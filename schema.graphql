type Account @entity {
  id: ID!
  "Events emitted by this account"
  events: [Event!]! @derivedFrom(field: "emitter")
  "Expressions deployed by this account"
  expressions: [Expression!] @derivedFrom(field: "account")
}

type Contract @entity {
  "Address of this contract"
  id: ID!
  "Bytecode hash of this contract"
  bytecodeHash: String
  deployTransaction: Transaction
  "The deployer used when added/deployed the contract"
  initialDeployer: ExpressionDeployer
  "The meta emmited"
  "the main RaindocumentMeta + all the cbor maps of that"
  meta: [Meta!]!
  "Expressions deployed via this contract."
  expressions: [Expression!] @derivedFrom(field: "sender")
  contractMeta: Bytes
  contractMetaHash: Bytes

  "The type of this contract. Eg: contract or proxy"
  type: String!
  "Optional implementation contract if the contract type is an implementation"
  implementation: Contract
}

type ExpressionDeployer @entity {
  "The address of this deployer."
  id: ID!
  deployTransaction: Transaction
  "Bytecode hash of this Deployer"
  bytecodeHash: String
  "The interpreter instance this deployer uses."
  interpreter: InterpreterInstance # get from ValidInterpreter.interpreter
  "The RainterpreterStore instance being used by the deployer"
  store: RainterpreterStoreInstance
  "The account that deployed this IExpressionDeployerV1"
  account: Account
  "functionPointers"
  functionPointers: String
  "Raw authoringMeta"
  authoringMeta: Bytes
  "Raw authoringMeta hash"
  authoringMetaHash: Bytes
  "Authoring meta"
  "the main RaindocumentMeta + all the cbor maps of that"
  meta: [Meta!]!
  "The deployed bytecode of the expressionDeployer contract that is being deployed"
  deployedBytecode: Bytes
  "The bytecode of the expressionDeployer"
  bytecode: Bytes
}

type Interpreter @entity {
  "Hash of the deployed bytecode for this interpreter."
  id: ID!
  "Instances of this interpreter"
  instances: [InterpreterInstance!]! @derivedFrom(field: "interpreter")
  "Expressions deployed by this interpreter"
  expressions: [Expression!] @derivedFrom(field: "interpreter")
}

type InterpreterInstance @entity {
  "Address of this interpreter instance"
  id: ID!
  interpreter: Interpreter!
  "Expressions deployed by this interpreter instance"
  expressions: [Expression!] @derivedFrom(field: "interpreterInstance")
}

type RainterpreterStore @entity {
  "Hash of the deployed bytecode for this RainterpreterStore."
  id: ID!
  "Instances of this store"
  instances: [RainterpreterStoreInstance!]! @derivedFrom(field: "store")
}

type RainterpreterStoreInstance @entity {
  "Address of the RainterpreterStore instance"
  id: ID!
  store: RainterpreterStore!
  "ExpressionDeployers using this store"
  deployers: [ExpressionDeployer!] @derivedFrom(field: "store")
}

type Expression @entity(immutable: true) {
  "Address for this expression"
  id: ID!
  event: DeployExpressionEvent!
  "Account that deployed this expression"
  account: Account!
  "The contract that this expression was deployed via"
  sender: Contract!
  interpreter: Interpreter!
  interpreterInstance: InterpreterInstance!
  config: StateConfig!
}

type DeployExpressionEvent implements Event @entity(immutable: true) {
  id: ID!
  "Transaction this event was emitted in."
  transaction: Transaction!
  "Account that sent the transaction this event was emitted in."
  emitter: Account!
  timestamp: BigInt!
  "Expression"
  expression: Expression! #map by DeployExpression.expressionAddress
}

interface Event {
  id: ID!
  "Transaction this event was emitted in."
  transaction: Transaction!
  "Account that sent the transaction this event was emitted in."
  emitter: Account!
  timestamp: BigInt!
}

type Transaction @entity(immutable: true) {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  events: [Event!] @derivedFrom(field: "transaction")
}

type StateConfig @entity {
  id: ID!
  bytecode: Bytes!
  constants: [BigInt!]!
  minOutputs: [BigInt!]!
}

type Meta @entity {
  "The hash of the meta raw bytes, this basically is the hash of 'rawBytes' field"
  "for RainDocument metas emitted by contracts this is already known (i guess?), but for each cbor map needs to be calculated"
  id: Bytes!
  "The raw bytes, hash of this field is basically the 'id'"
  "for RainDocument metas emitted by contracts this is already known, but for each cbor map, this will basically be the **PAYLOAD**"
  rawBytes: Bytes!
  "The contract address that emitted this record"
  contracts: [ID!]!
  "The magic number that is used to track the payload"
  magicNumber: BigInt!
  "If this record is Raindocument meta (emitted directly from contract) will be false, if it is a cbor map it will be true"
  type: bool!
  "RainDocuments that had this record as one their cbor maps, only will be filled if 'type' is true, else it will be an empty array"
  parents: [Meta!]!
  "Cbor maps that this RainDocument had as its content, only will be filled if 'type' is false, else it will be an empty array"
  childs: [Meta!]!


  "here comes the optional props, which are only needed for cbor maps records"
  "so these props will only be filled if 'type' is true, else they will be null"

  "The header name info for Content-Type"
  contentType: String
  "The header name info for Content-Encoding. It's optional"
  contentEncoding: String
  "The header name info for Content-Language. It's optional"
  contentLanguage: String
  "note that since we have payload as 'rawBytes' we dont need it here as in 'payload' field"
  "note that since we have magic number as 'magicNumber' field we dont need it again here"
}

# type RainMetaV1 @entity {
#   "Hash of the meta directly emitted by the contract"
#   id: Bytes! # Include the RainMeta MagicNumber.
#   "Original meta bytes directly emitted from the contract"
#   metaBytes: Bytes! # Original meta bytes emitted from the contract
#   "The meta content V1 decoded from the meta bytes emitted"
#   content: [MetaContentV1!] @derivedFrom(field: "documents")
# }

# type MetaContentV1 @entity {
#   "The hash of the Map Rain Meta document or CBOR Item"
#   id: Bytes! # Hash of the whole stringify data.
#   "Original item/document data bytes"
#   encodedData: Bytes!
#   "The payload present on the index 0 of the Rain meta Document"
#   payload: Bytes!
#   "The magic number that is used to track the payload"
#   magicNumber: BigInt!
#   "The header name info for Content-Type"
#   contentType: String
#   "The header name info for Content-Encoding. It's optional"
#   contentEncoding: String
#   "The header name info for Content-Language. It's optional"
#   contentLanguage: String
#   "RainMeta documents bytes that have this content"
#   documents: [RainMetaV1!]!
# }