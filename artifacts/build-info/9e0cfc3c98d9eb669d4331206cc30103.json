{"id":"9e0cfc3c98d9eb669d4331206cc30103","_format":"hh-sol-build-info-1","solcVersion":"0.8.18","solcLongVersion":"0.8.18+commit.87f61d96","input":{"language":"Solidity","sources":{"contracts/test/factory/CloneFactoryExists.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity =0.8.18;\n\n// just import clone factory so it exists for tests to deploy.\nimport \"rain.factory/concrete/CloneFactory.sol\";"},"lib/openzeppelin-contracts/contracts/proxy/Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"},"lib/rain.factory/src/concrete/CloneFactory.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity =0.8.18;\n\nimport \"../interface/ICloneableV1.sol\";\nimport \"../interface/ICloneableFactoryV1.sol\";\nimport \"rain.interpreter/abstract/DeployerDiscoverableMetaV1.sol\";\nimport {Clones} from \"openzeppelin-contracts/contracts/proxy/Clones.sol\";\n\n/// Thrown when an implementation is the zero address which is always a mistake.\nerror ZeroImplementation();\n\nbytes32 constant CLONE_FACTORY_META_HASH = bytes32(0xae0fb5b68fe1791c72509bf46ea6abf6a982d21451265be0a017f7959712a67e);\n\ncontract CloneFactory is ICloneableFactoryV1, DeployerDiscoverableMetaV1 {\n    constructor(DeployerDiscoverableMetaV1ConstructionConfig memory config_)\n        DeployerDiscoverableMetaV1(CLONE_FACTORY_META_HASH, config_)\n    {}\n\n    /// @inheritdoc ICloneableFactoryV1\n    function clone(address implementation_, bytes calldata data_) external returns (address) {\n        if (implementation_ == address(0)) {\n            revert ZeroImplementation();\n        }\n        address clone_ = Clones.clone(implementation_);\n        emit NewClone(msg.sender, implementation_, clone_);\n        ICloneableV1(clone_).initialize(data_);\n        return clone_;\n    }\n}\n"},"lib/rain.factory/src/interface/ICloneableFactoryV1.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity ^0.8.18;\n\n/// @title ICloneableFactoryV1\n/// @notice A minimal interface to create proxy clones of a reference bytecode\n/// and emit events so that indexers can discover it. `ICloneableFactoryV1` knows\n/// nothing about the contracts that it clones, instead relying only on the\n/// minimal `ICloneableV1` interface being implemented on the reference bytecode.\ninterface ICloneableFactoryV1 {\n    /// Emitted upon each `clone`.\n    /// @param sender The `msg.sender` that called `clone`.\n    /// @param implementation The reference bytecode to clone as a proxy.\n    /// @param clone The address of the new proxy contract.\n    event NewClone(address sender, address implementation, address clone);\n\n    /// Clones an implementation using a proxy. EIP1167 proxy as used by Open\n    /// Zeppelin is recommended but the exact cloning procedure is not specified\n    /// by this interface. The factory MUST call `ICloneableV1.initialize`\n    /// atomically with the cloning process and MUST NOT call any other functions\n    /// on the cloned proxy before initialize completes successfully. If the\n    /// initialize reverts then the `clone` MUST revert.\n    /// MUST emit `NewClone` with the implementation and clone address.\n    /// @param implementation The contract to clone.\n    /// @param data As per `ICloneableV1`.\n    /// @return New child contract address.\n    function clone(address implementation, bytes calldata data) external returns (address);\n}\n"},"lib/rain.factory/src/interface/ICloneableV1.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity ^0.8.18;\n\n/// @title ICloneableV1\n/// @notice Minimal interface following the Open Zeppelin conventions for\n/// initializing a cloned proxy.\ninterface ICloneableV1 {\n    /// Initialize is intended to work like constructors but for cloneable\n    /// proxies. The `ICloneableV1` contract MUST ensure that initialize cannot\n    /// be called more than once. The `ICloneableV1` contract is designed to be\n    /// deployed by an `ICloneFactoryV1` but MUST NOT assume that it will be. It\n    /// is possible for someone to directly deploy an `ICloneableV1` and fail to\n    /// call initialize before other functions are called, and end users MAY NOT\n    /// realise or know how to confirm a safe deployment state. The\n    /// `ICloneableV1` MUST take appropriate measures to ensure that functions\n    /// called before initialize are safe to do so, or revert.\n    ///\n    /// To be fully generic `initilize` accepts `bytes` and so MUST ABI decode\n    /// within the initialize function. This allows the factory to service\n    /// arbitrary cloneable proxies but also erases the type of the\n    /// initialization config from the ABI. One workaround is to emit an event\n    /// containing the initialization config type, so that the type appears\n    /// within the event and therefore the ABI.\n    /// @param data The initialization data.\n    function initialize(bytes calldata data) external;\n}\n"},"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity ^0.8.18;\n\nimport \"rain.metadata/IMetaV1.sol\";\nimport \"rain.metadata/LibMeta.sol\";\nimport \"../lib/LibDeployerDiscoverable.sol\";\n\n/// Construction config for `DeployerDiscoverableMetaV1`.\n/// @param deployer Deployer the calling contract will be discoverable under.\n/// @param meta MetaV1 data to emit before touching the deployer.\nstruct DeployerDiscoverableMetaV1ConstructionConfig {\n    address deployer;\n    bytes meta;\n}\n\n/// @title DeployerDiscoverableMetaV1\n/// @notice Upon construction, checks metadata against a known hash, emits it\n/// then touches the deployer (deploy an empty expression). This allows indexers\n/// to discover the metadata of the `DeployerDiscoverableMetaV1` contract by\n/// indexing the deployer. In this way the deployer acts as a pseudo-registry by\n/// virtue of it being a natural hub for interactions with calling contracts.\nabstract contract DeployerDiscoverableMetaV1 is IMetaV1 {\n    constructor(bytes32 metaHash, DeployerDiscoverableMetaV1ConstructionConfig memory config) {\n        LibMeta.checkMetaHashed(metaHash, config.meta);\n        emit MetaV1(msg.sender, uint256(uint160(address(this))), config.meta);\n        LibDeployerDiscoverable.touchDeployer(config.deployer);\n    }\n}\n"},"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity ^0.8.18;\n\nimport \"./IInterpreterV1.sol\";\n\n/// @title IExpressionDeployerV1\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\n/// coupled at the bytecode level to some interpreter that it knows how to\n/// analyse and deploy expressions for. The expression deployer can perform an\n/// integrity check \"dry run\" of candidate source code for the intepreter. The\n/// critical analysis/transformation includes:\n///\n/// - Enforcement of no out of bounds memory reads/writes\n/// - Calculation of memory required to eval the stack with a single allocation\n/// - Replacing index based opcodes with absolute interpreter function pointers\n/// - Enforcement that all opcodes and operands used exist and are valid\n///\n/// This analysis is highly sensitive to the specific implementation and position\n/// of all opcodes and function pointers as compiled into the interpreter. This\n/// is what makes the coupling between an interpreter and expression deployer\n/// so tight. Ideally all responsibilities would be handled by a single contract\n/// but this introduces code size issues quickly by roughly doubling the compiled\n/// logic of each opcode (half for the integrity check and half for evaluation).\n///\n/// Interpreters MUST assume that expression deployers are malicious and fail\n/// gracefully if the integrity check is corrupt/bypassed and/or function\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\n/// responsibility to do everything it can to prevent undefined behaviour in the\n/// interpreter, and the interpreter's responsibility to handle the expression\n/// deployer completely failing to do so.\ninterface IExpressionDeployerV1 {\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\n    /// sense of the opcodes in this interpreter deployment, as a human. For\n    /// formats like json that make heavy use of boilerplate, repetition and\n    /// whitespace, some kind of compression is recommended.\n    /// @param sender The `msg.sender` providing the op meta.\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\n    /// etc. and is intended for offchain consumption.\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\n\n    /// Expressions are expected to be deployed onchain as immutable contract\n    /// code with a first class address like any other contract or account.\n    /// Technically this is optional in the sense that all the tools required to\n    /// eval some expression and define all its opcodes are available as\n    /// libraries.\n    ///\n    /// In practise there are enough advantages to deploying the sources directly\n    /// onchain as contract data and loading them from the interpreter at eval:\n    ///\n    /// - Loading and storing binary data is gas efficient as immutable contract\n    ///   data\n    /// - Expressions need to be immutable between their deploy time integrity\n    ///   check and runtime evaluation\n    /// - Passing the address of an expression through calldata to an interpreter\n    ///   is cheaper than passing an entire expression through calldata\n    /// - Conceptually a very simple approach, even if implementations like\n    ///   SSTORE2 are subtle under the hood\n    ///\n    /// The expression deployer MUST perform an integrity check of the source\n    /// code before it puts the expression onchain at a known address. The\n    /// integrity check MUST at a minimum (it is free to do additional static\n    /// analysis) calculate the memory required to be allocated for the stack in\n    /// total, and that no out of bounds memory reads/writes occur within this\n    /// stack. A simple example of an invalid source would be one that pushes one\n    /// value to the stack then attempts to pops two values, clearly we cannot\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\n    /// in the case of any integrity failure, all integrity checks MUST pass in\n    /// order for the deployment to complete.\n    ///\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\n    /// any additional processing required by its paired interpreter.\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\n    /// from the corresponding interpreter.\n    ///\n    /// @param sources Sources verbatim. These sources MUST be provided in their\n    /// sequential/index opcode form as the deployment process will need to index\n    /// into BOTH the integrity check and the final runtime function pointers.\n    /// This will be emitted in an event for offchain processing to use the\n    /// indexed opcode sources. The first N sources are considered entrypoints\n    /// and will be integrity checked by the expression deployer against a\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\n    /// internal use such as the `call` opcode but will NOT be integrity checked\n    /// UNLESS entered by an opcode in an entrypoint.\n    /// @param constants Constants verbatim. Constants are provided alongside\n    /// sources rather than inline as it allows us to avoid variable length\n    /// opcodes and can be more memory efficient if the same constant is\n    /// referenced several times from the sources.\n    /// @param minOutputs The first N sources on the state config are entrypoints\n    /// to the expression where N is the length of the `minOutputs` array. Each\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\n    /// be present on the final stack for an evaluation of each entrypoint. The\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\n    /// the expression only applies checks and error logic. Non-entrypoint\n    /// sources MUST NOT have a minimum outputs length specified.\n    /// @return interpreter The interpreter the deployer believes it is qualified\n    /// to perform integrity checks on behalf of.\n    /// @return store The interpreter store the deployer believes is compatible\n    /// with the interpreter.\n    /// @return expression The address of the deployed onchain expression. MUST\n    /// be valid according to all integrity checks the deployer is aware of.\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\n        external\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\n}\n"},"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity ^0.8.18;\n\nimport \"./IInterpreterV1.sol\";\n\n/// A fully qualified namespace includes the interpreter's own namespacing logic\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\n/// allow either the caller nor any expression/word to modify this directly on\n/// pain of potential key collisions on writes to the interpreter's own storage.\ntype FullyQualifiedNamespace is uint256;\n\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\n\n/// @title IInterpreterStoreV1\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\n/// handle state changes for many calling contracts, many interpreters and many\n/// expressions. The store is responsible for ensuring that applying these state\n/// changes is safe from key collisions with calls to `set` from different\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\n/// state changes associated with some other caller.\n///\n/// The store defines the shape of its own state changes, which is opaque to the\n/// calling contract. For example, some store may treat the list of state changes\n/// as a pairwise key/value set, and some other store may treat it as a literal\n/// list to be stored as-is.\n///\n/// Each interpreter decides for itself which store to use based on the\n/// compatibility of its own opcodes.\n///\n/// The store MUST assume the state changes have been corrupted by the calling\n/// contract due to bugs or malicious intent, and enforce state isolation between\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\n/// it can detect invalid state changes, such as a key/value list having an odd\n/// number of items, but this MAY NOT be possible if the corruption is\n/// undetectable.\ninterface IInterpreterStoreV1 {\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\n    /// defines the meaning of the `uint256[]` for its own storage logic.\n    ///\n    /// @param namespace The unqualified namespace for the set that MUST be\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\n    /// between callers. The fully qualified namespace forms a compound key with\n    /// the keys for each value to set.\n    /// @param kvs The list of changes to apply to the store's internal state.\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\n\n    /// Given a fully qualified namespace and key, return the associated value.\n    /// Ostensibly the interpreter can use this to implement opcodes that read\n    /// previously set values. The interpreter MUST apply the same qualification\n    /// logic as the store that it uses to guarantee consistent round tripping of\n    /// data and prevent malicious behaviours. Technically also allows onchain\n    /// reads of any set value from any contract, not just interpreters, but in\n    /// this case readers MUST be aware and handle inconsistencies between get\n    /// and set while the state changes are still in memory in the calling\n    /// context and haven't yet been persisted to the store.\n    ///\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\n    /// @param namespace The fully qualified namespace to get a single value for.\n    /// @param key The key to get the value for within the namespace.\n    /// @return The value OR ZERO IF NOT SET.\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\n}\n"},"lib/rain.interpreter/src/interface/IInterpreterV1.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity ^0.8.18;\n\nimport \"./IInterpreterStoreV1.sol\";\n\n/// @dev The index of a source within a deployed expression that can be evaluated\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\n/// internally such as by the `call` opcode.\ntype SourceIndex is uint16;\n\n/// @dev Encoded information about a specific evaluation including the expression\n/// address onchain, entrypoint and expected return values.\ntype EncodedDispatch is uint256;\n\n/// @dev The namespace for state changes as requested by the calling contract.\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\n/// caller etc.\ntype StateNamespace is uint256;\n\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\n/// Commonly used to specify the number of inputs to a variadic function such\n/// as addition or multiplication.\ntype Operand is uint256;\n\n/// @dev The default state namespace MUST be used when a calling contract has no\n/// particular opinion on or need for dynamic namespaces.\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\n\n/// @title IInterpreterV1\n/// Interface into a standard interpreter that supports:\n///\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\n///   to the evaluated logic\n/// - handling subsequent state changes in bulk in response to evaluated logic\n/// - namespacing state changes according to the caller's preferences to avoid\n///   unwanted key collisions\n/// - exposing its internal function pointers to support external precompilation\n///   of logic for more gas efficient runtime evaluation by the interpreter\n///\n/// The interface is designed to be stable across many versions and\n/// implementations of an interpreter, balancing minimalism with features\n/// required for a general purpose onchain interpreted compute environment.\n///\n/// The security model of an interpreter is that it MUST be resilient to\n/// malicious expressions even if they dispatch arbitrary internal function\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\n/// undefined behaviour or error during an eval, _provided that no state changes\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\n/// malicious expression can be negatively impacted by the result. In turn, the\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\n/// return values from any interpreter that it requests an expression from. And\n/// so on and so forth up to the externally owned account (EOA) who signs the\n/// transaction and agrees to a specific combination of contracts, expressions\n/// and interpreters, who can presumably make an informed decision about which\n/// ones to trust to get the job done.\n///\n/// The state changes for an interpreter are expected to be produces by an `eval`\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\n/// caller, after the caller has had an opportunity to apply their own\n/// intermediate logic such as reentrancy defenses against malicious\n/// interpreters. The interpreter is free to structure the state changes however\n/// it wants but MUST guard against the calling contract corrupting the changes\n/// between `eval` and `set`. For example a store could sandbox storage writes\n/// per-caller so that a malicious caller can only damage their own state\n/// changes, while honest callers respect, benefit from and are protected by the\n/// interpreter store's state change handling.\n///\n/// The two step eval-state model allows eval to be read-only which provides\n/// security guarantees for the caller such as no stateful reentrancy, either\n/// from the interpreter or some contract interface used by some word, while\n/// still allowing for storage writes. As the storage writes happen on the\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\n/// need to trust the interpreter, which allows for permissionless selection of\n/// interpreters by end users. Delegate call always implies an admin key on the\n/// caller because the delegatee contract can write arbitrarily to the state of\n/// the delegator, which severely limits the generality of contract composition.\ninterface IInterpreterV1 {\n    /// Exposes the function pointers as `uint16` values packed into a single\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\n    ///\n    /// `IExpressionDeployerV1` contracts use these function pointers to\n    /// \"compile\" the expression into something that an interpreter can dispatch\n    /// directly without paying gas to lookup the same at runtime. As the\n    /// validity of any integrity check and subsequent dispatch is highly\n    /// sensitive to both the function pointers and overall bytecode of the\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\n    /// against accidentally being deployed onchain paired against an unknown\n    /// interpreter. It is very easy for an apparent compatible pairing to be\n    /// subtly and critically incompatible due to addition/removal/reordering of\n    /// opcodes and compiler optimisations on the interpreter bytecode.\n    ///\n    /// This MAY return different values during construction vs. all other times\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\n    /// on function pointers reported during contract construction.\n    function functionPointers() external view returns (bytes memory);\n\n    /// The raison d'etre for an interpreter. Given some expression and per-call\n    /// additional contextual data, produce a stack of results and a set of state\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\n    /// call to `IInterpreterStoreV1.set`.\n    /// @param store The storage contract that the returned key/value pairs\n    /// MUST be passed to IF the calling contract is in a non-static calling\n    /// context. Static calling contexts MUST pass `address(0)`.\n    /// @param namespace The state namespace that will be fully qualified by the\n    /// interpreter at runtime in order to perform gets on the underlying store.\n    /// MUST be the same namespace passed to the store by the calling contract\n    /// when sending the resulting key/value items to storage.\n    /// @param dispatch All the information required for the interpreter to load\n    /// an expression, select an entrypoint and return the values expected by the\n    /// caller. The interpreter MAY encode dispatches differently to\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\n    /// calling contracts that hardcode the encoding logic.\n    /// @param context A 2-dimensional array of data that can be indexed into at\n    /// runtime by the interpreter. The calling contract is responsible for\n    /// ensuring the authenticity and completeness of context data. The\n    /// interpreter MUST revert at runtime if an expression attempts to index\n    /// into some context value that is not provided by the caller. This implies\n    /// that context reads cannot be checked for out of bounds reads at deploy\n    /// time, as the runtime context MAY be provided in a different shape to what\n    /// the expression is expecting.\n    /// Same as `eval` but allowing the caller to specify a namespace under which\n    /// the state changes will be applied. The interpeter MUST ensure that keys\n    /// will never collide across namespaces, even if, for example:\n    ///\n    /// - The calling contract is malicious and attempts to craft a collision\n    ///   with state changes from another contract\n    /// - The expression is malicious and attempts to craft a collision with\n    ///   other expressions evaluated by the same calling contract\n    ///\n    /// A malicious entity MAY have access to significant offchain resources to\n    /// attempt to precompute key collisions through brute force. The collision\n    /// resistance of namespaces should be comparable or equivalent to the\n    /// collision resistance of the hashing algorithms employed by the blockchain\n    /// itself, such as the design of `mapping` in Solidity that hashes each\n    /// nested key to produce a collision resistant compound key.\n    /// @return stack The list of values produced by evaluating the expression.\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\n    /// applicable.\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\n    function eval(\n        IInterpreterStoreV1 store,\n        StateNamespace namespace,\n        EncodedDispatch dispatch,\n        uint256[][] calldata context\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\n}\n"},"lib/rain.interpreter/src/lib/LibDeployerDiscoverable.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity ^0.8.18;\n\nimport \"../interface/IExpressionDeployerV1.sol\";\n\nlibrary LibDeployerDiscoverable {\n    /// Hack so that some deployer will emit an event with the sender as the\n    /// caller of `touchDeployer`. This MAY be needed by indexers such as\n    /// subgraph that can only index events from the first moment they are aware\n    /// of some contract. The deployer MUST be registered in ERC1820 registry\n    /// before it is touched, THEN the caller meta MUST be emitted after the\n    /// deployer is touched. This allows indexers such as subgraph to index the\n    /// deployer, then see the caller, then see the caller's meta emitted in the\n    /// same transaction.\n    /// This is NOT required if ANY other expression is deployed in the same\n    /// transaction as the caller meta, there only needs to be one expression on\n    /// ANY deployer known to ERC1820.\n    function touchDeployer(address deployer) internal {\n        (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression) =\n            IExpressionDeployerV1(deployer).deployExpression(new bytes[](0), new uint256[](0), new uint256[](0));\n        (interpreter);\n        (store);\n        (expression);\n    }\n}\n"},"lib/rain.metadata/src/IMetaV1.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity ^0.8.18;\n\n/// Thrown when hashed metadata does NOT match the expected hash.\n/// @param expectedHash The hash expected by the `IMetaV1` contract.\n/// @param actualHash The hash of the metadata seen by the `IMetaV1` contract.\nerror UnexpectedMetaHash(bytes32 expectedHash, bytes32 actualHash);\n\n/// Thrown when some bytes are expected to be rain meta and are not.\n/// @param unmeta the bytes that are not meta.\nerror NotRainMetaV1(bytes unmeta);\n\n/// @dev Randomly generated magic number with first bytes oned out.\n/// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\nuint64 constant META_MAGIC_NUMBER_V1 = 0xff0a89c674ee7874;\n\n/// @title IMetaV1\ninterface IMetaV1 {\n    /// An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\n    /// to the metadata so that tooling can easily drop/ignore data from unknown\n    /// sources. As metadata is about something, the subject MUST be provided.\n    /// @param sender The msg.sender.\n    /// @param subject The entity that the metadata is about. MAY be the address\n    /// of the emitting contract (as `uint256`) OR anything else. The\n    /// interpretation of the subject is context specific, so will often be a\n    /// hash of some data/thing that this metadata is about.\n    /// @param meta Rain metadata V1 compliant metadata bytes.\n    /// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\n    event MetaV1(address sender, uint256 subject, bytes meta);\n}\n"},"lib/rain.metadata/src/LibMeta.sol":{"content":"// SPDX-License-Identifier: CAL\npragma solidity ^0.8.18;\n\nimport \"./IMetaV1.sol\";\n\n/// @title LibMeta\n/// @notice Need a place to put data that can be handled offchain like ABIs that\n/// IS NOT etherscan.\nlibrary LibMeta {\n    /// Returns true if the metadata bytes are prefixed by the Rain meta magic\n    /// number. DOES NOT attempt to validate the body of the metadata as offchain\n    /// tooling will be required for this.\n    /// @param meta_ The data that may be rain metadata.\n    /// @return True if `meta_` is metadata, false otherwise.\n    function isRainMetaV1(bytes memory meta_) internal pure returns (bool) {\n        if (meta_.length < 8) return false;\n        uint256 mask_ = type(uint64).max;\n        uint256 magicNumber_ = META_MAGIC_NUMBER_V1;\n        assembly (\"memory-safe\") {\n            magicNumber_ := and(mload(add(meta_, 8)), mask_)\n        }\n        return magicNumber_ == META_MAGIC_NUMBER_V1;\n    }\n\n    /// Reverts if the provided `meta_` is NOT metadata according to\n    /// `isRainMetaV1`.\n    /// @param meta_ The metadata bytes to check.\n    function checkMetaUnhashed(bytes memory meta_) internal pure {\n        if (!isRainMetaV1(meta_)) {\n            revert NotRainMetaV1(meta_);\n        }\n    }\n\n    /// Reverts if the provided `meta_` is NOT metadata according to\n    /// `isRainMetaV1` OR it does not match the expected hash of its data.\n    /// @param meta_ The metadata to check.\n    function checkMetaHashed(bytes32 expectedHash_, bytes memory meta_) internal pure {\n        bytes32 actualHash_ = keccak256(meta_);\n        if (expectedHash_ != actualHash_) {\n            revert UnexpectedMetaHash(expectedHash_, actualHash_);\n        }\n        checkMetaUnhashed(meta_);\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":1000000,"details":{"peephole":true,"inliner":true,"jumpdestRemover":true,"orderLiterals":true,"deduplicate":true,"cse":true,"constantOptimizer":true}},"evmVersion":"london","metadata":{"appendCBOR":false,"useLiteralContent":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"],"":["ast"]}},"remappings":["ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/","rain.cooldown/=lib/rain.cooldown/src/","rain.factory/=lib/rain.factory/src/","rain.flow/=lib/rain.flow/src/","rain.interface.sale/=lib/rain.interface.sale/src/","rain.interpreter/=lib/rain.interpreter/src/","rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/","rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/","rain.lib.typecast/=lib/rain.lib.typecast/src/","rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/","rain.math.saturating/=lib/rain.math.saturating/src/","rain.metadata/=lib/rain.metadata/src/","rain.orderbook/=lib/rain.orderbook/","sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/","sol.lib.datacontract/=lib/sol.lib.datacontract/src/","sol.lib.memory/=lib/sol.lib.memory/src/"]}},"output":{"sources":{"contracts/test/factory/CloneFactoryExists.sol":{"ast":{"absolutePath":"contracts/test/factory/CloneFactoryExists.sol","exportedSymbols":{"CLONE_FACTORY_META_HASH":[98],"CloneFactory":[159],"Clones":[82],"DEFAULT_STATE_NAMESPACE":[342],"DeployerDiscoverableMetaV1":[247],"DeployerDiscoverableMetaV1ConstructionConfig":[202],"EncodedDispatch":[330],"FullyQualifiedNamespace":[291],"ICloneableFactoryV1":[182],"ICloneableV1":[192],"IExpressionDeployerV1":[286],"IInterpreterStoreV1":[323],"IInterpreterV1":[373],"IMetaV1":[451],"LibDeployerDiscoverable":[422],"LibMeta":[535],"META_MAGIC_NUMBER_V1":[440],"NO_STORE":[300],"NotRainMetaV1":[436],"Operand":[334],"SourceIndex":[328],"StateNamespace":[332],"UnexpectedMetaHash":[431],"ZeroImplementation":[92]},"id":3,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":1,"literals":["solidity","=","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:0"},{"absolutePath":"lib/rain.factory/src/concrete/CloneFactory.sol","file":"rain.factory/concrete/CloneFactory.sol","id":2,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":3,"sourceUnit":160,"src":"121:48:0","symbolAliases":[],"unitAlias":""}],"src":"32:137:0"},"id":0},"lib/openzeppelin-contracts/contracts/proxy/Clones.sol":{"ast":{"absolutePath":"lib/openzeppelin-contracts/contracts/proxy/Clones.sol","exportedSymbols":{"Clones":[82]},"id":83,"license":"MIT","nodeType":"SourceUnit","nodes":[{"id":4,"literals":["solidity","^","0.8",".0"],"nodeType":"PragmaDirective","src":"100:23:1"},{"abstract":false,"baseContracts":[],"canonicalName":"Clones","contractDependencies":[],"contractKind":"library","documentation":{"id":5,"nodeType":"StructuredDocumentation","src":"125:629:1","text":" @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n deploying minimal proxy contracts, also known as \"clones\".\n > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n deterministic method.\n _Available since v3.4._"},"fullyImplemented":true,"id":82,"linearizedBaseContracts":[82],"name":"Clones","nameLocation":"763:6:1","nodeType":"ContractDefinition","nodes":[{"body":{"id":24,"nodeType":"Block","src":"1048:684:1","statements":[{"AST":{"nodeType":"YulBlock","src":"1110:549:1","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1315:4:1","type":"","value":"0x00"},{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1328:4:1","type":"","value":"0xe8"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1338:4:1","type":"","value":"0x60"},{"name":"implementation","nodeType":"YulIdentifier","src":"1344:14:1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"1334:3:1"},"nodeType":"YulFunctionCall","src":"1334:25:1"}],"functionName":{"name":"shr","nodeType":"YulIdentifier","src":"1324:3:1"},"nodeType":"YulFunctionCall","src":"1324:36:1"},{"kind":"number","nodeType":"YulLiteral","src":"1362:48:1","type":"","value":"0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000"}],"functionName":{"name":"or","nodeType":"YulIdentifier","src":"1321:2:1"},"nodeType":"YulFunctionCall","src":"1321:90:1"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1308:6:1"},"nodeType":"YulFunctionCall","src":"1308:104:1"},"nodeType":"YulExpressionStatement","src":"1308:104:1"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1533:4:1","type":"","value":"0x20"},{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1546:4:1","type":"","value":"0x78"},{"name":"implementation","nodeType":"YulIdentifier","src":"1552:14:1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"1542:3:1"},"nodeType":"YulFunctionCall","src":"1542:25:1"},{"kind":"number","nodeType":"YulLiteral","src":"1569:32:1","type":"","value":"0x5af43d82803e903d91602b57fd5bf3"}],"functionName":{"name":"or","nodeType":"YulIdentifier","src":"1539:2:1"},"nodeType":"YulFunctionCall","src":"1539:63:1"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1526:6:1"},"nodeType":"YulFunctionCall","src":"1526:77:1"},"nodeType":"YulExpressionStatement","src":"1526:77:1"},{"nodeType":"YulAssignment","src":"1616:33:1","value":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1635:1:1","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1638:4:1","type":"","value":"0x09"},{"kind":"number","nodeType":"YulLiteral","src":"1644:4:1","type":"","value":"0x37"}],"functionName":{"name":"create","nodeType":"YulIdentifier","src":"1628:6:1"},"nodeType":"YulFunctionCall","src":"1628:21:1"},"variableNames":[{"name":"instance","nodeType":"YulIdentifier","src":"1616:8:1"}]}]},"documentation":"@solidity memory-safe-assembly","evmVersion":"london","externalReferences":[{"declaration":8,"isOffset":false,"isSlot":false,"src":"1344:14:1","valueSize":1},{"declaration":8,"isOffset":false,"isSlot":false,"src":"1552:14:1","valueSize":1},{"declaration":11,"isOffset":false,"isSlot":false,"src":"1616:8:1","valueSize":1}],"id":13,"nodeType":"InlineAssembly","src":"1101:558:1"},{"expression":{"arguments":[{"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":20,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":15,"name":"instance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":11,"src":"1676:8:1","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"arguments":[{"hexValue":"30","id":18,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"1696:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":17,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"1688:7:1","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":16,"name":"address","nodeType":"ElementaryTypeName","src":"1688:7:1","typeDescriptions":{}}},"id":19,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1688:10:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"1676:22:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},{"hexValue":"455243313136373a20637265617465206661696c6564","id":21,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"1700:24:1","typeDescriptions":{"typeIdentifier":"t_stringliteral_68ca40b61460257f14e69f48b1a4dbc812e9afc6932f127ef8084544457b3335","typeString":"literal_string \"ERC1167: create failed\""},"value":"ERC1167: create failed"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"},{"typeIdentifier":"t_stringliteral_68ca40b61460257f14e69f48b1a4dbc812e9afc6932f127ef8084544457b3335","typeString":"literal_string \"ERC1167: create failed\""}],"id":14,"name":"require","nodeType":"Identifier","overloadedDeclarations":[-18,-18],"referencedDeclaration":-18,"src":"1668:7:1","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$","typeString":"function (bool,string memory) pure"}},"id":22,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1668:57:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":23,"nodeType":"ExpressionStatement","src":"1668:57:1"}]},"documentation":{"id":6,"nodeType":"StructuredDocumentation","src":"776:192:1","text":" @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n This function uses the create opcode, which should never revert."},"id":25,"implemented":true,"kind":"function","modifiers":[],"name":"clone","nameLocation":"982:5:1","nodeType":"FunctionDefinition","parameters":{"id":9,"nodeType":"ParameterList","parameters":[{"constant":false,"id":8,"mutability":"mutable","name":"implementation","nameLocation":"996:14:1","nodeType":"VariableDeclaration","scope":25,"src":"988:22:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":7,"name":"address","nodeType":"ElementaryTypeName","src":"988:7:1","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"987:24:1"},"returnParameters":{"id":12,"nodeType":"ParameterList","parameters":[{"constant":false,"id":11,"mutability":"mutable","name":"instance","nameLocation":"1038:8:1","nodeType":"VariableDeclaration","scope":25,"src":"1030:16:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":10,"name":"address","nodeType":"ElementaryTypeName","src":"1030:7:1","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"1029:18:1"},"scope":82,"src":"973:759:1","stateMutability":"nonpayable","virtual":false,"visibility":"internal"},{"body":{"id":46,"nodeType":"Block","src":"2209:692:1","statements":[{"AST":{"nodeType":"YulBlock","src":"2271:556:1","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2476:4:1","type":"","value":"0x00"},{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2489:4:1","type":"","value":"0xe8"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2499:4:1","type":"","value":"0x60"},{"name":"implementation","nodeType":"YulIdentifier","src":"2505:14:1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"2495:3:1"},"nodeType":"YulFunctionCall","src":"2495:25:1"}],"functionName":{"name":"shr","nodeType":"YulIdentifier","src":"2485:3:1"},"nodeType":"YulFunctionCall","src":"2485:36:1"},{"kind":"number","nodeType":"YulLiteral","src":"2523:48:1","type":"","value":"0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000"}],"functionName":{"name":"or","nodeType":"YulIdentifier","src":"2482:2:1"},"nodeType":"YulFunctionCall","src":"2482:90:1"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2469:6:1"},"nodeType":"YulFunctionCall","src":"2469:104:1"},"nodeType":"YulExpressionStatement","src":"2469:104:1"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2694:4:1","type":"","value":"0x20"},{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2707:4:1","type":"","value":"0x78"},{"name":"implementation","nodeType":"YulIdentifier","src":"2713:14:1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"2703:3:1"},"nodeType":"YulFunctionCall","src":"2703:25:1"},{"kind":"number","nodeType":"YulLiteral","src":"2730:32:1","type":"","value":"0x5af43d82803e903d91602b57fd5bf3"}],"functionName":{"name":"or","nodeType":"YulIdentifier","src":"2700:2:1"},"nodeType":"YulFunctionCall","src":"2700:63:1"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2687:6:1"},"nodeType":"YulFunctionCall","src":"2687:77:1"},"nodeType":"YulExpressionStatement","src":"2687:77:1"},{"nodeType":"YulAssignment","src":"2777:40:1","value":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2797:1:1","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"2800:4:1","type":"","value":"0x09"},{"kind":"number","nodeType":"YulLiteral","src":"2806:4:1","type":"","value":"0x37"},{"name":"salt","nodeType":"YulIdentifier","src":"2812:4:1"}],"functionName":{"name":"create2","nodeType":"YulIdentifier","src":"2789:7:1"},"nodeType":"YulFunctionCall","src":"2789:28:1"},"variableNames":[{"name":"instance","nodeType":"YulIdentifier","src":"2777:8:1"}]}]},"documentation":"@solidity memory-safe-assembly","evmVersion":"london","externalReferences":[{"declaration":28,"isOffset":false,"isSlot":false,"src":"2505:14:1","valueSize":1},{"declaration":28,"isOffset":false,"isSlot":false,"src":"2713:14:1","valueSize":1},{"declaration":33,"isOffset":false,"isSlot":false,"src":"2777:8:1","valueSize":1},{"declaration":30,"isOffset":false,"isSlot":false,"src":"2812:4:1","valueSize":1}],"id":35,"nodeType":"InlineAssembly","src":"2262:565:1"},{"expression":{"arguments":[{"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":42,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":37,"name":"instance","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":33,"src":"2844:8:1","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"arguments":[{"hexValue":"30","id":40,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"2864:1:1","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":39,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"2856:7:1","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":38,"name":"address","nodeType":"ElementaryTypeName","src":"2856:7:1","typeDescriptions":{}}},"id":41,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2856:10:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"2844:22:1","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},{"hexValue":"455243313136373a2063726561746532206661696c6564","id":43,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"2868:25:1","typeDescriptions":{"typeIdentifier":"t_stringliteral_4ec050e530ce66e7658278ab7a4e4a2f19225159c48fc52eb249bd268e755d73","typeString":"literal_string \"ERC1167: create2 failed\""},"value":"ERC1167: create2 failed"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bool","typeString":"bool"},{"typeIdentifier":"t_stringliteral_4ec050e530ce66e7658278ab7a4e4a2f19225159c48fc52eb249bd268e755d73","typeString":"literal_string \"ERC1167: create2 failed\""}],"id":36,"name":"require","nodeType":"Identifier","overloadedDeclarations":[-18,-18],"referencedDeclaration":-18,"src":"2836:7:1","typeDescriptions":{"typeIdentifier":"t_function_require_pure$_t_bool_$_t_string_memory_ptr_$returns$__$","typeString":"function (bool,string memory) pure"}},"id":44,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2836:58:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":45,"nodeType":"ExpressionStatement","src":"2836:58:1"}]},"documentation":{"id":26,"nodeType":"StructuredDocumentation","src":"1738:364:1","text":" @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n This function uses the create2 opcode and a `salt` to deterministically deploy\n the clone. Using the same `implementation` and `salt` multiple time will revert, since\n the clones cannot be deployed twice at the same address."},"id":47,"implemented":true,"kind":"function","modifiers":[],"name":"cloneDeterministic","nameLocation":"2116:18:1","nodeType":"FunctionDefinition","parameters":{"id":31,"nodeType":"ParameterList","parameters":[{"constant":false,"id":28,"mutability":"mutable","name":"implementation","nameLocation":"2143:14:1","nodeType":"VariableDeclaration","scope":47,"src":"2135:22:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":27,"name":"address","nodeType":"ElementaryTypeName","src":"2135:7:1","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":30,"mutability":"mutable","name":"salt","nameLocation":"2167:4:1","nodeType":"VariableDeclaration","scope":47,"src":"2159:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":29,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2159:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"2134:38:1"},"returnParameters":{"id":34,"nodeType":"ParameterList","parameters":[{"constant":false,"id":33,"mutability":"mutable","name":"instance","nameLocation":"2199:8:1","nodeType":"VariableDeclaration","scope":47,"src":"2191:16:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":32,"name":"address","nodeType":"ElementaryTypeName","src":"2191:7:1","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"2190:18:1"},"scope":82,"src":"2107:794:1","stateMutability":"nonpayable","virtual":false,"visibility":"internal"},{"body":{"id":60,"nodeType":"Block","src":"3176:515:1","statements":[{"AST":{"nodeType":"YulBlock","src":"3238:447:1","statements":[{"nodeType":"YulVariableDeclaration","src":"3252:22:1","value":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"3269:4:1","type":"","value":"0x40"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"3263:5:1"},"nodeType":"YulFunctionCall","src":"3263:11:1"},"variables":[{"name":"ptr","nodeType":"YulTypedName","src":"3256:3:1","type":""}]},{"expression":{"arguments":[{"arguments":[{"name":"ptr","nodeType":"YulIdentifier","src":"3298:3:1"},{"kind":"number","nodeType":"YulLiteral","src":"3303:4:1","type":"","value":"0x38"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3294:3:1"},"nodeType":"YulFunctionCall","src":"3294:14:1"},{"name":"deployer","nodeType":"YulIdentifier","src":"3310:8:1"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3287:6:1"},"nodeType":"YulFunctionCall","src":"3287:32:1"},"nodeType":"YulExpressionStatement","src":"3287:32:1"},{"expression":{"arguments":[{"arguments":[{"name":"ptr","nodeType":"YulIdentifier","src":"3343:3:1"},{"kind":"number","nodeType":"YulLiteral","src":"3348:4:1","type":"","value":"0x24"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3339:3:1"},"nodeType":"YulFunctionCall","src":"3339:14:1"},{"kind":"number","nodeType":"YulLiteral","src":"3355:34:1","type":"","value":"0x5af43d82803e903d91602b57fd5bf3ff"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3332:6:1"},"nodeType":"YulFunctionCall","src":"3332:58:1"},"nodeType":"YulExpressionStatement","src":"3332:58:1"},{"expression":{"arguments":[{"arguments":[{"name":"ptr","nodeType":"YulIdentifier","src":"3414:3:1"},{"kind":"number","nodeType":"YulLiteral","src":"3419:4:1","type":"","value":"0x14"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3410:3:1"},"nodeType":"YulFunctionCall","src":"3410:14:1"},{"name":"implementation","nodeType":"YulIdentifier","src":"3426:14:1"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3403:6:1"},"nodeType":"YulFunctionCall","src":"3403:38:1"},"nodeType":"YulExpressionStatement","src":"3403:38:1"},{"expression":{"arguments":[{"name":"ptr","nodeType":"YulIdentifier","src":"3461:3:1"},{"kind":"number","nodeType":"YulLiteral","src":"3466:42:1","type":"","value":"0x3d602d80600a3d3981f3363d3d373d3d3d363d73"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3454:6:1"},"nodeType":"YulFunctionCall","src":"3454:55:1"},"nodeType":"YulExpressionStatement","src":"3454:55:1"},{"expression":{"arguments":[{"arguments":[{"name":"ptr","nodeType":"YulIdentifier","src":"3533:3:1"},{"kind":"number","nodeType":"YulLiteral","src":"3538:4:1","type":"","value":"0x58"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3529:3:1"},"nodeType":"YulFunctionCall","src":"3529:14:1"},{"name":"salt","nodeType":"YulIdentifier","src":"3545:4:1"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3522:6:1"},"nodeType":"YulFunctionCall","src":"3522:28:1"},"nodeType":"YulExpressionStatement","src":"3522:28:1"},{"expression":{"arguments":[{"arguments":[{"name":"ptr","nodeType":"YulIdentifier","src":"3574:3:1"},{"kind":"number","nodeType":"YulLiteral","src":"3579:4:1","type":"","value":"0x78"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3570:3:1"},"nodeType":"YulFunctionCall","src":"3570:14:1"},{"arguments":[{"arguments":[{"name":"ptr","nodeType":"YulIdentifier","src":"3600:3:1"},{"kind":"number","nodeType":"YulLiteral","src":"3605:4:1","type":"","value":"0x0c"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3596:3:1"},"nodeType":"YulFunctionCall","src":"3596:14:1"},{"kind":"number","nodeType":"YulLiteral","src":"3612:4:1","type":"","value":"0x37"}],"functionName":{"name":"keccak256","nodeType":"YulIdentifier","src":"3586:9:1"},"nodeType":"YulFunctionCall","src":"3586:31:1"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3563:6:1"},"nodeType":"YulFunctionCall","src":"3563:55:1"},"nodeType":"YulExpressionStatement","src":"3563:55:1"},{"nodeType":"YulAssignment","src":"3631:44:1","value":{"arguments":[{"arguments":[{"name":"ptr","nodeType":"YulIdentifier","src":"3658:3:1"},{"kind":"number","nodeType":"YulLiteral","src":"3663:4:1","type":"","value":"0x43"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3654:3:1"},"nodeType":"YulFunctionCall","src":"3654:14:1"},{"kind":"number","nodeType":"YulLiteral","src":"3670:4:1","type":"","value":"0x55"}],"functionName":{"name":"keccak256","nodeType":"YulIdentifier","src":"3644:9:1"},"nodeType":"YulFunctionCall","src":"3644:31:1"},"variableNames":[{"name":"predicted","nodeType":"YulIdentifier","src":"3631:9:1"}]}]},"documentation":"@solidity memory-safe-assembly","evmVersion":"london","externalReferences":[{"declaration":54,"isOffset":false,"isSlot":false,"src":"3310:8:1","valueSize":1},{"declaration":50,"isOffset":false,"isSlot":false,"src":"3426:14:1","valueSize":1},{"declaration":57,"isOffset":false,"isSlot":false,"src":"3631:9:1","valueSize":1},{"declaration":52,"isOffset":false,"isSlot":false,"src":"3545:4:1","valueSize":1}],"id":59,"nodeType":"InlineAssembly","src":"3229:456:1"}]},"documentation":{"id":48,"nodeType":"StructuredDocumentation","src":"2907:99:1","text":" @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}."},"id":61,"implemented":true,"kind":"function","modifiers":[],"name":"predictDeterministicAddress","nameLocation":"3020:27:1","nodeType":"FunctionDefinition","parameters":{"id":55,"nodeType":"ParameterList","parameters":[{"constant":false,"id":50,"mutability":"mutable","name":"implementation","nameLocation":"3065:14:1","nodeType":"VariableDeclaration","scope":61,"src":"3057:22:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":49,"name":"address","nodeType":"ElementaryTypeName","src":"3057:7:1","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":52,"mutability":"mutable","name":"salt","nameLocation":"3097:4:1","nodeType":"VariableDeclaration","scope":61,"src":"3089:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":51,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3089:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":54,"mutability":"mutable","name":"deployer","nameLocation":"3119:8:1","nodeType":"VariableDeclaration","scope":61,"src":"3111:16:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":53,"name":"address","nodeType":"ElementaryTypeName","src":"3111:7:1","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"3047:86:1"},"returnParameters":{"id":58,"nodeType":"ParameterList","parameters":[{"constant":false,"id":57,"mutability":"mutable","name":"predicted","nameLocation":"3165:9:1","nodeType":"VariableDeclaration","scope":61,"src":"3157:17:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":56,"name":"address","nodeType":"ElementaryTypeName","src":"3157:7:1","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"3156:19:1"},"scope":82,"src":"3011:680:1","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":80,"nodeType":"Block","src":"3946:88:1","statements":[{"expression":{"arguments":[{"id":72,"name":"implementation","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":64,"src":"3991:14:1","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":73,"name":"salt","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":66,"src":"4007:4:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"arguments":[{"id":76,"name":"this","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-28,"src":"4021:4:1","typeDescriptions":{"typeIdentifier":"t_contract$_Clones_$82","typeString":"library Clones"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_Clones_$82","typeString":"library Clones"}],"id":75,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"4013:7:1","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":74,"name":"address","nodeType":"ElementaryTypeName","src":"4013:7:1","typeDescriptions":{}}},"id":77,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"4013:13:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_address","typeString":"address"}],"id":71,"name":"predictDeterministicAddress","nodeType":"Identifier","overloadedDeclarations":[61,81],"referencedDeclaration":61,"src":"3963:27:1","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_address_$_t_bytes32_$_t_address_$returns$_t_address_$","typeString":"function (address,bytes32,address) pure returns (address)"}},"id":78,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"3963:64:1","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"functionReturnParameters":70,"id":79,"nodeType":"Return","src":"3956:71:1"}]},"documentation":{"id":62,"nodeType":"StructuredDocumentation","src":"3697:99:1","text":" @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}."},"id":81,"implemented":true,"kind":"function","modifiers":[],"name":"predictDeterministicAddress","nameLocation":"3810:27:1","nodeType":"FunctionDefinition","parameters":{"id":67,"nodeType":"ParameterList","parameters":[{"constant":false,"id":64,"mutability":"mutable","name":"implementation","nameLocation":"3846:14:1","nodeType":"VariableDeclaration","scope":81,"src":"3838:22:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":63,"name":"address","nodeType":"ElementaryTypeName","src":"3838:7:1","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":66,"mutability":"mutable","name":"salt","nameLocation":"3870:4:1","nodeType":"VariableDeclaration","scope":81,"src":"3862:12:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":65,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3862:7:1","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"3837:38:1"},"returnParameters":{"id":70,"nodeType":"ParameterList","parameters":[{"constant":false,"id":69,"mutability":"mutable","name":"predicted","nameLocation":"3931:9:1","nodeType":"VariableDeclaration","scope":81,"src":"3923:17:1","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":68,"name":"address","nodeType":"ElementaryTypeName","src":"3923:7:1","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"3922:19:1"},"scope":82,"src":"3801:233:1","stateMutability":"view","virtual":false,"visibility":"internal"}],"scope":83,"src":"755:3281:1","usedErrors":[]}],"src":"100:3937:1"},"id":1},"lib/rain.factory/src/concrete/CloneFactory.sol":{"ast":{"absolutePath":"lib/rain.factory/src/concrete/CloneFactory.sol","exportedSymbols":{"CLONE_FACTORY_META_HASH":[98],"CloneFactory":[159],"Clones":[82],"DEFAULT_STATE_NAMESPACE":[342],"DeployerDiscoverableMetaV1":[247],"DeployerDiscoverableMetaV1ConstructionConfig":[202],"EncodedDispatch":[330],"FullyQualifiedNamespace":[291],"ICloneableFactoryV1":[182],"ICloneableV1":[192],"IExpressionDeployerV1":[286],"IInterpreterStoreV1":[323],"IInterpreterV1":[373],"IMetaV1":[451],"LibDeployerDiscoverable":[422],"LibMeta":[535],"META_MAGIC_NUMBER_V1":[440],"NO_STORE":[300],"NotRainMetaV1":[436],"Operand":[334],"SourceIndex":[328],"StateNamespace":[332],"UnexpectedMetaHash":[431],"ZeroImplementation":[92]},"id":160,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":84,"literals":["solidity","=","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:2"},{"absolutePath":"lib/rain.factory/src/interface/ICloneableV1.sol","file":"../interface/ICloneableV1.sol","id":85,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":160,"sourceUnit":193,"src":"58:39:2","symbolAliases":[],"unitAlias":""},{"absolutePath":"lib/rain.factory/src/interface/ICloneableFactoryV1.sol","file":"../interface/ICloneableFactoryV1.sol","id":86,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":160,"sourceUnit":183,"src":"98:46:2","symbolAliases":[],"unitAlias":""},{"absolutePath":"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol","file":"rain.interpreter/abstract/DeployerDiscoverableMetaV1.sol","id":87,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":160,"sourceUnit":248,"src":"145:66:2","symbolAliases":[],"unitAlias":""},{"absolutePath":"lib/openzeppelin-contracts/contracts/proxy/Clones.sol","file":"openzeppelin-contracts/contracts/proxy/Clones.sol","id":89,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":160,"sourceUnit":83,"src":"212:73:2","symbolAliases":[{"foreign":{"id":88,"name":"Clones","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":82,"src":"220:6:2","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"documentation":{"id":90,"nodeType":"StructuredDocumentation","src":"287:81:2","text":"Thrown when an implementation is the zero address which is always a mistake."},"errorSelector":"4208d2eb","id":92,"name":"ZeroImplementation","nameLocation":"374:18:2","nodeType":"ErrorDefinition","parameters":{"id":91,"nodeType":"ParameterList","parameters":[],"src":"392:2:2"},"src":"368:27:2"},{"constant":true,"id":98,"mutability":"constant","name":"CLONE_FACTORY_META_HASH","nameLocation":"414:23:2","nodeType":"VariableDeclaration","scope":160,"src":"397:118:2","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":93,"name":"bytes32","nodeType":"ElementaryTypeName","src":"397:7:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":{"arguments":[{"hexValue":"307861653066623562363866653137393163373235303962663436656136616266366139383264323134353132363562653061303137663739353937313261363765","id":96,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"448:66:2","typeDescriptions":{"typeIdentifier":"t_rational_78730192497411501813382313816002206475570308023588106457734054107808760243838_by_1","typeString":"int_const 7873...(69 digits omitted)...3838"},"value":"0xae0fb5b68fe1791c72509bf46ea6abf6a982d21451265be0a017f7959712a67e"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_78730192497411501813382313816002206475570308023588106457734054107808760243838_by_1","typeString":"int_const 7873...(69 digits omitted)...3838"}],"id":95,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"440:7:2","typeDescriptions":{"typeIdentifier":"t_type$_t_bytes32_$","typeString":"type(bytes32)"},"typeName":{"id":94,"name":"bytes32","nodeType":"ElementaryTypeName","src":"440:7:2","typeDescriptions":{}}},"id":97,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"440:75:2","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"abstract":false,"baseContracts":[{"baseName":{"id":99,"name":"ICloneableFactoryV1","nameLocations":["543:19:2"],"nodeType":"IdentifierPath","referencedDeclaration":182,"src":"543:19:2"},"id":100,"nodeType":"InheritanceSpecifier","src":"543:19:2"},{"baseName":{"id":101,"name":"DeployerDiscoverableMetaV1","nameLocations":["564:26:2"],"nodeType":"IdentifierPath","referencedDeclaration":247,"src":"564:26:2"},"id":102,"nodeType":"InheritanceSpecifier","src":"564:26:2"}],"canonicalName":"CloneFactory","contractDependencies":[],"contractKind":"contract","fullyImplemented":true,"id":159,"linearizedBaseContracts":[159,247,451,182],"name":"CloneFactory","nameLocation":"527:12:2","nodeType":"ContractDefinition","nodes":[{"body":{"id":112,"nodeType":"Block","src":"743:2:2","statements":[]},"id":113,"implemented":true,"kind":"constructor","modifiers":[{"arguments":[{"id":108,"name":"CLONE_FACTORY_META_HASH","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":98,"src":"705:23:2","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":109,"name":"config_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":105,"src":"730:7:2","typeDescriptions":{"typeIdentifier":"t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_memory_ptr","typeString":"struct DeployerDiscoverableMetaV1ConstructionConfig memory"}}],"id":110,"kind":"baseConstructorSpecifier","modifierName":{"id":107,"name":"DeployerDiscoverableMetaV1","nameLocations":["678:26:2"],"nodeType":"IdentifierPath","referencedDeclaration":247,"src":"678:26:2"},"nodeType":"ModifierInvocation","src":"678:60:2"}],"name":"","nameLocation":"-1:-1:-1","nodeType":"FunctionDefinition","parameters":{"id":106,"nodeType":"ParameterList","parameters":[{"constant":false,"id":105,"mutability":"mutable","name":"config_","nameLocation":"661:7:2","nodeType":"VariableDeclaration","scope":113,"src":"609:59:2","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_memory_ptr","typeString":"struct DeployerDiscoverableMetaV1ConstructionConfig"},"typeName":{"id":104,"nodeType":"UserDefinedTypeName","pathNode":{"id":103,"name":"DeployerDiscoverableMetaV1ConstructionConfig","nameLocations":["609:44:2"],"nodeType":"IdentifierPath","referencedDeclaration":202,"src":"609:44:2"},"referencedDeclaration":202,"src":"609:44:2","typeDescriptions":{"typeIdentifier":"t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_storage_ptr","typeString":"struct DeployerDiscoverableMetaV1ConstructionConfig"}},"visibility":"internal"}],"src":"608:61:2"},"returnParameters":{"id":111,"nodeType":"ParameterList","parameters":[],"src":"743:0:2"},"scope":159,"src":"597:148:2","stateMutability":"nonpayable","virtual":false,"visibility":"public"},{"baseFunctions":[181],"body":{"id":157,"nodeType":"Block","src":"880:290:2","statements":[{"condition":{"commonType":{"typeIdentifier":"t_address","typeString":"address"},"id":128,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":123,"name":"implementation_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":116,"src":"894:15:2","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"arguments":[{"hexValue":"30","id":126,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"921:1:2","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":125,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"913:7:2","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":124,"name":"address","nodeType":"ElementaryTypeName","src":"913:7:2","typeDescriptions":{}}},"id":127,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"913:10:2","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"src":"894:29:2","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":133,"nodeType":"IfStatement","src":"890:87:2","trueBody":{"id":132,"nodeType":"Block","src":"925:52:2","statements":[{"errorCall":{"arguments":[],"expression":{"argumentTypes":[],"id":129,"name":"ZeroImplementation","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":92,"src":"946:18:2","typeDescriptions":{"typeIdentifier":"t_function_error_pure$__$returns$__$","typeString":"function () pure"}},"id":130,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"946:20:2","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":131,"nodeType":"RevertStatement","src":"939:27:2"}]}},{"assignments":[135],"declarations":[{"constant":false,"id":135,"mutability":"mutable","name":"clone_","nameLocation":"994:6:2","nodeType":"VariableDeclaration","scope":157,"src":"986:14:2","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":134,"name":"address","nodeType":"ElementaryTypeName","src":"986:7:2","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":140,"initialValue":{"arguments":[{"id":138,"name":"implementation_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":116,"src":"1016:15:2","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":136,"name":"Clones","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":82,"src":"1003:6:2","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_Clones_$82_$","typeString":"type(library Clones)"}},"id":137,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1010:5:2","memberName":"clone","nodeType":"MemberAccess","referencedDeclaration":25,"src":"1003:12:2","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_address_$returns$_t_address_$","typeString":"function (address) returns (address)"}},"id":139,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1003:29:2","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"nodeType":"VariableDeclarationStatement","src":"986:46:2"},{"eventCall":{"arguments":[{"expression":{"id":142,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"1056:3:2","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":143,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1060:6:2","memberName":"sender","nodeType":"MemberAccess","src":"1056:10:2","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":144,"name":"implementation_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":116,"src":"1068:15:2","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":145,"name":"clone_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":135,"src":"1085:6:2","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"}],"id":141,"name":"NewClone","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":171,"src":"1047:8:2","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_address_$_t_address_$returns$__$","typeString":"function (address,address,address)"}},"id":146,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1047:45:2","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":147,"nodeType":"EmitStatement","src":"1042:50:2"},{"expression":{"arguments":[{"id":152,"name":"data_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":118,"src":"1134:5:2","typeDescriptions":{"typeIdentifier":"t_bytes_calldata_ptr","typeString":"bytes calldata"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_calldata_ptr","typeString":"bytes calldata"}],"expression":{"arguments":[{"id":149,"name":"clone_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":135,"src":"1115:6:2","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":148,"name":"ICloneableV1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":192,"src":"1102:12:2","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_ICloneableV1_$192_$","typeString":"type(contract ICloneableV1)"}},"id":150,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1102:20:2","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_ICloneableV1_$192","typeString":"contract ICloneableV1"}},"id":151,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1123:10:2","memberName":"initialize","nodeType":"MemberAccess","referencedDeclaration":191,"src":"1102:31:2","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_bytes_memory_ptr_$returns$__$","typeString":"function (bytes memory) external"}},"id":153,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1102:38:2","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":154,"nodeType":"ExpressionStatement","src":"1102:38:2"},{"expression":{"id":155,"name":"clone_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":135,"src":"1157:6:2","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"functionReturnParameters":122,"id":156,"nodeType":"Return","src":"1150:13:2"}]},"documentation":{"id":114,"nodeType":"StructuredDocumentation","src":"751:35:2","text":"@inheritdoc ICloneableFactoryV1"},"functionSelector":"0fbe133c","id":158,"implemented":true,"kind":"function","modifiers":[],"name":"clone","nameLocation":"800:5:2","nodeType":"FunctionDefinition","parameters":{"id":119,"nodeType":"ParameterList","parameters":[{"constant":false,"id":116,"mutability":"mutable","name":"implementation_","nameLocation":"814:15:2","nodeType":"VariableDeclaration","scope":158,"src":"806:23:2","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":115,"name":"address","nodeType":"ElementaryTypeName","src":"806:7:2","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":118,"mutability":"mutable","name":"data_","nameLocation":"846:5:2","nodeType":"VariableDeclaration","scope":158,"src":"831:20:2","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_bytes_calldata_ptr","typeString":"bytes"},"typeName":{"id":117,"name":"bytes","nodeType":"ElementaryTypeName","src":"831:5:2","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"805:47:2"},"returnParameters":{"id":122,"nodeType":"ParameterList","parameters":[{"constant":false,"id":121,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":158,"src":"871:7:2","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":120,"name":"address","nodeType":"ElementaryTypeName","src":"871:7:2","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"870:9:2"},"scope":159,"src":"791:379:2","stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"scope":160,"src":"518:654:2","usedErrors":[92,431,436]}],"src":"32:1141:2"},"id":2},"lib/rain.factory/src/interface/ICloneableFactoryV1.sol":{"ast":{"absolutePath":"lib/rain.factory/src/interface/ICloneableFactoryV1.sol","exportedSymbols":{"ICloneableFactoryV1":[182]},"id":183,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":161,"literals":["solidity","^","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:3"},{"abstract":false,"baseContracts":[],"canonicalName":"ICloneableFactoryV1","contractDependencies":[],"contractKind":"interface","documentation":{"id":162,"nodeType":"StructuredDocumentation","src":"58:350:3","text":"@title ICloneableFactoryV1\n @notice A minimal interface to create proxy clones of a reference bytecode\n and emit events so that indexers can discover it. `ICloneableFactoryV1` knows\n nothing about the contracts that it clones, instead relying only on the\n minimal `ICloneableV1` interface being implemented on the reference bytecode."},"fullyImplemented":false,"id":182,"linearizedBaseContracts":[182],"name":"ICloneableFactoryV1","nameLocation":"418:19:3","nodeType":"ContractDefinition","nodes":[{"anonymous":false,"documentation":{"id":163,"nodeType":"StructuredDocumentation","src":"444:224:3","text":"Emitted upon each `clone`.\n @param sender The `msg.sender` that called `clone`.\n @param implementation The reference bytecode to clone as a proxy.\n @param clone The address of the new proxy contract."},"eventSelector":"274b5f356634f32a865af65bdc3d8205939d9413d75e1f367652e4f3b24d0c3a","id":171,"name":"NewClone","nameLocation":"679:8:3","nodeType":"EventDefinition","parameters":{"id":170,"nodeType":"ParameterList","parameters":[{"constant":false,"id":165,"indexed":false,"mutability":"mutable","name":"sender","nameLocation":"696:6:3","nodeType":"VariableDeclaration","scope":171,"src":"688:14:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":164,"name":"address","nodeType":"ElementaryTypeName","src":"688:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":167,"indexed":false,"mutability":"mutable","name":"implementation","nameLocation":"712:14:3","nodeType":"VariableDeclaration","scope":171,"src":"704:22:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":166,"name":"address","nodeType":"ElementaryTypeName","src":"704:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":169,"indexed":false,"mutability":"mutable","name":"clone","nameLocation":"736:5:3","nodeType":"VariableDeclaration","scope":171,"src":"728:13:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":168,"name":"address","nodeType":"ElementaryTypeName","src":"728:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"687:55:3"},"src":"673:70:3"},{"documentation":{"id":172,"nodeType":"StructuredDocumentation","src":"749:657:3","text":"Clones an implementation using a proxy. EIP1167 proxy as used by Open\n Zeppelin is recommended but the exact cloning procedure is not specified\n by this interface. The factory MUST call `ICloneableV1.initialize`\n atomically with the cloning process and MUST NOT call any other functions\n on the cloned proxy before initialize completes successfully. If the\n initialize reverts then the `clone` MUST revert.\n MUST emit `NewClone` with the implementation and clone address.\n @param implementation The contract to clone.\n @param data As per `ICloneableV1`.\n @return New child contract address."},"functionSelector":"0fbe133c","id":181,"implemented":false,"kind":"function","modifiers":[],"name":"clone","nameLocation":"1420:5:3","nodeType":"FunctionDefinition","parameters":{"id":177,"nodeType":"ParameterList","parameters":[{"constant":false,"id":174,"mutability":"mutable","name":"implementation","nameLocation":"1434:14:3","nodeType":"VariableDeclaration","scope":181,"src":"1426:22:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":173,"name":"address","nodeType":"ElementaryTypeName","src":"1426:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":176,"mutability":"mutable","name":"data","nameLocation":"1465:4:3","nodeType":"VariableDeclaration","scope":181,"src":"1450:19:3","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_bytes_calldata_ptr","typeString":"bytes"},"typeName":{"id":175,"name":"bytes","nodeType":"ElementaryTypeName","src":"1450:5:3","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1425:45:3"},"returnParameters":{"id":180,"nodeType":"ParameterList","parameters":[{"constant":false,"id":179,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":181,"src":"1489:7:3","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":178,"name":"address","nodeType":"ElementaryTypeName","src":"1489:7:3","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"1488:9:3"},"scope":182,"src":"1411:87:3","stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"scope":183,"src":"408:1092:3","usedErrors":[]}],"src":"32:1469:3"},"id":3},"lib/rain.factory/src/interface/ICloneableV1.sol":{"ast":{"absolutePath":"lib/rain.factory/src/interface/ICloneableV1.sol","exportedSymbols":{"ICloneableV1":[192]},"id":193,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":184,"literals":["solidity","^","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:4"},{"abstract":false,"baseContracts":[],"canonicalName":"ICloneableV1","contractDependencies":[],"contractKind":"interface","documentation":{"id":185,"nodeType":"StructuredDocumentation","src":"58:131:4","text":"@title ICloneableV1\n @notice Minimal interface following the Open Zeppelin conventions for\n initializing a cloned proxy."},"fullyImplemented":false,"id":192,"linearizedBaseContracts":[192],"name":"ICloneableV1","nameLocation":"199:12:4","nodeType":"ContractDefinition","nodes":[{"documentation":{"id":186,"nodeType":"StructuredDocumentation","src":"218:1161:4","text":"Initialize is intended to work like constructors but for cloneable\n proxies. The `ICloneableV1` contract MUST ensure that initialize cannot\n be called more than once. The `ICloneableV1` contract is designed to be\n deployed by an `ICloneFactoryV1` but MUST NOT assume that it will be. It\n is possible for someone to directly deploy an `ICloneableV1` and fail to\n call initialize before other functions are called, and end users MAY NOT\n realise or know how to confirm a safe deployment state. The\n `ICloneableV1` MUST take appropriate measures to ensure that functions\n called before initialize are safe to do so, or revert.\n To be fully generic `initilize` accepts `bytes` and so MUST ABI decode\n within the initialize function. This allows the factory to service\n arbitrary cloneable proxies but also erases the type of the\n initialization config from the ABI. One workaround is to emit an event\n containing the initialization config type, so that the type appears\n within the event and therefore the ABI.\n @param data The initialization data."},"functionSelector":"439fab91","id":191,"implemented":false,"kind":"function","modifiers":[],"name":"initialize","nameLocation":"1393:10:4","nodeType":"FunctionDefinition","parameters":{"id":189,"nodeType":"ParameterList","parameters":[{"constant":false,"id":188,"mutability":"mutable","name":"data","nameLocation":"1419:4:4","nodeType":"VariableDeclaration","scope":191,"src":"1404:19:4","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_bytes_calldata_ptr","typeString":"bytes"},"typeName":{"id":187,"name":"bytes","nodeType":"ElementaryTypeName","src":"1404:5:4","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1403:21:4"},"returnParameters":{"id":190,"nodeType":"ParameterList","parameters":[],"src":"1433:0:4"},"scope":192,"src":"1384:50:4","stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"scope":193,"src":"189:1247:4","usedErrors":[]}],"src":"32:1405:4"},"id":4},"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol":{"ast":{"absolutePath":"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol","exportedSymbols":{"DEFAULT_STATE_NAMESPACE":[342],"DeployerDiscoverableMetaV1":[247],"DeployerDiscoverableMetaV1ConstructionConfig":[202],"EncodedDispatch":[330],"FullyQualifiedNamespace":[291],"IExpressionDeployerV1":[286],"IInterpreterStoreV1":[323],"IInterpreterV1":[373],"IMetaV1":[451],"LibDeployerDiscoverable":[422],"LibMeta":[535],"META_MAGIC_NUMBER_V1":[440],"NO_STORE":[300],"NotRainMetaV1":[436],"Operand":[334],"SourceIndex":[328],"StateNamespace":[332],"UnexpectedMetaHash":[431]},"id":248,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":194,"literals":["solidity","^","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:5"},{"absolutePath":"lib/rain.metadata/src/IMetaV1.sol","file":"rain.metadata/IMetaV1.sol","id":195,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":248,"sourceUnit":452,"src":"58:35:5","symbolAliases":[],"unitAlias":""},{"absolutePath":"lib/rain.metadata/src/LibMeta.sol","file":"rain.metadata/LibMeta.sol","id":196,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":248,"sourceUnit":536,"src":"94:35:5","symbolAliases":[],"unitAlias":""},{"absolutePath":"lib/rain.interpreter/src/lib/LibDeployerDiscoverable.sol","file":"../lib/LibDeployerDiscoverable.sol","id":197,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":248,"sourceUnit":423,"src":"130:44:5","symbolAliases":[],"unitAlias":""},{"canonicalName":"DeployerDiscoverableMetaV1ConstructionConfig","id":202,"members":[{"constant":false,"id":199,"mutability":"mutable","name":"deployer","nameLocation":"444:8:5","nodeType":"VariableDeclaration","scope":202,"src":"436:16:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":198,"name":"address","nodeType":"ElementaryTypeName","src":"436:7:5","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":201,"mutability":"mutable","name":"meta","nameLocation":"464:4:5","nodeType":"VariableDeclaration","scope":202,"src":"458:10:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"},"typeName":{"id":200,"name":"bytes","nodeType":"ElementaryTypeName","src":"458:5:5","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"name":"DeployerDiscoverableMetaV1ConstructionConfig","nameLocation":"385:44:5","nodeType":"StructDefinition","scope":248,"src":"378:93:5","visibility":"public"},{"abstract":true,"baseContracts":[{"baseName":{"id":204,"name":"IMetaV1","nameLocations":["954:7:5"],"nodeType":"IdentifierPath","referencedDeclaration":451,"src":"954:7:5"},"id":205,"nodeType":"InheritanceSpecifier","src":"954:7:5"}],"canonicalName":"DeployerDiscoverableMetaV1","contractDependencies":[],"contractKind":"contract","documentation":{"id":203,"nodeType":"StructuredDocumentation","src":"473:433:5","text":"@title DeployerDiscoverableMetaV1\n @notice Upon construction, checks metadata against a known hash, emits it\n then touches the deployer (deploy an empty expression). This allows indexers\n to discover the metadata of the `DeployerDiscoverableMetaV1` contract by\n indexing the deployer. In this way the deployer acts as a pseudo-registry by\n virtue of it being a natural hub for interactions with calling contracts."},"fullyImplemented":true,"id":247,"linearizedBaseContracts":[247,451],"name":"DeployerDiscoverableMetaV1","nameLocation":"924:26:5","nodeType":"ContractDefinition","nodes":[{"body":{"id":245,"nodeType":"Block","src":"1058:206:5","statements":[{"expression":{"arguments":[{"id":216,"name":"metaHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":207,"src":"1092:8:5","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"expression":{"id":217,"name":"config","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":210,"src":"1102:6:5","typeDescriptions":{"typeIdentifier":"t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_memory_ptr","typeString":"struct DeployerDiscoverableMetaV1ConstructionConfig memory"}},"id":218,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"1109:4:5","memberName":"meta","nodeType":"MemberAccess","referencedDeclaration":201,"src":"1102:11:5","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"expression":{"id":213,"name":"LibMeta","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":535,"src":"1068:7:5","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_LibMeta_$535_$","typeString":"type(library LibMeta)"}},"id":215,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1076:15:5","memberName":"checkMetaHashed","nodeType":"MemberAccess","referencedDeclaration":534,"src":"1068:23:5","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes32_$_t_bytes_memory_ptr_$returns$__$","typeString":"function (bytes32,bytes memory) pure"}},"id":219,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1068:46:5","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":220,"nodeType":"ExpressionStatement","src":"1068:46:5"},{"eventCall":{"arguments":[{"expression":{"id":222,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"1136:3:5","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":223,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1140:6:5","memberName":"sender","nodeType":"MemberAccess","src":"1136:10:5","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"arguments":[{"arguments":[{"arguments":[{"id":230,"name":"this","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-28,"src":"1172:4:5","typeDescriptions":{"typeIdentifier":"t_contract$_DeployerDiscoverableMetaV1_$247","typeString":"contract DeployerDiscoverableMetaV1"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_DeployerDiscoverableMetaV1_$247","typeString":"contract DeployerDiscoverableMetaV1"}],"id":229,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"1164:7:5","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":228,"name":"address","nodeType":"ElementaryTypeName","src":"1164:7:5","typeDescriptions":{}}},"id":231,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1164:13:5","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":227,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"1156:7:5","typeDescriptions":{"typeIdentifier":"t_type$_t_uint160_$","typeString":"type(uint160)"},"typeName":{"id":226,"name":"uint160","nodeType":"ElementaryTypeName","src":"1156:7:5","typeDescriptions":{}}},"id":232,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1156:22:5","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint160","typeString":"uint160"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_uint160","typeString":"uint160"}],"id":225,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"1148:7:5","typeDescriptions":{"typeIdentifier":"t_type$_t_uint256_$","typeString":"type(uint256)"},"typeName":{"id":224,"name":"uint256","nodeType":"ElementaryTypeName","src":"1148:7:5","typeDescriptions":{}}},"id":233,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1148:31:5","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"expression":{"id":234,"name":"config","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":210,"src":"1181:6:5","typeDescriptions":{"typeIdentifier":"t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_memory_ptr","typeString":"struct DeployerDiscoverableMetaV1ConstructionConfig memory"}},"id":235,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"1188:4:5","memberName":"meta","nodeType":"MemberAccess","referencedDeclaration":201,"src":"1181:11:5","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"id":221,"name":"MetaV1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":450,"src":"1129:6:5","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_uint256_$_t_bytes_memory_ptr_$returns$__$","typeString":"function (address,uint256,bytes memory)"}},"id":236,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1129:64:5","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":237,"nodeType":"EmitStatement","src":"1124:69:5"},{"expression":{"arguments":[{"expression":{"id":241,"name":"config","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":210,"src":"1241:6:5","typeDescriptions":{"typeIdentifier":"t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_memory_ptr","typeString":"struct DeployerDiscoverableMetaV1ConstructionConfig memory"}},"id":242,"isConstant":false,"isLValue":true,"isPure":false,"lValueRequested":false,"memberLocation":"1248:8:5","memberName":"deployer","nodeType":"MemberAccess","referencedDeclaration":199,"src":"1241:15:5","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"expression":{"id":238,"name":"LibDeployerDiscoverable","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":422,"src":"1203:23:5","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_LibDeployerDiscoverable_$422_$","typeString":"type(library LibDeployerDiscoverable)"}},"id":240,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1227:13:5","memberName":"touchDeployer","nodeType":"MemberAccess","referencedDeclaration":421,"src":"1203:37:5","typeDescriptions":{"typeIdentifier":"t_function_internal_nonpayable$_t_address_$returns$__$","typeString":"function (address)"}},"id":243,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1203:54:5","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":244,"nodeType":"ExpressionStatement","src":"1203:54:5"}]},"id":246,"implemented":true,"kind":"constructor","modifiers":[],"name":"","nameLocation":"-1:-1:-1","nodeType":"FunctionDefinition","parameters":{"id":211,"nodeType":"ParameterList","parameters":[{"constant":false,"id":207,"mutability":"mutable","name":"metaHash","nameLocation":"988:8:5","nodeType":"VariableDeclaration","scope":246,"src":"980:16:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":206,"name":"bytes32","nodeType":"ElementaryTypeName","src":"980:7:5","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":210,"mutability":"mutable","name":"config","nameLocation":"1050:6:5","nodeType":"VariableDeclaration","scope":246,"src":"998:58:5","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_memory_ptr","typeString":"struct DeployerDiscoverableMetaV1ConstructionConfig"},"typeName":{"id":209,"nodeType":"UserDefinedTypeName","pathNode":{"id":208,"name":"DeployerDiscoverableMetaV1ConstructionConfig","nameLocations":["998:44:5"],"nodeType":"IdentifierPath","referencedDeclaration":202,"src":"998:44:5"},"referencedDeclaration":202,"src":"998:44:5","typeDescriptions":{"typeIdentifier":"t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_storage_ptr","typeString":"struct DeployerDiscoverableMetaV1ConstructionConfig"}},"visibility":"internal"}],"src":"979:78:5"},"returnParameters":{"id":212,"nodeType":"ParameterList","parameters":[],"src":"1058:0:5"},"scope":247,"src":"968:296:5","stateMutability":"nonpayable","virtual":false,"visibility":"internal"}],"scope":248,"src":"906:360:5","usedErrors":[431,436]}],"src":"32:1235:5"},"id":5},"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol":{"ast":{"absolutePath":"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol","exportedSymbols":{"DEFAULT_STATE_NAMESPACE":[342],"EncodedDispatch":[330],"FullyQualifiedNamespace":[291],"IExpressionDeployerV1":[286],"IInterpreterStoreV1":[323],"IInterpreterV1":[373],"NO_STORE":[300],"Operand":[334],"SourceIndex":[328],"StateNamespace":[332]},"id":287,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":249,"literals":["solidity","^","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:6"},{"absolutePath":"lib/rain.interpreter/src/interface/IInterpreterV1.sol","file":"./IInterpreterV1.sol","id":250,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":287,"sourceUnit":374,"src":"58:30:6","symbolAliases":[],"unitAlias":""},{"abstract":false,"baseContracts":[],"canonicalName":"IExpressionDeployerV1","contractDependencies":[],"contractKind":"interface","documentation":{"id":251,"nodeType":"StructuredDocumentation","src":"90:1775:6","text":"@title IExpressionDeployerV1\n @notice Companion to `IInterpreterV1` responsible for onchain static code\n analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\n coupled at the bytecode level to some interpreter that it knows how to\n analyse and deploy expressions for. The expression deployer can perform an\n integrity check \"dry run\" of candidate source code for the intepreter. The\n critical analysis/transformation includes:\n - Enforcement of no out of bounds memory reads/writes\n - Calculation of memory required to eval the stack with a single allocation\n - Replacing index based opcodes with absolute interpreter function pointers\n - Enforcement that all opcodes and operands used exist and are valid\n This analysis is highly sensitive to the specific implementation and position\n of all opcodes and function pointers as compiled into the interpreter. This\n is what makes the coupling between an interpreter and expression deployer\n so tight. Ideally all responsibilities would be handled by a single contract\n but this introduces code size issues quickly by roughly doubling the compiled\n logic of each opcode (half for the integrity check and half for evaluation).\n Interpreters MUST assume that expression deployers are malicious and fail\n gracefully if the integrity check is corrupt/bypassed and/or function\n pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\n from `eval` in a read only way or error. I.e. it is the expression deployer's\n responsibility to do everything it can to prevent undefined behaviour in the\n interpreter, and the interpreter's responsibility to handle the expression\n deployer completely failing to do so."},"fullyImplemented":false,"id":286,"linearizedBaseContracts":[286],"name":"IExpressionDeployerV1","nameLocation":"1875:21:6","nodeType":"ContractDefinition","nodes":[{"anonymous":false,"documentation":{"id":252,"nodeType":"StructuredDocumentation","src":"1903:487:6","text":"This is the literal InterpreterOpMeta bytes to be used offchain to make\n sense of the opcodes in this interpreter deployment, as a human. For\n formats like json that make heavy use of boilerplate, repetition and\n whitespace, some kind of compression is recommended.\n @param sender The `msg.sender` providing the op meta.\n @param opMeta The raw binary data of the op meta. Maybe compressed data\n etc. and is intended for offchain consumption."},"eventSelector":"1788931a083e1bfada6cb062b5426ea97c7866b814b4d1173909e4018f2122f1","id":264,"name":"DISpair","nameLocation":"2401:7:6","nodeType":"EventDefinition","parameters":{"id":263,"nodeType":"ParameterList","parameters":[{"constant":false,"id":254,"indexed":false,"mutability":"mutable","name":"sender","nameLocation":"2417:6:6","nodeType":"VariableDeclaration","scope":264,"src":"2409:14:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":253,"name":"address","nodeType":"ElementaryTypeName","src":"2409:7:6","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":256,"indexed":false,"mutability":"mutable","name":"deployer","nameLocation":"2433:8:6","nodeType":"VariableDeclaration","scope":264,"src":"2425:16:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":255,"name":"address","nodeType":"ElementaryTypeName","src":"2425:7:6","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":258,"indexed":false,"mutability":"mutable","name":"interpreter","nameLocation":"2451:11:6","nodeType":"VariableDeclaration","scope":264,"src":"2443:19:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":257,"name":"address","nodeType":"ElementaryTypeName","src":"2443:7:6","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":260,"indexed":false,"mutability":"mutable","name":"store","nameLocation":"2472:5:6","nodeType":"VariableDeclaration","scope":264,"src":"2464:13:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":259,"name":"address","nodeType":"ElementaryTypeName","src":"2464:7:6","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":262,"indexed":false,"mutability":"mutable","name":"opMeta","nameLocation":"2485:6:6","nodeType":"VariableDeclaration","scope":264,"src":"2479:12:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":261,"name":"bytes","nodeType":"ElementaryTypeName","src":"2479:5:6","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"2408:84:6"},"src":"2395:98:6"},{"documentation":{"id":265,"nodeType":"StructuredDocumentation","src":"2499:4035:6","text":"Expressions are expected to be deployed onchain as immutable contract\n code with a first class address like any other contract or account.\n Technically this is optional in the sense that all the tools required to\n eval some expression and define all its opcodes are available as\n libraries.\n In practise there are enough advantages to deploying the sources directly\n onchain as contract data and loading them from the interpreter at eval:\n - Loading and storing binary data is gas efficient as immutable contract\n   data\n - Expressions need to be immutable between their deploy time integrity\n   check and runtime evaluation\n - Passing the address of an expression through calldata to an interpreter\n   is cheaper than passing an entire expression through calldata\n - Conceptually a very simple approach, even if implementations like\n   SSTORE2 are subtle under the hood\n The expression deployer MUST perform an integrity check of the source\n code before it puts the expression onchain at a known address. The\n integrity check MUST at a minimum (it is free to do additional static\n analysis) calculate the memory required to be allocated for the stack in\n total, and that no out of bounds memory reads/writes occur within this\n stack. A simple example of an invalid source would be one that pushes one\n value to the stack then attempts to pops two values, clearly we cannot\n remove more values than we added. The `IExpressionDeployerV1` MUST revert\n in the case of any integrity failure, all integrity checks MUST pass in\n order for the deployment to complete.\n Once the integrity check is complete the `IExpressionDeployerV1` MUST do\n any additional processing required by its paired interpreter.\n For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\n opcodes in the `ExpressionConfig` sources with real function pointers\n from the corresponding interpreter.\n @param sources Sources verbatim. These sources MUST be provided in their\n sequential/index opcode form as the deployment process will need to index\n into BOTH the integrity check and the final runtime function pointers.\n This will be emitted in an event for offchain processing to use the\n indexed opcode sources. The first N sources are considered entrypoints\n and will be integrity checked by the expression deployer against a\n starting stack height of 0. Non-entrypoint sources MAY be provided for\n internal use such as the `call` opcode but will NOT be integrity checked\n UNLESS entered by an opcode in an entrypoint.\n @param constants Constants verbatim. Constants are provided alongside\n sources rather than inline as it allows us to avoid variable length\n opcodes and can be more memory efficient if the same constant is\n referenced several times from the sources.\n @param minOutputs The first N sources on the state config are entrypoints\n to the expression where N is the length of the `minOutputs` array. Each\n item in the `minOutputs` array specifies the number of outputs that MUST\n be present on the final stack for an evaluation of each entrypoint. The\n minimum output for some entrypoint MAY be zero if the expectation is that\n the expression only applies checks and error logic. Non-entrypoint\n sources MUST NOT have a minimum outputs length specified.\n @return interpreter The interpreter the deployer believes it is qualified\n to perform integrity checks on behalf of.\n @return store The interpreter store the deployer believes is compatible\n with the interpreter.\n @return expression The address of the deployed onchain expression. MUST\n be valid according to all integrity checks the deployer is aware of."},"functionSelector":"5511cb67","id":285,"implemented":false,"kind":"function","modifiers":[],"name":"deployExpression","nameLocation":"6548:16:6","nodeType":"FunctionDefinition","parameters":{"id":275,"nodeType":"ParameterList","parameters":[{"constant":false,"id":268,"mutability":"mutable","name":"sources","nameLocation":"6580:7:6","nodeType":"VariableDeclaration","scope":285,"src":"6565:22:6","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_ptr_$dyn_memory_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":266,"name":"bytes","nodeType":"ElementaryTypeName","src":"6565:5:6","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":267,"nodeType":"ArrayTypeName","src":"6565:7:6","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"visibility":"internal"},{"constant":false,"id":271,"mutability":"mutable","name":"constants","nameLocation":"6606:9:6","nodeType":"VariableDeclaration","scope":285,"src":"6589:26:6","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":269,"name":"uint256","nodeType":"ElementaryTypeName","src":"6589:7:6","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":270,"nodeType":"ArrayTypeName","src":"6589:9:6","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"},{"constant":false,"id":274,"mutability":"mutable","name":"minOutputs","nameLocation":"6634:10:6","nodeType":"VariableDeclaration","scope":285,"src":"6617:27:6","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":272,"name":"uint256","nodeType":"ElementaryTypeName","src":"6617:7:6","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":273,"nodeType":"ArrayTypeName","src":"6617:9:6","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"}],"src":"6564:81:6"},"returnParameters":{"id":284,"nodeType":"ParameterList","parameters":[{"constant":false,"id":278,"mutability":"mutable","name":"interpreter","nameLocation":"6695:11:6","nodeType":"VariableDeclaration","scope":285,"src":"6680:26:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterV1_$373","typeString":"contract IInterpreterV1"},"typeName":{"id":277,"nodeType":"UserDefinedTypeName","pathNode":{"id":276,"name":"IInterpreterV1","nameLocations":["6680:14:6"],"nodeType":"IdentifierPath","referencedDeclaration":373,"src":"6680:14:6"},"referencedDeclaration":373,"src":"6680:14:6","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterV1_$373","typeString":"contract IInterpreterV1"}},"visibility":"internal"},{"constant":false,"id":281,"mutability":"mutable","name":"store","nameLocation":"6728:5:6","nodeType":"VariableDeclaration","scope":285,"src":"6708:25:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"},"typeName":{"id":280,"nodeType":"UserDefinedTypeName","pathNode":{"id":279,"name":"IInterpreterStoreV1","nameLocations":["6708:19:6"],"nodeType":"IdentifierPath","referencedDeclaration":323,"src":"6708:19:6"},"referencedDeclaration":323,"src":"6708:19:6","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"}},"visibility":"internal"},{"constant":false,"id":283,"mutability":"mutable","name":"expression","nameLocation":"6743:10:6","nodeType":"VariableDeclaration","scope":285,"src":"6735:18:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":282,"name":"address","nodeType":"ElementaryTypeName","src":"6735:7:6","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"6679:75:6"},"scope":286,"src":"6539:216:6","stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"scope":287,"src":"1865:4892:6","usedErrors":[]}],"src":"32:6726:6"},"id":6},"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol":{"ast":{"absolutePath":"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol","exportedSymbols":{"DEFAULT_STATE_NAMESPACE":[342],"EncodedDispatch":[330],"FullyQualifiedNamespace":[291],"IInterpreterStoreV1":[323],"IInterpreterV1":[373],"NO_STORE":[300],"Operand":[334],"SourceIndex":[328],"StateNamespace":[332]},"id":324,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":288,"literals":["solidity","^","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:7"},{"absolutePath":"lib/rain.interpreter/src/interface/IInterpreterV1.sol","file":"./IInterpreterV1.sol","id":289,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":324,"sourceUnit":374,"src":"58:30:7","symbolAliases":[],"unitAlias":""},{"canonicalName":"FullyQualifiedNamespace","id":291,"name":"FullyQualifiedNamespace","nameLocation":"579:23:7","nodeType":"UserDefinedValueTypeDefinition","src":"574:40:7","underlyingType":{"id":290,"name":"uint256","nodeType":"ElementaryTypeName","src":"606:7:7","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}},{"constant":true,"id":300,"mutability":"constant","name":"NO_STORE","nameLocation":"645:8:7","nodeType":"VariableDeclaration","scope":324,"src":"616:71:7","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"},"typeName":{"id":293,"nodeType":"UserDefinedTypeName","pathNode":{"id":292,"name":"IInterpreterStoreV1","nameLocations":["616:19:7"],"nodeType":"IdentifierPath","referencedDeclaration":323,"src":"616:19:7"},"referencedDeclaration":323,"src":"616:19:7","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"}},"value":{"arguments":[{"arguments":[{"hexValue":"30","id":297,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"684:1:7","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":296,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"676:7:7","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":295,"name":"address","nodeType":"ElementaryTypeName","src":"676:7:7","typeDescriptions":{}}},"id":298,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"676:10:7","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":294,"name":"IInterpreterStoreV1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":323,"src":"656:19:7","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IInterpreterStoreV1_$323_$","typeString":"type(contract IInterpreterStoreV1)"}},"id":299,"isConstant":false,"isLValue":false,"isPure":true,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"656:31:7","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"}},"visibility":"internal"},{"abstract":false,"baseContracts":[],"canonicalName":"IInterpreterStoreV1","contractDependencies":[],"contractKind":"interface","documentation":{"id":301,"nodeType":"StructuredDocumentation","src":"690:1287:7","text":"@title IInterpreterStoreV1\n @notice Tracks state changes on behalf of an interpreter. A single store can\n handle state changes for many calling contracts, many interpreters and many\n expressions. The store is responsible for ensuring that applying these state\n changes is safe from key collisions with calls to `set` from different\n `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\n state changes associated with some other caller.\n The store defines the shape of its own state changes, which is opaque to the\n calling contract. For example, some store may treat the list of state changes\n as a pairwise key/value set, and some other store may treat it as a literal\n list to be stored as-is.\n Each interpreter decides for itself which store to use based on the\n compatibility of its own opcodes.\n The store MUST assume the state changes have been corrupted by the calling\n contract due to bugs or malicious intent, and enforce state isolation between\n callers despite arbitrarily invalid state changes. The store MUST revert if\n it can detect invalid state changes, such as a key/value list having an odd\n number of items, but this MAY NOT be possible if the corruption is\n undetectable."},"fullyImplemented":false,"id":323,"linearizedBaseContracts":[323],"name":"IInterpreterStoreV1","nameLocation":"1987:19:7","nodeType":"ContractDefinition","nodes":[{"documentation":{"id":302,"nodeType":"StructuredDocumentation","src":"2013:669:7","text":"Mutates the interpreter store in bulk. The bulk values are provided in\n the form of a `uint256[]` which can be treated e.g. as pairwise keys and\n values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\n defines the meaning of the `uint256[]` for its own storage logic.\n @param namespace The unqualified namespace for the set that MUST be\n fully qualified by the `IInterpreterStoreV1` to prevent key collisions\n between callers. The fully qualified namespace forms a compound key with\n the keys for each value to set.\n @param kvs The list of changes to apply to the store's internal state."},"functionSelector":"946aadc6","id":311,"implemented":false,"kind":"function","modifiers":[],"name":"set","nameLocation":"2696:3:7","nodeType":"FunctionDefinition","parameters":{"id":309,"nodeType":"ParameterList","parameters":[{"constant":false,"id":305,"mutability":"mutable","name":"namespace","nameLocation":"2715:9:7","nodeType":"VariableDeclaration","scope":311,"src":"2700:24:7","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_StateNamespace_$332","typeString":"StateNamespace"},"typeName":{"id":304,"nodeType":"UserDefinedTypeName","pathNode":{"id":303,"name":"StateNamespace","nameLocations":["2700:14:7"],"nodeType":"IdentifierPath","referencedDeclaration":332,"src":"2700:14:7"},"referencedDeclaration":332,"src":"2700:14:7","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_StateNamespace_$332","typeString":"StateNamespace"}},"visibility":"internal"},{"constant":false,"id":308,"mutability":"mutable","name":"kvs","nameLocation":"2745:3:7","nodeType":"VariableDeclaration","scope":311,"src":"2726:22:7","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_calldata_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":306,"name":"uint256","nodeType":"ElementaryTypeName","src":"2726:7:7","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":307,"nodeType":"ArrayTypeName","src":"2726:9:7","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"}],"src":"2699:50:7"},"returnParameters":{"id":310,"nodeType":"ParameterList","parameters":[],"src":"2758:0:7"},"scope":323,"src":"2687:72:7","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":312,"nodeType":"StructuredDocumentation","src":"2765:1053:7","text":"Given a fully qualified namespace and key, return the associated value.\n Ostensibly the interpreter can use this to implement opcodes that read\n previously set values. The interpreter MUST apply the same qualification\n logic as the store that it uses to guarantee consistent round tripping of\n data and prevent malicious behaviours. Technically also allows onchain\n reads of any set value from any contract, not just interpreters, but in\n this case readers MUST be aware and handle inconsistencies between get\n and set while the state changes are still in memory in the calling\n context and haven't yet been persisted to the store.\n `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\n Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\n @param namespace The fully qualified namespace to get a single value for.\n @param key The key to get the value for within the namespace.\n @return The value OR ZERO IF NOT SET."},"functionSelector":"669e48aa","id":322,"implemented":false,"kind":"function","modifiers":[],"name":"get","nameLocation":"3832:3:7","nodeType":"FunctionDefinition","parameters":{"id":318,"nodeType":"ParameterList","parameters":[{"constant":false,"id":315,"mutability":"mutable","name":"namespace","nameLocation":"3860:9:7","nodeType":"VariableDeclaration","scope":322,"src":"3836:33:7","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_FullyQualifiedNamespace_$291","typeString":"FullyQualifiedNamespace"},"typeName":{"id":314,"nodeType":"UserDefinedTypeName","pathNode":{"id":313,"name":"FullyQualifiedNamespace","nameLocations":["3836:23:7"],"nodeType":"IdentifierPath","referencedDeclaration":291,"src":"3836:23:7"},"referencedDeclaration":291,"src":"3836:23:7","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_FullyQualifiedNamespace_$291","typeString":"FullyQualifiedNamespace"}},"visibility":"internal"},{"constant":false,"id":317,"mutability":"mutable","name":"key","nameLocation":"3879:3:7","nodeType":"VariableDeclaration","scope":322,"src":"3871:11:7","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":316,"name":"uint256","nodeType":"ElementaryTypeName","src":"3871:7:7","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3835:48:7"},"returnParameters":{"id":321,"nodeType":"ParameterList","parameters":[{"constant":false,"id":320,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":322,"src":"3907:7:7","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":319,"name":"uint256","nodeType":"ElementaryTypeName","src":"3907:7:7","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3906:9:7"},"scope":323,"src":"3823:93:7","stateMutability":"view","virtual":false,"visibility":"external"}],"scope":324,"src":"1977:1941:7","usedErrors":[]}],"src":"32:3887:7"},"id":7},"lib/rain.interpreter/src/interface/IInterpreterV1.sol":{"ast":{"absolutePath":"lib/rain.interpreter/src/interface/IInterpreterV1.sol","exportedSymbols":{"DEFAULT_STATE_NAMESPACE":[342],"EncodedDispatch":[330],"FullyQualifiedNamespace":[291],"IInterpreterStoreV1":[323],"IInterpreterV1":[373],"NO_STORE":[300],"Operand":[334],"SourceIndex":[328],"StateNamespace":[332]},"id":374,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":325,"literals":["solidity","^","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:8"},{"absolutePath":"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol","file":"./IInterpreterStoreV1.sol","id":326,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":374,"sourceUnit":324,"src":"58:35:8","symbolAliases":[],"unitAlias":""},{"canonicalName":"SourceIndex","id":328,"name":"SourceIndex","nameLocation":"308:11:8","nodeType":"UserDefinedValueTypeDefinition","src":"303:27:8","underlyingType":{"id":327,"name":"uint16","nodeType":"ElementaryTypeName","src":"323:6:8","typeDescriptions":{"typeIdentifier":"t_uint16","typeString":"uint16"}}},{"canonicalName":"EncodedDispatch","id":330,"name":"EncodedDispatch","nameLocation":"479:15:8","nodeType":"UserDefinedValueTypeDefinition","src":"474:32:8","underlyingType":{"id":329,"name":"uint256","nodeType":"ElementaryTypeName","src":"498:7:8","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}},{"canonicalName":"StateNamespace","id":332,"name":"StateNamespace","nameLocation":"684:14:8","nodeType":"UserDefinedValueTypeDefinition","src":"679:31:8","underlyingType":{"id":331,"name":"uint256","nodeType":"ElementaryTypeName","src":"702:7:8","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}},{"canonicalName":"Operand","id":334,"name":"Operand","nameLocation":"912:7:8","nodeType":"UserDefinedValueTypeDefinition","src":"907:24:8","underlyingType":{"id":333,"name":"uint256","nodeType":"ElementaryTypeName","src":"923:7:8","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}}},{"constant":true,"id":342,"mutability":"constant","name":"DEFAULT_STATE_NAMESPACE","nameLocation":"1096:23:8","nodeType":"VariableDeclaration","scope":374,"src":"1072:72:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_StateNamespace_$332","typeString":"StateNamespace"},"typeName":{"id":337,"nodeType":"UserDefinedTypeName","pathNode":{"id":336,"name":"StateNamespace","nameLocations":["1072:14:8"],"nodeType":"IdentifierPath","referencedDeclaration":332,"src":"1072:14:8"},"referencedDeclaration":332,"src":"1072:14:8","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_StateNamespace_$332","typeString":"StateNamespace"}},"value":{"arguments":[{"hexValue":"30","id":340,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"1142:1:8","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"expression":{"id":338,"name":"StateNamespace","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":332,"src":"1122:14:8","typeDescriptions":{"typeIdentifier":"t_type$_t_userDefinedValueType$_StateNamespace_$332_$","typeString":"type(StateNamespace)"}},"id":339,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"1137:4:8","memberName":"wrap","nodeType":"MemberAccess","src":"1122:19:8","typeDescriptions":{"typeIdentifier":"t_function_wrap_pure$_t_uint256_$returns$_t_userDefinedValueType$_StateNamespace_$332_$","typeString":"function (uint256) pure returns (StateNamespace)"}},"id":341,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1122:22:8","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_StateNamespace_$332","typeString":"StateNamespace"}},"visibility":"internal"},{"abstract":false,"baseContracts":[],"canonicalName":"IInterpreterV1","contractDependencies":[],"contractKind":"interface","documentation":{"id":343,"nodeType":"StructuredDocumentation","src":"1147:3203:8","text":"@title IInterpreterV1\n Interface into a standard interpreter that supports:\n - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\n - receiving arbitrary `uint256[][]` supporting context to be made available\n   to the evaluated logic\n - handling subsequent state changes in bulk in response to evaluated logic\n - namespacing state changes according to the caller's preferences to avoid\n   unwanted key collisions\n - exposing its internal function pointers to support external precompilation\n   of logic for more gas efficient runtime evaluation by the interpreter\n The interface is designed to be stable across many versions and\n implementations of an interpreter, balancing minimalism with features\n required for a general purpose onchain interpreted compute environment.\n The security model of an interpreter is that it MUST be resilient to\n malicious expressions even if they dispatch arbitrary internal function\n pointers during an eval. The interpreter MAY return garbage or exhibit\n undefined behaviour or error during an eval, _provided that no state changes\n are persisted_ e.g. in storage, such that only the caller that specifies the\n malicious expression can be negatively impacted by the result. In turn, the\n caller must guard itself against arbitrarily corrupt/malicious reverts and\n return values from any interpreter that it requests an expression from. And\n so on and so forth up to the externally owned account (EOA) who signs the\n transaction and agrees to a specific combination of contracts, expressions\n and interpreters, who can presumably make an informed decision about which\n ones to trust to get the job done.\n The state changes for an interpreter are expected to be produces by an `eval`\n and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\n caller, after the caller has had an opportunity to apply their own\n intermediate logic such as reentrancy defenses against malicious\n interpreters. The interpreter is free to structure the state changes however\n it wants but MUST guard against the calling contract corrupting the changes\n between `eval` and `set`. For example a store could sandbox storage writes\n per-caller so that a malicious caller can only damage their own state\n changes, while honest callers respect, benefit from and are protected by the\n interpreter store's state change handling.\n The two step eval-state model allows eval to be read-only which provides\n security guarantees for the caller such as no stateful reentrancy, either\n from the interpreter or some contract interface used by some word, while\n still allowing for storage writes. As the storage writes happen on the\n interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\n need to trust the interpreter, which allows for permissionless selection of\n interpreters by end users. Delegate call always implies an admin key on the\n caller because the delegatee contract can write arbitrarily to the state of\n the delegator, which severely limits the generality of contract composition."},"fullyImplemented":false,"id":373,"linearizedBaseContracts":[373],"name":"IInterpreterV1","nameLocation":"4360:14:8","nodeType":"ContractDefinition","nodes":[{"documentation":{"id":344,"nodeType":"StructuredDocumentation","src":"4381:1399:8","text":"Exposes the function pointers as `uint16` values packed into a single\n `bytes` in the same order as they would be indexed into by opcodes. For\n example, if opcode `2` should dispatch function at position `0x1234` then\n the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\n a placeholder for the function pointers of opcodes `0` and `1`.\n `IExpressionDeployerV1` contracts use these function pointers to\n \"compile\" the expression into something that an interpreter can dispatch\n directly without paying gas to lookup the same at runtime. As the\n validity of any integrity check and subsequent dispatch is highly\n sensitive to both the function pointers and overall bytecode of the\n interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\n against accidentally being deployed onchain paired against an unknown\n interpreter. It is very easy for an apparent compatible pairing to be\n subtly and critically incompatible due to addition/removal/reordering of\n opcodes and compiler optimisations on the interpreter bytecode.\n This MAY return different values during construction vs. all other times\n after the interpreter has been successfully deployed onchain. DO NOT rely\n on function pointers reported during contract construction."},"functionSelector":"f933c72f","id":349,"implemented":false,"kind":"function","modifiers":[],"name":"functionPointers","nameLocation":"5794:16:8","nodeType":"FunctionDefinition","parameters":{"id":345,"nodeType":"ParameterList","parameters":[],"src":"5810:2:8"},"returnParameters":{"id":348,"nodeType":"ParameterList","parameters":[{"constant":false,"id":347,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":349,"src":"5836:12:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":346,"name":"bytes","nodeType":"ElementaryTypeName","src":"5836:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"5835:14:8"},"scope":373,"src":"5785:65:8","stateMutability":"view","virtual":false,"visibility":"external"},{"documentation":{"id":350,"nodeType":"StructuredDocumentation","src":"5856:2997:8","text":"The raison d'etre for an interpreter. Given some expression and per-call\n additional contextual data, produce a stack of results and a set of state\n changes that the caller MAY OPTIONALLY pass back to be persisted by a\n call to `IInterpreterStoreV1.set`.\n @param store The storage contract that the returned key/value pairs\n MUST be passed to IF the calling contract is in a non-static calling\n context. Static calling contexts MUST pass `address(0)`.\n @param namespace The state namespace that will be fully qualified by the\n interpreter at runtime in order to perform gets on the underlying store.\n MUST be the same namespace passed to the store by the calling contract\n when sending the resulting key/value items to storage.\n @param dispatch All the information required for the interpreter to load\n an expression, select an entrypoint and return the values expected by the\n caller. The interpreter MAY encode dispatches differently to\n `LibEncodedDispatch` but this WILL negatively impact compatibility for\n calling contracts that hardcode the encoding logic.\n @param context A 2-dimensional array of data that can be indexed into at\n runtime by the interpreter. The calling contract is responsible for\n ensuring the authenticity and completeness of context data. The\n interpreter MUST revert at runtime if an expression attempts to index\n into some context value that is not provided by the caller. This implies\n that context reads cannot be checked for out of bounds reads at deploy\n time, as the runtime context MAY be provided in a different shape to what\n the expression is expecting.\n Same as `eval` but allowing the caller to specify a namespace under which\n the state changes will be applied. The interpeter MUST ensure that keys\n will never collide across namespaces, even if, for example:\n - The calling contract is malicious and attempts to craft a collision\n   with state changes from another contract\n - The expression is malicious and attempts to craft a collision with\n   other expressions evaluated by the same calling contract\n A malicious entity MAY have access to significant offchain resources to\n attempt to precompute key collisions through brute force. The collision\n resistance of namespaces should be comparable or equivalent to the\n collision resistance of the hashing algorithms employed by the blockchain\n itself, such as the design of `mapping` in Solidity that hashes each\n nested key to produce a collision resistant compound key.\n @return stack The list of values produced by evaluating the expression.\n MUST NOT be longer than the maximum length specified by `dispatch`, if\n applicable.\n @return kvs A list of pairwise key/value items to be saved in the store."},"functionSelector":"6715f825","id":372,"implemented":false,"kind":"function","modifiers":[],"name":"eval","nameLocation":"8867:4:8","nodeType":"FunctionDefinition","parameters":{"id":364,"nodeType":"ParameterList","parameters":[{"constant":false,"id":353,"mutability":"mutable","name":"store","nameLocation":"8901:5:8","nodeType":"VariableDeclaration","scope":372,"src":"8881:25:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"},"typeName":{"id":352,"nodeType":"UserDefinedTypeName","pathNode":{"id":351,"name":"IInterpreterStoreV1","nameLocations":["8881:19:8"],"nodeType":"IdentifierPath","referencedDeclaration":323,"src":"8881:19:8"},"referencedDeclaration":323,"src":"8881:19:8","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"}},"visibility":"internal"},{"constant":false,"id":356,"mutability":"mutable","name":"namespace","nameLocation":"8931:9:8","nodeType":"VariableDeclaration","scope":372,"src":"8916:24:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_StateNamespace_$332","typeString":"StateNamespace"},"typeName":{"id":355,"nodeType":"UserDefinedTypeName","pathNode":{"id":354,"name":"StateNamespace","nameLocations":["8916:14:8"],"nodeType":"IdentifierPath","referencedDeclaration":332,"src":"8916:14:8"},"referencedDeclaration":332,"src":"8916:14:8","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_StateNamespace_$332","typeString":"StateNamespace"}},"visibility":"internal"},{"constant":false,"id":359,"mutability":"mutable","name":"dispatch","nameLocation":"8966:8:8","nodeType":"VariableDeclaration","scope":372,"src":"8950:24:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_EncodedDispatch_$330","typeString":"EncodedDispatch"},"typeName":{"id":358,"nodeType":"UserDefinedTypeName","pathNode":{"id":357,"name":"EncodedDispatch","nameLocations":["8950:15:8"],"nodeType":"IdentifierPath","referencedDeclaration":330,"src":"8950:15:8"},"referencedDeclaration":330,"src":"8950:15:8","typeDescriptions":{"typeIdentifier":"t_userDefinedValueType$_EncodedDispatch_$330","typeString":"EncodedDispatch"}},"visibility":"internal"},{"constant":false,"id":363,"mutability":"mutable","name":"context","nameLocation":"9005:7:8","nodeType":"VariableDeclaration","scope":372,"src":"8984:28:8","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_array$_t_uint256_$dyn_calldata_ptr_$dyn_calldata_ptr","typeString":"uint256[][]"},"typeName":{"baseType":{"baseType":{"id":360,"name":"uint256","nodeType":"ElementaryTypeName","src":"8984:7:8","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":361,"nodeType":"ArrayTypeName","src":"8984:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"id":362,"nodeType":"ArrayTypeName","src":"8984:11:8","typeDescriptions":{"typeIdentifier":"t_array$_t_array$_t_uint256_$dyn_storage_$dyn_storage_ptr","typeString":"uint256[][]"}},"visibility":"internal"}],"src":"8871:147:8"},"returnParameters":{"id":371,"nodeType":"ParameterList","parameters":[{"constant":false,"id":367,"mutability":"mutable","name":"stack","nameLocation":"9059:5:8","nodeType":"VariableDeclaration","scope":372,"src":"9042:22:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":365,"name":"uint256","nodeType":"ElementaryTypeName","src":"9042:7:8","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":366,"nodeType":"ArrayTypeName","src":"9042:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"},{"constant":false,"id":370,"mutability":"mutable","name":"kvs","nameLocation":"9083:3:8","nodeType":"VariableDeclaration","scope":372,"src":"9066:20:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":368,"name":"uint256","nodeType":"ElementaryTypeName","src":"9066:7:8","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":369,"nodeType":"ArrayTypeName","src":"9066:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"}],"src":"9041:46:8"},"scope":373,"src":"8858:230:8","stateMutability":"view","virtual":false,"visibility":"external"}],"scope":374,"src":"4350:4740:8","usedErrors":[]}],"src":"32:9059:8"},"id":8},"lib/rain.interpreter/src/lib/LibDeployerDiscoverable.sol":{"ast":{"absolutePath":"lib/rain.interpreter/src/lib/LibDeployerDiscoverable.sol","exportedSymbols":{"DEFAULT_STATE_NAMESPACE":[342],"EncodedDispatch":[330],"FullyQualifiedNamespace":[291],"IExpressionDeployerV1":[286],"IInterpreterStoreV1":[323],"IInterpreterV1":[373],"LibDeployerDiscoverable":[422],"NO_STORE":[300],"Operand":[334],"SourceIndex":[328],"StateNamespace":[332]},"id":423,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":375,"literals":["solidity","^","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:9"},{"absolutePath":"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol","file":"../interface/IExpressionDeployerV1.sol","id":376,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":423,"sourceUnit":287,"src":"58:48:9","symbolAliases":[],"unitAlias":""},{"abstract":false,"baseContracts":[],"canonicalName":"LibDeployerDiscoverable","contractDependencies":[],"contractKind":"library","fullyImplemented":true,"id":422,"linearizedBaseContracts":[422],"name":"LibDeployerDiscoverable","nameLocation":"116:23:9","nodeType":"ContractDefinition","nodes":[{"body":{"id":420,"nodeType":"Block","src":"967:269:9","statements":[{"assignments":[384,387,389],"declarations":[{"constant":false,"id":384,"mutability":"mutable","name":"interpreter","nameLocation":"993:11:9","nodeType":"VariableDeclaration","scope":420,"src":"978:26:9","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterV1_$373","typeString":"contract IInterpreterV1"},"typeName":{"id":383,"nodeType":"UserDefinedTypeName","pathNode":{"id":382,"name":"IInterpreterV1","nameLocations":["978:14:9"],"nodeType":"IdentifierPath","referencedDeclaration":373,"src":"978:14:9"},"referencedDeclaration":373,"src":"978:14:9","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterV1_$373","typeString":"contract IInterpreterV1"}},"visibility":"internal"},{"constant":false,"id":387,"mutability":"mutable","name":"store","nameLocation":"1026:5:9","nodeType":"VariableDeclaration","scope":420,"src":"1006:25:9","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"},"typeName":{"id":386,"nodeType":"UserDefinedTypeName","pathNode":{"id":385,"name":"IInterpreterStoreV1","nameLocations":["1006:19:9"],"nodeType":"IdentifierPath","referencedDeclaration":323,"src":"1006:19:9"},"referencedDeclaration":323,"src":"1006:19:9","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"}},"visibility":"internal"},{"constant":false,"id":389,"mutability":"mutable","name":"expression","nameLocation":"1041:10:9","nodeType":"VariableDeclaration","scope":420,"src":"1033:18:9","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":388,"name":"address","nodeType":"ElementaryTypeName","src":"1033:7:9","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"id":410,"initialValue":{"arguments":[{"arguments":[{"hexValue":"30","id":397,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"1128:1:9","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":396,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"1116:11:9","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_$","typeString":"function (uint256) pure returns (bytes memory[] memory)"},"typeName":{"baseType":{"id":394,"name":"bytes","nodeType":"ElementaryTypeName","src":"1120:5:9","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":395,"nodeType":"ArrayTypeName","src":"1120:7:9","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}}},"id":398,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1116:14:9","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_ptr_$dyn_memory_ptr","typeString":"bytes memory[] memory"}},{"arguments":[{"hexValue":"30","id":402,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"1146:1:9","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":401,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"1132:13:9","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_uint256_$dyn_memory_ptr_$","typeString":"function (uint256) pure returns (uint256[] memory)"},"typeName":{"baseType":{"id":399,"name":"uint256","nodeType":"ElementaryTypeName","src":"1136:7:9","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":400,"nodeType":"ArrayTypeName","src":"1136:9:9","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}}},"id":403,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1132:16:9","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[] memory"}},{"arguments":[{"hexValue":"30","id":407,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"1164:1:9","typeDescriptions":{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"},"value":"0"}],"expression":{"argumentTypes":[{"typeIdentifier":"t_rational_0_by_1","typeString":"int_const 0"}],"id":406,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"NewExpression","src":"1150:13:9","typeDescriptions":{"typeIdentifier":"t_function_objectcreation_pure$_t_uint256_$returns$_t_array$_t_uint256_$dyn_memory_ptr_$","typeString":"function (uint256) pure returns (uint256[] memory)"},"typeName":{"baseType":{"id":404,"name":"uint256","nodeType":"ElementaryTypeName","src":"1154:7:9","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":405,"nodeType":"ArrayTypeName","src":"1154:9:9","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}}},"id":408,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1150:16:9","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[] memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_array$_t_bytes_memory_ptr_$dyn_memory_ptr","typeString":"bytes memory[] memory"},{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[] memory"},{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[] memory"}],"expression":{"arguments":[{"id":391,"name":"deployer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":379,"src":"1089:8:9","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":390,"name":"IExpressionDeployerV1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":286,"src":"1067:21:9","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IExpressionDeployerV1_$286_$","typeString":"type(contract IExpressionDeployerV1)"}},"id":392,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1067:31:9","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IExpressionDeployerV1_$286","typeString":"contract IExpressionDeployerV1"}},"id":393,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1099:16:9","memberName":"deployExpression","nodeType":"MemberAccess","referencedDeclaration":285,"src":"1067:48:9","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_$_t_array$_t_uint256_$dyn_memory_ptr_$_t_array$_t_uint256_$dyn_memory_ptr_$returns$_t_contract$_IInterpreterV1_$373_$_t_contract$_IInterpreterStoreV1_$323_$_t_address_$","typeString":"function (bytes memory[] memory,uint256[] memory,uint256[] memory) external returns (contract IInterpreterV1,contract IInterpreterStoreV1,address)"}},"id":409,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1067:100:9","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$_t_contract$_IInterpreterV1_$373_$_t_contract$_IInterpreterStoreV1_$323_$_t_address_$","typeString":"tuple(contract IInterpreterV1,contract IInterpreterStoreV1,address)"}},"nodeType":"VariableDeclarationStatement","src":"977:190:9"},{"expression":{"components":[{"id":411,"name":"interpreter","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":384,"src":"1178:11:9","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterV1_$373","typeString":"contract IInterpreterV1"}}],"id":412,"isConstant":false,"isInlineArray":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"TupleExpression","src":"1177:13:9","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterV1_$373","typeString":"contract IInterpreterV1"}},"id":413,"nodeType":"ExpressionStatement","src":"1177:13:9"},{"expression":{"components":[{"id":414,"name":"store","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":387,"src":"1201:5:9","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"}}],"id":415,"isConstant":false,"isInlineArray":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"TupleExpression","src":"1200:7:9","typeDescriptions":{"typeIdentifier":"t_contract$_IInterpreterStoreV1_$323","typeString":"contract IInterpreterStoreV1"}},"id":416,"nodeType":"ExpressionStatement","src":"1200:7:9"},{"expression":{"components":[{"id":417,"name":"expression","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":389,"src":"1218:10:9","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"id":418,"isConstant":false,"isInlineArray":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"TupleExpression","src":"1217:12:9","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":419,"nodeType":"ExpressionStatement","src":"1217:12:9"}]},"documentation":{"id":377,"nodeType":"StructuredDocumentation","src":"146:766:9","text":"Hack so that some deployer will emit an event with the sender as the\n caller of `touchDeployer`. This MAY be needed by indexers such as\n subgraph that can only index events from the first moment they are aware\n of some contract. The deployer MUST be registered in ERC1820 registry\n before it is touched, THEN the caller meta MUST be emitted after the\n deployer is touched. This allows indexers such as subgraph to index the\n deployer, then see the caller, then see the caller's meta emitted in the\n same transaction.\n This is NOT required if ANY other expression is deployed in the same\n transaction as the caller meta, there only needs to be one expression on\n ANY deployer known to ERC1820."},"id":421,"implemented":true,"kind":"function","modifiers":[],"name":"touchDeployer","nameLocation":"926:13:9","nodeType":"FunctionDefinition","parameters":{"id":380,"nodeType":"ParameterList","parameters":[{"constant":false,"id":379,"mutability":"mutable","name":"deployer","nameLocation":"948:8:9","nodeType":"VariableDeclaration","scope":421,"src":"940:16:9","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":378,"name":"address","nodeType":"ElementaryTypeName","src":"940:7:9","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"939:18:9"},"returnParameters":{"id":381,"nodeType":"ParameterList","parameters":[],"src":"967:0:9"},"scope":422,"src":"917:319:9","stateMutability":"nonpayable","virtual":false,"visibility":"internal"}],"scope":423,"src":"108:1130:9","usedErrors":[]}],"src":"32:1207:9"},"id":9},"lib/rain.metadata/src/IMetaV1.sol":{"ast":{"absolutePath":"lib/rain.metadata/src/IMetaV1.sol","exportedSymbols":{"IMetaV1":[451],"META_MAGIC_NUMBER_V1":[440],"NotRainMetaV1":[436],"UnexpectedMetaHash":[431]},"id":452,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":424,"literals":["solidity","^","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:10"},{"documentation":{"id":425,"nodeType":"StructuredDocumentation","src":"58:214:10","text":"Thrown when hashed metadata does NOT match the expected hash.\n @param expectedHash The hash expected by the `IMetaV1` contract.\n @param actualHash The hash of the metadata seen by the `IMetaV1` contract."},"errorSelector":"74fe10f0","id":431,"name":"UnexpectedMetaHash","nameLocation":"278:18:10","nodeType":"ErrorDefinition","parameters":{"id":430,"nodeType":"ParameterList","parameters":[{"constant":false,"id":427,"mutability":"mutable","name":"expectedHash","nameLocation":"305:12:10","nodeType":"VariableDeclaration","scope":431,"src":"297:20:10","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":426,"name":"bytes32","nodeType":"ElementaryTypeName","src":"297:7:10","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":429,"mutability":"mutable","name":"actualHash","nameLocation":"327:10:10","nodeType":"VariableDeclaration","scope":431,"src":"319:18:10","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":428,"name":"bytes32","nodeType":"ElementaryTypeName","src":"319:7:10","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"296:42:10"},"src":"272:67:10"},{"documentation":{"id":432,"nodeType":"StructuredDocumentation","src":"341:116:10","text":"Thrown when some bytes are expected to be rain meta and are not.\n @param unmeta the bytes that are not meta."},"errorSelector":"644cc258","id":436,"name":"NotRainMetaV1","nameLocation":"463:13:10","nodeType":"ErrorDefinition","parameters":{"id":435,"nodeType":"ParameterList","parameters":[{"constant":false,"id":434,"mutability":"mutable","name":"unmeta","nameLocation":"483:6:10","nodeType":"VariableDeclaration","scope":436,"src":"477:12:10","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":433,"name":"bytes","nodeType":"ElementaryTypeName","src":"477:5:10","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"476:14:10"},"src":"457:34:10"},{"constant":true,"id":440,"mutability":"constant","name":"META_MAGIC_NUMBER_V1","nameLocation":"644:20:10","nodeType":"VariableDeclaration","scope":452,"src":"628:57:10","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"},"typeName":{"id":438,"name":"uint64","nodeType":"ElementaryTypeName","src":"628:6:10","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"value":{"hexValue":"307866663061383963363734656537383734","id":439,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"667:18:10","typeDescriptions":{"typeIdentifier":"t_rational_18377652714897045620_by_1","typeString":"int_const 18377652714897045620"},"value":"0xff0a89c674ee7874"},"visibility":"internal"},{"abstract":false,"baseContracts":[],"canonicalName":"IMetaV1","contractDependencies":[],"contractKind":"interface","documentation":{"id":441,"nodeType":"StructuredDocumentation","src":"688:19:10","text":"@title IMetaV1"},"fullyImplemented":true,"id":451,"linearizedBaseContracts":[451],"name":"IMetaV1","nameLocation":"717:7:10","nodeType":"ContractDefinition","nodes":[{"anonymous":false,"documentation":{"id":442,"nodeType":"StructuredDocumentation","src":"731:697:10","text":"An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\n to the metadata so that tooling can easily drop/ignore data from unknown\n sources. As metadata is about something, the subject MUST be provided.\n @param sender The msg.sender.\n @param subject The entity that the metadata is about. MAY be the address\n of the emitting contract (as `uint256`) OR anything else. The\n interpretation of the subject is context specific, so will often be a\n hash of some data/thing that this metadata is about.\n @param meta Rain metadata V1 compliant metadata bytes.\n https://github.com/rainprotocol/specs/blob/main/metadata-v1.md"},"eventSelector":"bea766d03fa1efd3f81cc8634d08320bc62bb0ed9234ac59bbaafa5893fb6b13","id":450,"name":"MetaV1","nameLocation":"1439:6:10","nodeType":"EventDefinition","parameters":{"id":449,"nodeType":"ParameterList","parameters":[{"constant":false,"id":444,"indexed":false,"mutability":"mutable","name":"sender","nameLocation":"1454:6:10","nodeType":"VariableDeclaration","scope":450,"src":"1446:14:10","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":443,"name":"address","nodeType":"ElementaryTypeName","src":"1446:7:10","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":446,"indexed":false,"mutability":"mutable","name":"subject","nameLocation":"1470:7:10","nodeType":"VariableDeclaration","scope":450,"src":"1462:15:10","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":445,"name":"uint256","nodeType":"ElementaryTypeName","src":"1462:7:10","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":448,"indexed":false,"mutability":"mutable","name":"meta","nameLocation":"1485:4:10","nodeType":"VariableDeclaration","scope":450,"src":"1479:10:10","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":447,"name":"bytes","nodeType":"ElementaryTypeName","src":"1479:5:10","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1445:45:10"},"src":"1433:58:10"}],"scope":452,"src":"707:786:10","usedErrors":[]}],"src":"32:1462:10"},"id":10},"lib/rain.metadata/src/LibMeta.sol":{"ast":{"absolutePath":"lib/rain.metadata/src/LibMeta.sol","exportedSymbols":{"IMetaV1":[451],"LibMeta":[535],"META_MAGIC_NUMBER_V1":[440],"NotRainMetaV1":[436],"UnexpectedMetaHash":[431]},"id":536,"license":"CAL","nodeType":"SourceUnit","nodes":[{"id":453,"literals":["solidity","^","0.8",".18"],"nodeType":"PragmaDirective","src":"32:24:11"},{"absolutePath":"lib/rain.metadata/src/IMetaV1.sol","file":"./IMetaV1.sol","id":454,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":536,"sourceUnit":452,"src":"58:23:11","symbolAliases":[],"unitAlias":""},{"abstract":false,"baseContracts":[],"canonicalName":"LibMeta","contractDependencies":[],"contractKind":"library","documentation":{"id":455,"nodeType":"StructuredDocumentation","src":"83:122:11","text":"@title LibMeta\n @notice Need a place to put data that can be handled offchain like ABIs that\n IS NOT etherscan."},"fullyImplemented":true,"id":535,"linearizedBaseContracts":[535],"name":"LibMeta","nameLocation":"213:7:11","nodeType":"ContractDefinition","nodes":[{"body":{"id":487,"nodeType":"Block","src":"621:305:11","statements":[{"condition":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":466,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"expression":{"id":463,"name":"meta_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":458,"src":"635:5:11","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},"id":464,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"641:6:11","memberName":"length","nodeType":"MemberAccess","src":"635:12:11","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"<","rightExpression":{"hexValue":"38","id":465,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"650:1:11","typeDescriptions":{"typeIdentifier":"t_rational_8_by_1","typeString":"int_const 8"},"value":"8"},"src":"635:16:11","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":469,"nodeType":"IfStatement","src":"631:34:11","trueBody":{"expression":{"hexValue":"66616c7365","id":467,"isConstant":false,"isLValue":false,"isPure":true,"kind":"bool","lValueRequested":false,"nodeType":"Literal","src":"660:5:11","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"value":"false"},"functionReturnParameters":462,"id":468,"nodeType":"Return","src":"653:12:11"}},{"assignments":[471],"declarations":[{"constant":false,"id":471,"mutability":"mutable","name":"mask_","nameLocation":"683:5:11","nodeType":"VariableDeclaration","scope":487,"src":"675:13:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":470,"name":"uint256","nodeType":"ElementaryTypeName","src":"675:7:11","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":477,"initialValue":{"expression":{"arguments":[{"id":474,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"696:6:11","typeDescriptions":{"typeIdentifier":"t_type$_t_uint64_$","typeString":"type(uint64)"},"typeName":{"id":473,"name":"uint64","nodeType":"ElementaryTypeName","src":"696:6:11","typeDescriptions":{}}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_type$_t_uint64_$","typeString":"type(uint64)"}],"id":472,"name":"type","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-27,"src":"691:4:11","typeDescriptions":{"typeIdentifier":"t_function_metatype_pure$__$returns$__$","typeString":"function () pure"}},"id":475,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"691:12:11","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_magic_meta_type_t_uint64","typeString":"type(uint64)"}},"id":476,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"704:3:11","memberName":"max","nodeType":"MemberAccess","src":"691:16:11","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"nodeType":"VariableDeclarationStatement","src":"675:32:11"},{"assignments":[479],"declarations":[{"constant":false,"id":479,"mutability":"mutable","name":"magicNumber_","nameLocation":"725:12:11","nodeType":"VariableDeclaration","scope":487,"src":"717:20:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":478,"name":"uint256","nodeType":"ElementaryTypeName","src":"717:7:11","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"id":481,"initialValue":{"id":480,"name":"META_MAGIC_NUMBER_V1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":440,"src":"740:20:11","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"nodeType":"VariableDeclarationStatement","src":"717:43:11"},{"AST":{"nodeType":"YulBlock","src":"795:72:11","statements":[{"nodeType":"YulAssignment","src":"809:48:11","value":{"arguments":[{"arguments":[{"arguments":[{"name":"meta_","nodeType":"YulIdentifier","src":"839:5:11"},{"kind":"number","nodeType":"YulLiteral","src":"846:1:11","type":"","value":"8"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"835:3:11"},"nodeType":"YulFunctionCall","src":"835:13:11"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"829:5:11"},"nodeType":"YulFunctionCall","src":"829:20:11"},{"name":"mask_","nodeType":"YulIdentifier","src":"851:5:11"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"825:3:11"},"nodeType":"YulFunctionCall","src":"825:32:11"},"variableNames":[{"name":"magicNumber_","nodeType":"YulIdentifier","src":"809:12:11"}]}]},"evmVersion":"london","externalReferences":[{"declaration":479,"isOffset":false,"isSlot":false,"src":"809:12:11","valueSize":1},{"declaration":471,"isOffset":false,"isSlot":false,"src":"851:5:11","valueSize":1},{"declaration":458,"isOffset":false,"isSlot":false,"src":"839:5:11","valueSize":1}],"flags":["memory-safe"],"id":482,"nodeType":"InlineAssembly","src":"770:97:11"},{"expression":{"commonType":{"typeIdentifier":"t_uint256","typeString":"uint256"},"id":485,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":483,"name":"magicNumber_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":479,"src":"883:12:11","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":484,"name":"META_MAGIC_NUMBER_V1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":440,"src":"899:20:11","typeDescriptions":{"typeIdentifier":"t_uint64","typeString":"uint64"}},"src":"883:36:11","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":462,"id":486,"nodeType":"Return","src":"876:43:11"}]},"documentation":{"id":456,"nodeType":"StructuredDocumentation","src":"227:318:11","text":"Returns true if the metadata bytes are prefixed by the Rain meta magic\n number. DOES NOT attempt to validate the body of the metadata as offchain\n tooling will be required for this.\n @param meta_ The data that may be rain metadata.\n @return True if `meta_` is metadata, false otherwise."},"id":488,"implemented":true,"kind":"function","modifiers":[],"name":"isRainMetaV1","nameLocation":"559:12:11","nodeType":"FunctionDefinition","parameters":{"id":459,"nodeType":"ParameterList","parameters":[{"constant":false,"id":458,"mutability":"mutable","name":"meta_","nameLocation":"585:5:11","nodeType":"VariableDeclaration","scope":488,"src":"572:18:11","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":457,"name":"bytes","nodeType":"ElementaryTypeName","src":"572:5:11","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"571:20:11"},"returnParameters":{"id":462,"nodeType":"ParameterList","parameters":[{"constant":false,"id":461,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":488,"src":"615:4:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":460,"name":"bool","nodeType":"ElementaryTypeName","src":"615:4:11","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"614:6:11"},"scope":535,"src":"550:376:11","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":504,"nodeType":"Block","src":"1136:94:11","statements":[{"condition":{"id":497,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"nodeType":"UnaryOperation","operator":"!","prefix":true,"src":"1150:20:11","subExpression":{"arguments":[{"id":495,"name":"meta_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":491,"src":"1164:5:11","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"id":494,"name":"isRainMetaV1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":488,"src":"1151:12:11","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes_memory_ptr_$returns$_t_bool_$","typeString":"function (bytes memory) pure returns (bool)"}},"id":496,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1151:19:11","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":503,"nodeType":"IfStatement","src":"1146:78:11","trueBody":{"id":502,"nodeType":"Block","src":"1172:52:11","statements":[{"errorCall":{"arguments":[{"id":499,"name":"meta_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":491,"src":"1207:5:11","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"id":498,"name":"NotRainMetaV1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":436,"src":"1193:13:11","typeDescriptions":{"typeIdentifier":"t_function_error_pure$_t_bytes_memory_ptr_$returns$__$","typeString":"function (bytes memory) pure"}},"id":500,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1193:20:11","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":501,"nodeType":"RevertStatement","src":"1186:27:11"}]}}]},"documentation":{"id":489,"nodeType":"StructuredDocumentation","src":"932:138:11","text":"Reverts if the provided `meta_` is NOT metadata according to\n `isRainMetaV1`.\n @param meta_ The metadata bytes to check."},"id":505,"implemented":true,"kind":"function","modifiers":[],"name":"checkMetaUnhashed","nameLocation":"1084:17:11","nodeType":"FunctionDefinition","parameters":{"id":492,"nodeType":"ParameterList","parameters":[{"constant":false,"id":491,"mutability":"mutable","name":"meta_","nameLocation":"1115:5:11","nodeType":"VariableDeclaration","scope":505,"src":"1102:18:11","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":490,"name":"bytes","nodeType":"ElementaryTypeName","src":"1102:5:11","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1101:20:11"},"returnParameters":{"id":493,"nodeType":"ParameterList","parameters":[],"src":"1136:0:11"},"scope":535,"src":"1075:155:11","stateMutability":"pure","virtual":false,"visibility":"internal"},{"body":{"id":533,"nodeType":"Block","src":"1506:210:11","statements":[{"assignments":[514],"declarations":[{"constant":false,"id":514,"mutability":"mutable","name":"actualHash_","nameLocation":"1524:11:11","nodeType":"VariableDeclaration","scope":533,"src":"1516:19:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":513,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1516:7:11","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"id":518,"initialValue":{"arguments":[{"id":516,"name":"meta_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":510,"src":"1548:5:11","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"id":515,"name":"keccak256","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-8,"src":"1538:9:11","typeDescriptions":{"typeIdentifier":"t_function_keccak256_pure$_t_bytes_memory_ptr_$returns$_t_bytes32_$","typeString":"function (bytes memory) pure returns (bytes32)"}},"id":517,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1538:16:11","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"VariableDeclarationStatement","src":"1516:38:11"},{"condition":{"commonType":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"id":521,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":519,"name":"expectedHash_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":508,"src":"1568:13:11","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"nodeType":"BinaryOperation","operator":"!=","rightExpression":{"id":520,"name":"actualHash_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":514,"src":"1585:11:11","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"src":"1568:28:11","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":528,"nodeType":"IfStatement","src":"1564:112:11","trueBody":{"id":527,"nodeType":"Block","src":"1598:78:11","statements":[{"errorCall":{"arguments":[{"id":523,"name":"expectedHash_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":508,"src":"1638:13:11","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":524,"name":"actualHash_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":514,"src":"1653:11:11","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"}],"id":522,"name":"UnexpectedMetaHash","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":431,"src":"1619:18:11","typeDescriptions":{"typeIdentifier":"t_function_error_pure$_t_bytes32_$_t_bytes32_$returns$__$","typeString":"function (bytes32,bytes32) pure"}},"id":525,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1619:46:11","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":526,"nodeType":"RevertStatement","src":"1612:53:11"}]}},{"expression":{"arguments":[{"id":530,"name":"meta_","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":510,"src":"1703:5:11","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"id":529,"name":"checkMetaUnhashed","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":505,"src":"1685:17:11","typeDescriptions":{"typeIdentifier":"t_function_internal_pure$_t_bytes_memory_ptr_$returns$__$","typeString":"function (bytes memory) pure"}},"id":531,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1685:24:11","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":532,"nodeType":"ExpressionStatement","src":"1685:24:11"}]},"documentation":{"id":506,"nodeType":"StructuredDocumentation","src":"1236:183:11","text":"Reverts if the provided `meta_` is NOT metadata according to\n `isRainMetaV1` OR it does not match the expected hash of its data.\n @param meta_ The metadata to check."},"id":534,"implemented":true,"kind":"function","modifiers":[],"name":"checkMetaHashed","nameLocation":"1433:15:11","nodeType":"FunctionDefinition","parameters":{"id":511,"nodeType":"ParameterList","parameters":[{"constant":false,"id":508,"mutability":"mutable","name":"expectedHash_","nameLocation":"1457:13:11","nodeType":"VariableDeclaration","scope":534,"src":"1449:21:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":507,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1449:7:11","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":510,"mutability":"mutable","name":"meta_","nameLocation":"1485:5:11","nodeType":"VariableDeclaration","scope":534,"src":"1472:18:11","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":509,"name":"bytes","nodeType":"ElementaryTypeName","src":"1472:5:11","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1448:43:11"},"returnParameters":{"id":512,"nodeType":"ParameterList","parameters":[],"src":"1506:0:11"},"scope":535,"src":"1424:292:11","stateMutability":"pure","virtual":false,"visibility":"internal"}],"scope":536,"src":"205:1513:11","usedErrors":[]}],"src":"32:1687:11"},"id":11}},"contracts":{"lib/openzeppelin-contracts/contracts/proxy/Clones.sol":{"Clones":{"abi":[],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"60206037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fd","opcodes":"PUSH1 0x20 PUSH1 0x37 PUSH1 0xB DUP3 DUP3 DUP3 CODECOPY DUP1 MLOAD PUSH1 0x0 BYTE PUSH1 0x73 EQ PUSH1 0x2A JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x0 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST ADDRESS PUSH1 0x0 MSTORE PUSH1 0x73 DUP2 MSTORE8 DUP3 DUP2 RETURN INVALID PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT ","sourceMap":"755:3281:1:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;755:3281:1;;;;;;;;;;;;;;;;;"},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"73000000000000000000000000000000000000000030146080604052600080fd","opcodes":"PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT ","sourceMap":"755:3281:1:-:0;;;;;;;;"},"methodIdentifiers":{}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for deploying minimal proxy contracts, also known as \\\"clones\\\". > To simply and cheaply clone contract functionality in an immutable way, this standard specifies > a minimal bytecode implementation that delegates all calls to a known, fixed address. The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2` (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the deterministic method. _Available since v3.4._\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\":\"Clones\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x888d64d221d52c31d015b76e50ca1af5ef8ff076550810b49cea6b01d8267a10\",\"license\":\"MIT\"}},\"version\":1}"}},"lib/rain.factory/src/concrete/CloneFactory.sol":{"CloneFactory":{"abi":[{"inputs":[{"components":[{"internalType":"address","name":"deployer","type":"address"},{"internalType":"bytes","name":"meta","type":"bytes"}],"internalType":"struct DeployerDiscoverableMetaV1ConstructionConfig","name":"config_","type":"tuple"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"bytes","name":"unmeta","type":"bytes"}],"name":"NotRainMetaV1","type":"error"},{"inputs":[{"internalType":"bytes32","name":"expectedHash","type":"bytes32"},{"internalType":"bytes32","name":"actualHash","type":"bytes32"}],"name":"UnexpectedMetaHash","type":"error"},{"inputs":[],"name":"ZeroImplementation","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"subject","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"meta","type":"bytes"}],"name":"MetaV1","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"address","name":"implementation","type":"address"},{"indexed":false,"internalType":"address","name":"clone","type":"address"}],"name":"NewClone","type":"event"},{"inputs":[{"internalType":"address","name":"implementation_","type":"address"},{"internalType":"bytes","name":"data_","type":"bytes"}],"name":"clone","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"}],"evm":{"bytecode":{"functionDebugData":{"@_113":{"entryPoint":null,"id":113,"parameterSlots":1,"returnSlots":0},"@_246":{"entryPoint":null,"id":246,"parameterSlots":2,"returnSlots":0},"@checkMetaHashed_534":{"entryPoint":216,"id":534,"parameterSlots":2,"returnSlots":0},"@checkMetaUnhashed_505":{"entryPoint":490,"id":505,"parameterSlots":1,"returnSlots":0},"@isRainMetaV1_488":{"entryPoint":538,"id":488,"parameterSlots":1,"returnSlots":1},"@touchDeployer_421":{"entryPoint":287,"id":421,"parameterSlots":1,"returnSlots":0},"abi_decode_tuple_t_contract$_IInterpreterV1_$373t_contract$_IInterpreterStoreV1_$323t_address_fromMemory":{"entryPoint":1290,"id":null,"parameterSlots":2,"returnSlots":3},"abi_decode_tuple_t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_memory_ptr_fromMemory":{"entryPoint":762,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_array_uint256_dyn":{"entryPoint":1082,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_bytes":{"entryPoint":986,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_address_t_uint256_t_bytes_memory_ptr__to_t_address_t_uint256_t_bytes_memory_ptr__fromStack_reversed":{"entryPoint":1032,"id":null,"parameterSlots":4,"returnSlots":1},"abi_encode_tuple_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__fromStack_reversed":{"entryPoint":1143,"id":null,"parameterSlots":4,"returnSlots":1},"abi_encode_tuple_t_bytes32_t_bytes32__to_t_bytes32_t_bytes32__fromStack_reversed":{"entryPoint":null,"id":null,"parameterSlots":3,"returnSlots":1},"abi_encode_tuple_t_bytes_memory_ptr__to_t_bytes_memory_ptr__fromStack_reversed":{"entryPoint":1374,"id":null,"parameterSlots":2,"returnSlots":1},"allocate_memory":{"entryPoint":651,"id":null,"parameterSlots":1,"returnSlots":1},"allocate_memory_945":{"entryPoint":608,"id":null,"parameterSlots":0,"returnSlots":1},"copy_memory_to_memory_with_cleanup":{"entryPoint":724,"id":null,"parameterSlots":3,"returnSlots":0},"panic_error_0x41":{"entryPoint":586,"id":null,"parameterSlots":0,"returnSlots":0},"validator_revert_address":{"entryPoint":702,"id":null,"parameterSlots":1,"returnSlots":0}},"generatedSources":[{"ast":{"nodeType":"YulBlock","src":"0:5580:12","statements":[{"nodeType":"YulBlock","src":"6:3:12","statements":[]},{"body":{"nodeType":"YulBlock","src":"46:95:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"63:1:12","type":"","value":"0"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"70:3:12","type":"","value":"224"},{"kind":"number","nodeType":"YulLiteral","src":"75:10:12","type":"","value":"0x4e487b71"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"66:3:12"},"nodeType":"YulFunctionCall","src":"66:20:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"56:6:12"},"nodeType":"YulFunctionCall","src":"56:31:12"},"nodeType":"YulExpressionStatement","src":"56:31:12"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"103:1:12","type":"","value":"4"},{"kind":"number","nodeType":"YulLiteral","src":"106:4:12","type":"","value":"0x41"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"96:6:12"},"nodeType":"YulFunctionCall","src":"96:15:12"},"nodeType":"YulExpressionStatement","src":"96:15:12"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"127:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"130:4:12","type":"","value":"0x24"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"120:6:12"},"nodeType":"YulFunctionCall","src":"120:15:12"},"nodeType":"YulExpressionStatement","src":"120:15:12"}]},"name":"panic_error_0x41","nodeType":"YulFunctionDefinition","src":"14:127:12"},{"body":{"nodeType":"YulBlock","src":"191:211:12","statements":[{"nodeType":"YulAssignment","src":"201:21:12","value":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"217:4:12","type":"","value":"0x40"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"211:5:12"},"nodeType":"YulFunctionCall","src":"211:11:12"},"variableNames":[{"name":"memPtr","nodeType":"YulIdentifier","src":"201:6:12"}]},{"nodeType":"YulVariableDeclaration","src":"231:35:12","value":{"arguments":[{"name":"memPtr","nodeType":"YulIdentifier","src":"253:6:12"},{"kind":"number","nodeType":"YulLiteral","src":"261:4:12","type":"","value":"0x40"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"249:3:12"},"nodeType":"YulFunctionCall","src":"249:17:12"},"variables":[{"name":"newFreePtr","nodeType":"YulTypedName","src":"235:10:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"341:22:12","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x41","nodeType":"YulIdentifier","src":"343:16:12"},"nodeType":"YulFunctionCall","src":"343:18:12"},"nodeType":"YulExpressionStatement","src":"343:18:12"}]},"condition":{"arguments":[{"arguments":[{"name":"newFreePtr","nodeType":"YulIdentifier","src":"284:10:12"},{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"304:2:12","type":"","value":"64"},{"kind":"number","nodeType":"YulLiteral","src":"308:1:12","type":"","value":"1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"300:3:12"},"nodeType":"YulFunctionCall","src":"300:10:12"},{"kind":"number","nodeType":"YulLiteral","src":"312:1:12","type":"","value":"1"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"296:3:12"},"nodeType":"YulFunctionCall","src":"296:18:12"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"281:2:12"},"nodeType":"YulFunctionCall","src":"281:34:12"},{"arguments":[{"name":"newFreePtr","nodeType":"YulIdentifier","src":"320:10:12"},{"name":"memPtr","nodeType":"YulIdentifier","src":"332:6:12"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"317:2:12"},"nodeType":"YulFunctionCall","src":"317:22:12"}],"functionName":{"name":"or","nodeType":"YulIdentifier","src":"278:2:12"},"nodeType":"YulFunctionCall","src":"278:62:12"},"nodeType":"YulIf","src":"275:88:12"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"379:4:12","type":"","value":"0x40"},{"name":"newFreePtr","nodeType":"YulIdentifier","src":"385:10:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"372:6:12"},"nodeType":"YulFunctionCall","src":"372:24:12"},"nodeType":"YulExpressionStatement","src":"372:24:12"}]},"name":"allocate_memory_945","nodeType":"YulFunctionDefinition","returnVariables":[{"name":"memPtr","nodeType":"YulTypedName","src":"180:6:12","type":""}],"src":"146:256:12"},{"body":{"nodeType":"YulBlock","src":"452:230:12","statements":[{"nodeType":"YulAssignment","src":"462:19:12","value":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"478:2:12","type":"","value":"64"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"472:5:12"},"nodeType":"YulFunctionCall","src":"472:9:12"},"variableNames":[{"name":"memPtr","nodeType":"YulIdentifier","src":"462:6:12"}]},{"nodeType":"YulVariableDeclaration","src":"490:58:12","value":{"arguments":[{"name":"memPtr","nodeType":"YulIdentifier","src":"512:6:12"},{"arguments":[{"arguments":[{"name":"size","nodeType":"YulIdentifier","src":"528:4:12"},{"kind":"number","nodeType":"YulLiteral","src":"534:2:12","type":"","value":"31"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"524:3:12"},"nodeType":"YulFunctionCall","src":"524:13:12"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"543:2:12","type":"","value":"31"}],"functionName":{"name":"not","nodeType":"YulIdentifier","src":"539:3:12"},"nodeType":"YulFunctionCall","src":"539:7:12"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"520:3:12"},"nodeType":"YulFunctionCall","src":"520:27:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"508:3:12"},"nodeType":"YulFunctionCall","src":"508:40:12"},"variables":[{"name":"newFreePtr","nodeType":"YulTypedName","src":"494:10:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"623:22:12","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x41","nodeType":"YulIdentifier","src":"625:16:12"},"nodeType":"YulFunctionCall","src":"625:18:12"},"nodeType":"YulExpressionStatement","src":"625:18:12"}]},"condition":{"arguments":[{"arguments":[{"name":"newFreePtr","nodeType":"YulIdentifier","src":"566:10:12"},{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"586:2:12","type":"","value":"64"},{"kind":"number","nodeType":"YulLiteral","src":"590:1:12","type":"","value":"1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"582:3:12"},"nodeType":"YulFunctionCall","src":"582:10:12"},{"kind":"number","nodeType":"YulLiteral","src":"594:1:12","type":"","value":"1"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"578:3:12"},"nodeType":"YulFunctionCall","src":"578:18:12"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"563:2:12"},"nodeType":"YulFunctionCall","src":"563:34:12"},{"arguments":[{"name":"newFreePtr","nodeType":"YulIdentifier","src":"602:10:12"},{"name":"memPtr","nodeType":"YulIdentifier","src":"614:6:12"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"599:2:12"},"nodeType":"YulFunctionCall","src":"599:22:12"}],"functionName":{"name":"or","nodeType":"YulIdentifier","src":"560:2:12"},"nodeType":"YulFunctionCall","src":"560:62:12"},"nodeType":"YulIf","src":"557:88:12"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"661:2:12","type":"","value":"64"},{"name":"newFreePtr","nodeType":"YulIdentifier","src":"665:10:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"654:6:12"},"nodeType":"YulFunctionCall","src":"654:22:12"},"nodeType":"YulExpressionStatement","src":"654:22:12"}]},"name":"allocate_memory","nodeType":"YulFunctionDefinition","parameters":[{"name":"size","nodeType":"YulTypedName","src":"432:4:12","type":""}],"returnVariables":[{"name":"memPtr","nodeType":"YulTypedName","src":"441:6:12","type":""}],"src":"407:275:12"},{"body":{"nodeType":"YulBlock","src":"732:86:12","statements":[{"body":{"nodeType":"YulBlock","src":"796:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"805:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"808:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"798:6:12"},"nodeType":"YulFunctionCall","src":"798:12:12"},"nodeType":"YulExpressionStatement","src":"798:12:12"}]},"condition":{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"755:5:12"},{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"766:5:12"},{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"781:3:12","type":"","value":"160"},{"kind":"number","nodeType":"YulLiteral","src":"786:1:12","type":"","value":"1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"777:3:12"},"nodeType":"YulFunctionCall","src":"777:11:12"},{"kind":"number","nodeType":"YulLiteral","src":"790:1:12","type":"","value":"1"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"773:3:12"},"nodeType":"YulFunctionCall","src":"773:19:12"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"762:3:12"},"nodeType":"YulFunctionCall","src":"762:31:12"}],"functionName":{"name":"eq","nodeType":"YulIdentifier","src":"752:2:12"},"nodeType":"YulFunctionCall","src":"752:42:12"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"745:6:12"},"nodeType":"YulFunctionCall","src":"745:50:12"},"nodeType":"YulIf","src":"742:70:12"}]},"name":"validator_revert_address","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nodeType":"YulTypedName","src":"721:5:12","type":""}],"src":"687:131:12"},{"body":{"nodeType":"YulBlock","src":"889:184:12","statements":[{"nodeType":"YulVariableDeclaration","src":"899:10:12","value":{"kind":"number","nodeType":"YulLiteral","src":"908:1:12","type":"","value":"0"},"variables":[{"name":"i","nodeType":"YulTypedName","src":"903:1:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"968:63:12","statements":[{"expression":{"arguments":[{"arguments":[{"name":"dst","nodeType":"YulIdentifier","src":"993:3:12"},{"name":"i","nodeType":"YulIdentifier","src":"998:1:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"989:3:12"},"nodeType":"YulFunctionCall","src":"989:11:12"},{"arguments":[{"arguments":[{"name":"src","nodeType":"YulIdentifier","src":"1012:3:12"},{"name":"i","nodeType":"YulIdentifier","src":"1017:1:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1008:3:12"},"nodeType":"YulFunctionCall","src":"1008:11:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"1002:5:12"},"nodeType":"YulFunctionCall","src":"1002:18:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"982:6:12"},"nodeType":"YulFunctionCall","src":"982:39:12"},"nodeType":"YulExpressionStatement","src":"982:39:12"}]},"condition":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"929:1:12"},{"name":"length","nodeType":"YulIdentifier","src":"932:6:12"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"926:2:12"},"nodeType":"YulFunctionCall","src":"926:13:12"},"nodeType":"YulForLoop","post":{"nodeType":"YulBlock","src":"940:19:12","statements":[{"nodeType":"YulAssignment","src":"942:15:12","value":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"951:1:12"},{"kind":"number","nodeType":"YulLiteral","src":"954:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"947:3:12"},"nodeType":"YulFunctionCall","src":"947:10:12"},"variableNames":[{"name":"i","nodeType":"YulIdentifier","src":"942:1:12"}]}]},"pre":{"nodeType":"YulBlock","src":"922:3:12","statements":[]},"src":"918:113:12"},{"expression":{"arguments":[{"arguments":[{"name":"dst","nodeType":"YulIdentifier","src":"1051:3:12"},{"name":"length","nodeType":"YulIdentifier","src":"1056:6:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1047:3:12"},"nodeType":"YulFunctionCall","src":"1047:16:12"},{"kind":"number","nodeType":"YulLiteral","src":"1065:1:12","type":"","value":"0"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1040:6:12"},"nodeType":"YulFunctionCall","src":"1040:27:12"},"nodeType":"YulExpressionStatement","src":"1040:27:12"}]},"name":"copy_memory_to_memory_with_cleanup","nodeType":"YulFunctionDefinition","parameters":[{"name":"src","nodeType":"YulTypedName","src":"867:3:12","type":""},{"name":"dst","nodeType":"YulTypedName","src":"872:3:12","type":""},{"name":"length","nodeType":"YulTypedName","src":"877:6:12","type":""}],"src":"823:250:12"},{"body":{"nodeType":"YulBlock","src":"1220:1016:12","statements":[{"nodeType":"YulVariableDeclaration","src":"1230:12:12","value":{"kind":"number","nodeType":"YulLiteral","src":"1240:2:12","type":"","value":"32"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"1234:2:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"1287:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1296:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1299:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1289:6:12"},"nodeType":"YulFunctionCall","src":"1289:12:12"},"nodeType":"YulExpressionStatement","src":"1289:12:12"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nodeType":"YulIdentifier","src":"1262:7:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"1271:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"1258:3:12"},"nodeType":"YulFunctionCall","src":"1258:23:12"},{"name":"_1","nodeType":"YulIdentifier","src":"1283:2:12"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"1254:3:12"},"nodeType":"YulFunctionCall","src":"1254:32:12"},"nodeType":"YulIf","src":"1251:52:12"},{"nodeType":"YulVariableDeclaration","src":"1312:30:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1332:9:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"1326:5:12"},"nodeType":"YulFunctionCall","src":"1326:16:12"},"variables":[{"name":"offset","nodeType":"YulTypedName","src":"1316:6:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"1351:28:12","value":{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1369:2:12","type":"","value":"64"},{"kind":"number","nodeType":"YulLiteral","src":"1373:1:12","type":"","value":"1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"1365:3:12"},"nodeType":"YulFunctionCall","src":"1365:10:12"},{"kind":"number","nodeType":"YulLiteral","src":"1377:1:12","type":"","value":"1"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"1361:3:12"},"nodeType":"YulFunctionCall","src":"1361:18:12"},"variables":[{"name":"_2","nodeType":"YulTypedName","src":"1355:2:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"1406:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1415:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1418:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1408:6:12"},"nodeType":"YulFunctionCall","src":"1408:12:12"},"nodeType":"YulExpressionStatement","src":"1408:12:12"}]},"condition":{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"1394:6:12"},{"name":"_2","nodeType":"YulIdentifier","src":"1402:2:12"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"1391:2:12"},"nodeType":"YulFunctionCall","src":"1391:14:12"},"nodeType":"YulIf","src":"1388:34:12"},{"nodeType":"YulVariableDeclaration","src":"1431:32:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1445:9:12"},{"name":"offset","nodeType":"YulIdentifier","src":"1456:6:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1441:3:12"},"nodeType":"YulFunctionCall","src":"1441:22:12"},"variables":[{"name":"_3","nodeType":"YulTypedName","src":"1435:2:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"1503:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1512:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1515:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1505:6:12"},"nodeType":"YulFunctionCall","src":"1505:12:12"},"nodeType":"YulExpressionStatement","src":"1505:12:12"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nodeType":"YulIdentifier","src":"1483:7:12"},{"name":"_3","nodeType":"YulIdentifier","src":"1492:2:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"1479:3:12"},"nodeType":"YulFunctionCall","src":"1479:16:12"},{"kind":"number","nodeType":"YulLiteral","src":"1497:4:12","type":"","value":"0x40"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"1475:3:12"},"nodeType":"YulFunctionCall","src":"1475:27:12"},"nodeType":"YulIf","src":"1472:47:12"},{"nodeType":"YulVariableDeclaration","src":"1528:34:12","value":{"arguments":[],"functionName":{"name":"allocate_memory_945","nodeType":"YulIdentifier","src":"1541:19:12"},"nodeType":"YulFunctionCall","src":"1541:21:12"},"variables":[{"name":"value","nodeType":"YulTypedName","src":"1532:5:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"1571:24:12","value":{"arguments":[{"name":"_3","nodeType":"YulIdentifier","src":"1592:2:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"1586:5:12"},"nodeType":"YulFunctionCall","src":"1586:9:12"},"variables":[{"name":"value_1","nodeType":"YulTypedName","src":"1575:7:12","type":""}]},{"expression":{"arguments":[{"name":"value_1","nodeType":"YulIdentifier","src":"1629:7:12"}],"functionName":{"name":"validator_revert_address","nodeType":"YulIdentifier","src":"1604:24:12"},"nodeType":"YulFunctionCall","src":"1604:33:12"},"nodeType":"YulExpressionStatement","src":"1604:33:12"},{"expression":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"1653:5:12"},{"name":"value_1","nodeType":"YulIdentifier","src":"1660:7:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1646:6:12"},"nodeType":"YulFunctionCall","src":"1646:22:12"},"nodeType":"YulExpressionStatement","src":"1646:22:12"},{"nodeType":"YulVariableDeclaration","src":"1677:34:12","value":{"arguments":[{"arguments":[{"name":"_3","nodeType":"YulIdentifier","src":"1703:2:12"},{"name":"_1","nodeType":"YulIdentifier","src":"1707:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1699:3:12"},"nodeType":"YulFunctionCall","src":"1699:11:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"1693:5:12"},"nodeType":"YulFunctionCall","src":"1693:18:12"},"variables":[{"name":"offset_1","nodeType":"YulTypedName","src":"1681:8:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"1740:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1749:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1752:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1742:6:12"},"nodeType":"YulFunctionCall","src":"1742:12:12"},"nodeType":"YulExpressionStatement","src":"1742:12:12"}]},"condition":{"arguments":[{"name":"offset_1","nodeType":"YulIdentifier","src":"1726:8:12"},{"name":"_2","nodeType":"YulIdentifier","src":"1736:2:12"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"1723:2:12"},"nodeType":"YulFunctionCall","src":"1723:16:12"},"nodeType":"YulIf","src":"1720:36:12"},{"nodeType":"YulVariableDeclaration","src":"1765:27:12","value":{"arguments":[{"name":"_3","nodeType":"YulIdentifier","src":"1779:2:12"},{"name":"offset_1","nodeType":"YulIdentifier","src":"1783:8:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1775:3:12"},"nodeType":"YulFunctionCall","src":"1775:17:12"},"variables":[{"name":"_4","nodeType":"YulTypedName","src":"1769:2:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"1840:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1849:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1852:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1842:6:12"},"nodeType":"YulFunctionCall","src":"1842:12:12"},"nodeType":"YulExpressionStatement","src":"1842:12:12"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"_4","nodeType":"YulIdentifier","src":"1819:2:12"},{"kind":"number","nodeType":"YulLiteral","src":"1823:4:12","type":"","value":"0x1f"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1815:3:12"},"nodeType":"YulFunctionCall","src":"1815:13:12"},{"name":"dataEnd","nodeType":"YulIdentifier","src":"1830:7:12"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"1811:3:12"},"nodeType":"YulFunctionCall","src":"1811:27:12"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"1804:6:12"},"nodeType":"YulFunctionCall","src":"1804:35:12"},"nodeType":"YulIf","src":"1801:55:12"},{"nodeType":"YulVariableDeclaration","src":"1865:19:12","value":{"arguments":[{"name":"_4","nodeType":"YulIdentifier","src":"1881:2:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"1875:5:12"},"nodeType":"YulFunctionCall","src":"1875:9:12"},"variables":[{"name":"_5","nodeType":"YulTypedName","src":"1869:2:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"1907:22:12","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x41","nodeType":"YulIdentifier","src":"1909:16:12"},"nodeType":"YulFunctionCall","src":"1909:18:12"},"nodeType":"YulExpressionStatement","src":"1909:18:12"}]},"condition":{"arguments":[{"name":"_5","nodeType":"YulIdentifier","src":"1899:2:12"},{"name":"_2","nodeType":"YulIdentifier","src":"1903:2:12"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"1896:2:12"},"nodeType":"YulFunctionCall","src":"1896:10:12"},"nodeType":"YulIf","src":"1893:36:12"},{"nodeType":"YulVariableDeclaration","src":"1938:66:12","value":{"arguments":[{"arguments":[{"arguments":[{"arguments":[{"name":"_5","nodeType":"YulIdentifier","src":"1979:2:12"},{"kind":"number","nodeType":"YulLiteral","src":"1983:4:12","type":"","value":"0x1f"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1975:3:12"},"nodeType":"YulFunctionCall","src":"1975:13:12"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1994:2:12","type":"","value":"31"}],"functionName":{"name":"not","nodeType":"YulIdentifier","src":"1990:3:12"},"nodeType":"YulFunctionCall","src":"1990:7:12"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"1971:3:12"},"nodeType":"YulFunctionCall","src":"1971:27:12"},{"name":"_1","nodeType":"YulIdentifier","src":"2000:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1967:3:12"},"nodeType":"YulFunctionCall","src":"1967:36:12"}],"functionName":{"name":"allocate_memory","nodeType":"YulIdentifier","src":"1951:15:12"},"nodeType":"YulFunctionCall","src":"1951:53:12"},"variables":[{"name":"array","nodeType":"YulTypedName","src":"1942:5:12","type":""}]},{"expression":{"arguments":[{"name":"array","nodeType":"YulIdentifier","src":"2020:5:12"},{"name":"_5","nodeType":"YulIdentifier","src":"2027:2:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2013:6:12"},"nodeType":"YulFunctionCall","src":"2013:17:12"},"nodeType":"YulExpressionStatement","src":"2013:17:12"},{"body":{"nodeType":"YulBlock","src":"2076:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2085:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"2088:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"2078:6:12"},"nodeType":"YulFunctionCall","src":"2078:12:12"},"nodeType":"YulExpressionStatement","src":"2078:12:12"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"_4","nodeType":"YulIdentifier","src":"2053:2:12"},{"name":"_5","nodeType":"YulIdentifier","src":"2057:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2049:3:12"},"nodeType":"YulFunctionCall","src":"2049:11:12"},{"name":"_1","nodeType":"YulIdentifier","src":"2062:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2045:3:12"},"nodeType":"YulFunctionCall","src":"2045:20:12"},{"name":"dataEnd","nodeType":"YulIdentifier","src":"2067:7:12"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"2042:2:12"},"nodeType":"YulFunctionCall","src":"2042:33:12"},"nodeType":"YulIf","src":"2039:53:12"},{"expression":{"arguments":[{"arguments":[{"name":"_4","nodeType":"YulIdentifier","src":"2140:2:12"},{"name":"_1","nodeType":"YulIdentifier","src":"2144:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2136:3:12"},"nodeType":"YulFunctionCall","src":"2136:11:12"},{"arguments":[{"name":"array","nodeType":"YulIdentifier","src":"2153:5:12"},{"name":"_1","nodeType":"YulIdentifier","src":"2160:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2149:3:12"},"nodeType":"YulFunctionCall","src":"2149:14:12"},{"name":"_5","nodeType":"YulIdentifier","src":"2165:2:12"}],"functionName":{"name":"copy_memory_to_memory_with_cleanup","nodeType":"YulIdentifier","src":"2101:34:12"},"nodeType":"YulFunctionCall","src":"2101:67:12"},"nodeType":"YulExpressionStatement","src":"2101:67:12"},{"expression":{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"2188:5:12"},{"name":"_1","nodeType":"YulIdentifier","src":"2195:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2184:3:12"},"nodeType":"YulFunctionCall","src":"2184:14:12"},{"name":"array","nodeType":"YulIdentifier","src":"2200:5:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2177:6:12"},"nodeType":"YulFunctionCall","src":"2177:29:12"},"nodeType":"YulExpressionStatement","src":"2177:29:12"},{"nodeType":"YulAssignment","src":"2215:15:12","value":{"name":"value","nodeType":"YulIdentifier","src":"2225:5:12"},"variableNames":[{"name":"value0","nodeType":"YulIdentifier","src":"2215:6:12"}]}]},"name":"abi_decode_tuple_t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_memory_ptr_fromMemory","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"1186:9:12","type":""},{"name":"dataEnd","nodeType":"YulTypedName","src":"1197:7:12","type":""}],"returnVariables":[{"name":"value0","nodeType":"YulTypedName","src":"1209:6:12","type":""}],"src":"1078:1158:12"},{"body":{"nodeType":"YulBlock","src":"2290:221:12","statements":[{"nodeType":"YulVariableDeclaration","src":"2300:26:12","value":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"2320:5:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"2314:5:12"},"nodeType":"YulFunctionCall","src":"2314:12:12"},"variables":[{"name":"length","nodeType":"YulTypedName","src":"2304:6:12","type":""}]},{"expression":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"2342:3:12"},{"name":"length","nodeType":"YulIdentifier","src":"2347:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2335:6:12"},"nodeType":"YulFunctionCall","src":"2335:19:12"},"nodeType":"YulExpressionStatement","src":"2335:19:12"},{"expression":{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"2402:5:12"},{"kind":"number","nodeType":"YulLiteral","src":"2409:4:12","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2398:3:12"},"nodeType":"YulFunctionCall","src":"2398:16:12"},{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"2420:3:12"},{"kind":"number","nodeType":"YulLiteral","src":"2425:4:12","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2416:3:12"},"nodeType":"YulFunctionCall","src":"2416:14:12"},{"name":"length","nodeType":"YulIdentifier","src":"2432:6:12"}],"functionName":{"name":"copy_memory_to_memory_with_cleanup","nodeType":"YulIdentifier","src":"2363:34:12"},"nodeType":"YulFunctionCall","src":"2363:76:12"},"nodeType":"YulExpressionStatement","src":"2363:76:12"},{"nodeType":"YulAssignment","src":"2448:57:12","value":{"arguments":[{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"2463:3:12"},{"arguments":[{"arguments":[{"name":"length","nodeType":"YulIdentifier","src":"2476:6:12"},{"kind":"number","nodeType":"YulLiteral","src":"2484:2:12","type":"","value":"31"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2472:3:12"},"nodeType":"YulFunctionCall","src":"2472:15:12"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2493:2:12","type":"","value":"31"}],"functionName":{"name":"not","nodeType":"YulIdentifier","src":"2489:3:12"},"nodeType":"YulFunctionCall","src":"2489:7:12"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"2468:3:12"},"nodeType":"YulFunctionCall","src":"2468:29:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2459:3:12"},"nodeType":"YulFunctionCall","src":"2459:39:12"},{"kind":"number","nodeType":"YulLiteral","src":"2500:4:12","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2455:3:12"},"nodeType":"YulFunctionCall","src":"2455:50:12"},"variableNames":[{"name":"end","nodeType":"YulIdentifier","src":"2448:3:12"}]}]},"name":"abi_encode_bytes","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nodeType":"YulTypedName","src":"2267:5:12","type":""},{"name":"pos","nodeType":"YulTypedName","src":"2274:3:12","type":""}],"returnVariables":[{"name":"end","nodeType":"YulTypedName","src":"2282:3:12","type":""}],"src":"2241:270:12"},{"body":{"nodeType":"YulBlock","src":"2691:210:12","statements":[{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2708:9:12"},{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"2723:6:12"},{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2739:3:12","type":"","value":"160"},{"kind":"number","nodeType":"YulLiteral","src":"2744:1:12","type":"","value":"1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"2735:3:12"},"nodeType":"YulFunctionCall","src":"2735:11:12"},{"kind":"number","nodeType":"YulLiteral","src":"2748:1:12","type":"","value":"1"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"2731:3:12"},"nodeType":"YulFunctionCall","src":"2731:19:12"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"2719:3:12"},"nodeType":"YulFunctionCall","src":"2719:32:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2701:6:12"},"nodeType":"YulFunctionCall","src":"2701:51:12"},"nodeType":"YulExpressionStatement","src":"2701:51:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2772:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"2783:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2768:3:12"},"nodeType":"YulFunctionCall","src":"2768:18:12"},{"name":"value1","nodeType":"YulIdentifier","src":"2788:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2761:6:12"},"nodeType":"YulFunctionCall","src":"2761:34:12"},"nodeType":"YulExpressionStatement","src":"2761:34:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2815:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"2826:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2811:3:12"},"nodeType":"YulFunctionCall","src":"2811:18:12"},{"kind":"number","nodeType":"YulLiteral","src":"2831:2:12","type":"","value":"96"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2804:6:12"},"nodeType":"YulFunctionCall","src":"2804:30:12"},"nodeType":"YulExpressionStatement","src":"2804:30:12"},{"nodeType":"YulAssignment","src":"2843:52:12","value":{"arguments":[{"name":"value2","nodeType":"YulIdentifier","src":"2868:6:12"},{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2880:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"2891:2:12","type":"","value":"96"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2876:3:12"},"nodeType":"YulFunctionCall","src":"2876:18:12"}],"functionName":{"name":"abi_encode_bytes","nodeType":"YulIdentifier","src":"2851:16:12"},"nodeType":"YulFunctionCall","src":"2851:44:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"2843:4:12"}]}]},"name":"abi_encode_tuple_t_address_t_uint256_t_bytes_memory_ptr__to_t_address_t_uint256_t_bytes_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"2644:9:12","type":""},{"name":"value2","nodeType":"YulTypedName","src":"2655:6:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"2663:6:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"2671:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"2682:4:12","type":""}],"src":"2516:385:12"},{"body":{"nodeType":"YulBlock","src":"3035:119:12","statements":[{"nodeType":"YulAssignment","src":"3045:26:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3057:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"3068:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3053:3:12"},"nodeType":"YulFunctionCall","src":"3053:18:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"3045:4:12"}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3087:9:12"},{"name":"value0","nodeType":"YulIdentifier","src":"3098:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3080:6:12"},"nodeType":"YulFunctionCall","src":"3080:25:12"},"nodeType":"YulExpressionStatement","src":"3080:25:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3125:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"3136:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3121:3:12"},"nodeType":"YulFunctionCall","src":"3121:18:12"},{"name":"value1","nodeType":"YulIdentifier","src":"3141:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3114:6:12"},"nodeType":"YulFunctionCall","src":"3114:34:12"},"nodeType":"YulExpressionStatement","src":"3114:34:12"}]},"name":"abi_encode_tuple_t_bytes32_t_bytes32__to_t_bytes32_t_bytes32__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"2996:9:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"3007:6:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"3015:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"3026:4:12","type":""}],"src":"2906:248:12"},{"body":{"nodeType":"YulBlock","src":"3220:374:12","statements":[{"nodeType":"YulVariableDeclaration","src":"3230:26:12","value":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"3250:5:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"3244:5:12"},"nodeType":"YulFunctionCall","src":"3244:12:12"},"variables":[{"name":"length","nodeType":"YulTypedName","src":"3234:6:12","type":""}]},{"expression":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3272:3:12"},{"name":"length","nodeType":"YulIdentifier","src":"3277:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3265:6:12"},"nodeType":"YulFunctionCall","src":"3265:19:12"},"nodeType":"YulExpressionStatement","src":"3265:19:12"},{"nodeType":"YulVariableDeclaration","src":"3293:14:12","value":{"kind":"number","nodeType":"YulLiteral","src":"3303:4:12","type":"","value":"0x20"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"3297:2:12","type":""}]},{"nodeType":"YulAssignment","src":"3316:19:12","value":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3327:3:12"},{"name":"_1","nodeType":"YulIdentifier","src":"3332:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3323:3:12"},"nodeType":"YulFunctionCall","src":"3323:12:12"},"variableNames":[{"name":"pos","nodeType":"YulIdentifier","src":"3316:3:12"}]},{"nodeType":"YulVariableDeclaration","src":"3344:28:12","value":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"3362:5:12"},{"name":"_1","nodeType":"YulIdentifier","src":"3369:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3358:3:12"},"nodeType":"YulFunctionCall","src":"3358:14:12"},"variables":[{"name":"srcPtr","nodeType":"YulTypedName","src":"3348:6:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"3381:10:12","value":{"kind":"number","nodeType":"YulLiteral","src":"3390:1:12","type":"","value":"0"},"variables":[{"name":"i","nodeType":"YulTypedName","src":"3385:1:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"3449:120:12","statements":[{"expression":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3470:3:12"},{"arguments":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"3481:6:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"3475:5:12"},"nodeType":"YulFunctionCall","src":"3475:13:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3463:6:12"},"nodeType":"YulFunctionCall","src":"3463:26:12"},"nodeType":"YulExpressionStatement","src":"3463:26:12"},{"nodeType":"YulAssignment","src":"3502:19:12","value":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3513:3:12"},{"name":"_1","nodeType":"YulIdentifier","src":"3518:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3509:3:12"},"nodeType":"YulFunctionCall","src":"3509:12:12"},"variableNames":[{"name":"pos","nodeType":"YulIdentifier","src":"3502:3:12"}]},{"nodeType":"YulAssignment","src":"3534:25:12","value":{"arguments":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"3548:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"3556:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3544:3:12"},"nodeType":"YulFunctionCall","src":"3544:15:12"},"variableNames":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"3534:6:12"}]}]},"condition":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"3411:1:12"},{"name":"length","nodeType":"YulIdentifier","src":"3414:6:12"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"3408:2:12"},"nodeType":"YulFunctionCall","src":"3408:13:12"},"nodeType":"YulForLoop","post":{"nodeType":"YulBlock","src":"3422:18:12","statements":[{"nodeType":"YulAssignment","src":"3424:14:12","value":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"3433:1:12"},{"kind":"number","nodeType":"YulLiteral","src":"3436:1:12","type":"","value":"1"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3429:3:12"},"nodeType":"YulFunctionCall","src":"3429:9:12"},"variableNames":[{"name":"i","nodeType":"YulIdentifier","src":"3424:1:12"}]}]},"pre":{"nodeType":"YulBlock","src":"3404:3:12","statements":[]},"src":"3400:169:12"},{"nodeType":"YulAssignment","src":"3578:10:12","value":{"name":"pos","nodeType":"YulIdentifier","src":"3585:3:12"},"variableNames":[{"name":"end","nodeType":"YulIdentifier","src":"3578:3:12"}]}]},"name":"abi_encode_array_uint256_dyn","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nodeType":"YulTypedName","src":"3197:5:12","type":""},{"name":"pos","nodeType":"YulTypedName","src":"3204:3:12","type":""}],"returnVariables":[{"name":"end","nodeType":"YulTypedName","src":"3212:3:12","type":""}],"src":"3159:435:12"},{"body":{"nodeType":"YulBlock","src":"3924:859:12","statements":[{"nodeType":"YulVariableDeclaration","src":"3934:32:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3952:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"3963:2:12","type":"","value":"96"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3948:3:12"},"nodeType":"YulFunctionCall","src":"3948:18:12"},"variables":[{"name":"tail_1","nodeType":"YulTypedName","src":"3938:6:12","type":""}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3982:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"3993:2:12","type":"","value":"96"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3975:6:12"},"nodeType":"YulFunctionCall","src":"3975:21:12"},"nodeType":"YulExpressionStatement","src":"3975:21:12"},{"nodeType":"YulVariableDeclaration","src":"4005:17:12","value":{"name":"tail_1","nodeType":"YulIdentifier","src":"4016:6:12"},"variables":[{"name":"pos","nodeType":"YulTypedName","src":"4009:3:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"4031:27:12","value":{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"4051:6:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"4045:5:12"},"nodeType":"YulFunctionCall","src":"4045:13:12"},"variables":[{"name":"length","nodeType":"YulTypedName","src":"4035:6:12","type":""}]},{"expression":{"arguments":[{"name":"tail_1","nodeType":"YulIdentifier","src":"4074:6:12"},{"name":"length","nodeType":"YulIdentifier","src":"4082:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4067:6:12"},"nodeType":"YulFunctionCall","src":"4067:22:12"},"nodeType":"YulExpressionStatement","src":"4067:22:12"},{"nodeType":"YulAssignment","src":"4098:26:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4109:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"4120:3:12","type":"","value":"128"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4105:3:12"},"nodeType":"YulFunctionCall","src":"4105:19:12"},"variableNames":[{"name":"pos","nodeType":"YulIdentifier","src":"4098:3:12"}]},{"nodeType":"YulVariableDeclaration","src":"4133:54:12","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4155:9:12"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"4170:1:12","type":"","value":"5"},{"name":"length","nodeType":"YulIdentifier","src":"4173:6:12"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"4166:3:12"},"nodeType":"YulFunctionCall","src":"4166:14:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4151:3:12"},"nodeType":"YulFunctionCall","src":"4151:30:12"},{"kind":"number","nodeType":"YulLiteral","src":"4183:3:12","type":"","value":"128"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4147:3:12"},"nodeType":"YulFunctionCall","src":"4147:40:12"},"variables":[{"name":"tail_2","nodeType":"YulTypedName","src":"4137:6:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"4196:14:12","value":{"kind":"number","nodeType":"YulLiteral","src":"4206:4:12","type":"","value":"0x20"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"4200:2:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"4219:29:12","value":{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"4237:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"4245:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4233:3:12"},"nodeType":"YulFunctionCall","src":"4233:15:12"},"variables":[{"name":"srcPtr","nodeType":"YulTypedName","src":"4223:6:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"4257:10:12","value":{"kind":"number","nodeType":"YulLiteral","src":"4266:1:12","type":"","value":"0"},"variables":[{"name":"i","nodeType":"YulTypedName","src":"4261:1:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"4325:206:12","statements":[{"expression":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"4346:3:12"},{"arguments":[{"arguments":[{"name":"tail_2","nodeType":"YulIdentifier","src":"4359:6:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"4367:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"4355:3:12"},"nodeType":"YulFunctionCall","src":"4355:22:12"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"4383:3:12","type":"","value":"127"}],"functionName":{"name":"not","nodeType":"YulIdentifier","src":"4379:3:12"},"nodeType":"YulFunctionCall","src":"4379:8:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4351:3:12"},"nodeType":"YulFunctionCall","src":"4351:37:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4339:6:12"},"nodeType":"YulFunctionCall","src":"4339:50:12"},"nodeType":"YulExpressionStatement","src":"4339:50:12"},{"nodeType":"YulAssignment","src":"4402:49:12","value":{"arguments":[{"arguments":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"4435:6:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"4429:5:12"},"nodeType":"YulFunctionCall","src":"4429:13:12"},{"name":"tail_2","nodeType":"YulIdentifier","src":"4444:6:12"}],"functionName":{"name":"abi_encode_bytes","nodeType":"YulIdentifier","src":"4412:16:12"},"nodeType":"YulFunctionCall","src":"4412:39:12"},"variableNames":[{"name":"tail_2","nodeType":"YulIdentifier","src":"4402:6:12"}]},{"nodeType":"YulAssignment","src":"4464:25:12","value":{"arguments":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"4478:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"4486:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4474:3:12"},"nodeType":"YulFunctionCall","src":"4474:15:12"},"variableNames":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"4464:6:12"}]},{"nodeType":"YulAssignment","src":"4502:19:12","value":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"4513:3:12"},{"name":"_1","nodeType":"YulIdentifier","src":"4518:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4509:3:12"},"nodeType":"YulFunctionCall","src":"4509:12:12"},"variableNames":[{"name":"pos","nodeType":"YulIdentifier","src":"4502:3:12"}]}]},"condition":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"4287:1:12"},{"name":"length","nodeType":"YulIdentifier","src":"4290:6:12"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"4284:2:12"},"nodeType":"YulFunctionCall","src":"4284:13:12"},"nodeType":"YulForLoop","post":{"nodeType":"YulBlock","src":"4298:18:12","statements":[{"nodeType":"YulAssignment","src":"4300:14:12","value":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"4309:1:12"},{"kind":"number","nodeType":"YulLiteral","src":"4312:1:12","type":"","value":"1"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4305:3:12"},"nodeType":"YulFunctionCall","src":"4305:9:12"},"variableNames":[{"name":"i","nodeType":"YulIdentifier","src":"4300:1:12"}]}]},"pre":{"nodeType":"YulBlock","src":"4280:3:12","statements":[]},"src":"4276:255:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4551:9:12"},{"name":"_1","nodeType":"YulIdentifier","src":"4562:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4547:3:12"},"nodeType":"YulFunctionCall","src":"4547:18:12"},{"arguments":[{"name":"tail_2","nodeType":"YulIdentifier","src":"4571:6:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"4579:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"4567:3:12"},"nodeType":"YulFunctionCall","src":"4567:22:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4540:6:12"},"nodeType":"YulFunctionCall","src":"4540:50:12"},"nodeType":"YulExpressionStatement","src":"4540:50:12"},{"nodeType":"YulVariableDeclaration","src":"4599:58:12","value":{"arguments":[{"name":"value1","nodeType":"YulIdentifier","src":"4642:6:12"},{"name":"tail_2","nodeType":"YulIdentifier","src":"4650:6:12"}],"functionName":{"name":"abi_encode_array_uint256_dyn","nodeType":"YulIdentifier","src":"4613:28:12"},"nodeType":"YulFunctionCall","src":"4613:44:12"},"variables":[{"name":"tail_3","nodeType":"YulTypedName","src":"4603:6:12","type":""}]},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4677:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"4688:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4673:3:12"},"nodeType":"YulFunctionCall","src":"4673:18:12"},{"arguments":[{"name":"tail_3","nodeType":"YulIdentifier","src":"4697:6:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"4705:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"4693:3:12"},"nodeType":"YulFunctionCall","src":"4693:22:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4666:6:12"},"nodeType":"YulFunctionCall","src":"4666:50:12"},"nodeType":"YulExpressionStatement","src":"4666:50:12"},{"nodeType":"YulAssignment","src":"4725:52:12","value":{"arguments":[{"name":"value2","nodeType":"YulIdentifier","src":"4762:6:12"},{"name":"tail_3","nodeType":"YulIdentifier","src":"4770:6:12"}],"functionName":{"name":"abi_encode_array_uint256_dyn","nodeType":"YulIdentifier","src":"4733:28:12"},"nodeType":"YulFunctionCall","src":"4733:44:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"4725:4:12"}]}]},"name":"abi_encode_tuple_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"3877:9:12","type":""},{"name":"value2","nodeType":"YulTypedName","src":"3888:6:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"3896:6:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"3904:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"3915:4:12","type":""}],"src":"3599:1184:12"},{"body":{"nodeType":"YulBlock","src":"4952:404:12","statements":[{"body":{"nodeType":"YulBlock","src":"4998:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"5007:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"5010:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"5000:6:12"},"nodeType":"YulFunctionCall","src":"5000:12:12"},"nodeType":"YulExpressionStatement","src":"5000:12:12"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nodeType":"YulIdentifier","src":"4973:7:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"4982:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"4969:3:12"},"nodeType":"YulFunctionCall","src":"4969:23:12"},{"kind":"number","nodeType":"YulLiteral","src":"4994:2:12","type":"","value":"96"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"4965:3:12"},"nodeType":"YulFunctionCall","src":"4965:32:12"},"nodeType":"YulIf","src":"4962:52:12"},{"nodeType":"YulVariableDeclaration","src":"5023:29:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5042:9:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"5036:5:12"},"nodeType":"YulFunctionCall","src":"5036:16:12"},"variables":[{"name":"value","nodeType":"YulTypedName","src":"5027:5:12","type":""}]},{"expression":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"5086:5:12"}],"functionName":{"name":"validator_revert_address","nodeType":"YulIdentifier","src":"5061:24:12"},"nodeType":"YulFunctionCall","src":"5061:31:12"},"nodeType":"YulExpressionStatement","src":"5061:31:12"},{"nodeType":"YulAssignment","src":"5101:15:12","value":{"name":"value","nodeType":"YulIdentifier","src":"5111:5:12"},"variableNames":[{"name":"value0","nodeType":"YulIdentifier","src":"5101:6:12"}]},{"nodeType":"YulVariableDeclaration","src":"5125:40:12","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5150:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5161:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5146:3:12"},"nodeType":"YulFunctionCall","src":"5146:18:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"5140:5:12"},"nodeType":"YulFunctionCall","src":"5140:25:12"},"variables":[{"name":"value_1","nodeType":"YulTypedName","src":"5129:7:12","type":""}]},{"expression":{"arguments":[{"name":"value_1","nodeType":"YulIdentifier","src":"5199:7:12"}],"functionName":{"name":"validator_revert_address","nodeType":"YulIdentifier","src":"5174:24:12"},"nodeType":"YulFunctionCall","src":"5174:33:12"},"nodeType":"YulExpressionStatement","src":"5174:33:12"},{"nodeType":"YulAssignment","src":"5216:17:12","value":{"name":"value_1","nodeType":"YulIdentifier","src":"5226:7:12"},"variableNames":[{"name":"value1","nodeType":"YulIdentifier","src":"5216:6:12"}]},{"nodeType":"YulVariableDeclaration","src":"5242:40:12","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5267:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5278:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5263:3:12"},"nodeType":"YulFunctionCall","src":"5263:18:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"5257:5:12"},"nodeType":"YulFunctionCall","src":"5257:25:12"},"variables":[{"name":"value_2","nodeType":"YulTypedName","src":"5246:7:12","type":""}]},{"expression":{"arguments":[{"name":"value_2","nodeType":"YulIdentifier","src":"5316:7:12"}],"functionName":{"name":"validator_revert_address","nodeType":"YulIdentifier","src":"5291:24:12"},"nodeType":"YulFunctionCall","src":"5291:33:12"},"nodeType":"YulExpressionStatement","src":"5291:33:12"},{"nodeType":"YulAssignment","src":"5333:17:12","value":{"name":"value_2","nodeType":"YulIdentifier","src":"5343:7:12"},"variableNames":[{"name":"value2","nodeType":"YulIdentifier","src":"5333:6:12"}]}]},"name":"abi_decode_tuple_t_contract$_IInterpreterV1_$373t_contract$_IInterpreterStoreV1_$323t_address_fromMemory","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"4902:9:12","type":""},{"name":"dataEnd","nodeType":"YulTypedName","src":"4913:7:12","type":""}],"returnVariables":[{"name":"value0","nodeType":"YulTypedName","src":"4925:6:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"4933:6:12","type":""},{"name":"value2","nodeType":"YulTypedName","src":"4941:6:12","type":""}],"src":"4788:568:12"},{"body":{"nodeType":"YulBlock","src":"5480:98:12","statements":[{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5497:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5508:2:12","type":"","value":"32"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5490:6:12"},"nodeType":"YulFunctionCall","src":"5490:21:12"},"nodeType":"YulExpressionStatement","src":"5490:21:12"},{"nodeType":"YulAssignment","src":"5520:52:12","value":{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"5545:6:12"},{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5557:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5568:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5553:3:12"},"nodeType":"YulFunctionCall","src":"5553:18:12"}],"functionName":{"name":"abi_encode_bytes","nodeType":"YulIdentifier","src":"5528:16:12"},"nodeType":"YulFunctionCall","src":"5528:44:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"5520:4:12"}]}]},"name":"abi_encode_tuple_t_bytes_memory_ptr__to_t_bytes_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"5449:9:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"5460:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"5471:4:12","type":""}],"src":"5361:217:12"}]},"contents":"{\n    { }\n    function panic_error_0x41()\n    {\n        mstore(0, shl(224, 0x4e487b71))\n        mstore(4, 0x41)\n        revert(0, 0x24)\n    }\n    function allocate_memory_945() -> memPtr\n    {\n        memPtr := mload(0x40)\n        let newFreePtr := add(memPtr, 0x40)\n        if or(gt(newFreePtr, sub(shl(64, 1), 1)), lt(newFreePtr, memPtr)) { panic_error_0x41() }\n        mstore(0x40, newFreePtr)\n    }\n    function allocate_memory(size) -> memPtr\n    {\n        memPtr := mload(64)\n        let newFreePtr := add(memPtr, and(add(size, 31), not(31)))\n        if or(gt(newFreePtr, sub(shl(64, 1), 1)), lt(newFreePtr, memPtr)) { panic_error_0x41() }\n        mstore(64, newFreePtr)\n    }\n    function validator_revert_address(value)\n    {\n        if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { revert(0, 0) }\n    }\n    function copy_memory_to_memory_with_cleanup(src, dst, length)\n    {\n        let i := 0\n        for { } lt(i, length) { i := add(i, 32) }\n        {\n            mstore(add(dst, i), mload(add(src, i)))\n        }\n        mstore(add(dst, length), 0)\n    }\n    function abi_decode_tuple_t_struct$_DeployerDiscoverableMetaV1ConstructionConfig_$202_memory_ptr_fromMemory(headStart, dataEnd) -> value0\n    {\n        let _1 := 32\n        if slt(sub(dataEnd, headStart), _1) { revert(0, 0) }\n        let offset := mload(headStart)\n        let _2 := sub(shl(64, 1), 1)\n        if gt(offset, _2) { revert(0, 0) }\n        let _3 := add(headStart, offset)\n        if slt(sub(dataEnd, _3), 0x40) { revert(0, 0) }\n        let value := allocate_memory_945()\n        let value_1 := mload(_3)\n        validator_revert_address(value_1)\n        mstore(value, value_1)\n        let offset_1 := mload(add(_3, _1))\n        if gt(offset_1, _2) { revert(0, 0) }\n        let _4 := add(_3, offset_1)\n        if iszero(slt(add(_4, 0x1f), dataEnd)) { revert(0, 0) }\n        let _5 := mload(_4)\n        if gt(_5, _2) { panic_error_0x41() }\n        let array := allocate_memory(add(and(add(_5, 0x1f), not(31)), _1))\n        mstore(array, _5)\n        if gt(add(add(_4, _5), _1), dataEnd) { revert(0, 0) }\n        copy_memory_to_memory_with_cleanup(add(_4, _1), add(array, _1), _5)\n        mstore(add(value, _1), array)\n        value0 := value\n    }\n    function abi_encode_bytes(value, pos) -> end\n    {\n        let length := mload(value)\n        mstore(pos, length)\n        copy_memory_to_memory_with_cleanup(add(value, 0x20), add(pos, 0x20), length)\n        end := add(add(pos, and(add(length, 31), not(31))), 0x20)\n    }\n    function abi_encode_tuple_t_address_t_uint256_t_bytes_memory_ptr__to_t_address_t_uint256_t_bytes_memory_ptr__fromStack_reversed(headStart, value2, value1, value0) -> tail\n    {\n        mstore(headStart, and(value0, sub(shl(160, 1), 1)))\n        mstore(add(headStart, 32), value1)\n        mstore(add(headStart, 64), 96)\n        tail := abi_encode_bytes(value2, add(headStart, 96))\n    }\n    function abi_encode_tuple_t_bytes32_t_bytes32__to_t_bytes32_t_bytes32__fromStack_reversed(headStart, value1, value0) -> tail\n    {\n        tail := add(headStart, 64)\n        mstore(headStart, value0)\n        mstore(add(headStart, 32), value1)\n    }\n    function abi_encode_array_uint256_dyn(value, pos) -> end\n    {\n        let length := mload(value)\n        mstore(pos, length)\n        let _1 := 0x20\n        pos := add(pos, _1)\n        let srcPtr := add(value, _1)\n        let i := 0\n        for { } lt(i, length) { i := add(i, 1) }\n        {\n            mstore(pos, mload(srcPtr))\n            pos := add(pos, _1)\n            srcPtr := add(srcPtr, _1)\n        }\n        end := pos\n    }\n    function abi_encode_tuple_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__fromStack_reversed(headStart, value2, value1, value0) -> tail\n    {\n        let tail_1 := add(headStart, 96)\n        mstore(headStart, 96)\n        let pos := tail_1\n        let length := mload(value0)\n        mstore(tail_1, length)\n        pos := add(headStart, 128)\n        let tail_2 := add(add(headStart, shl(5, length)), 128)\n        let _1 := 0x20\n        let srcPtr := add(value0, _1)\n        let i := 0\n        for { } lt(i, length) { i := add(i, 1) }\n        {\n            mstore(pos, add(sub(tail_2, headStart), not(127)))\n            tail_2 := abi_encode_bytes(mload(srcPtr), tail_2)\n            srcPtr := add(srcPtr, _1)\n            pos := add(pos, _1)\n        }\n        mstore(add(headStart, _1), sub(tail_2, headStart))\n        let tail_3 := abi_encode_array_uint256_dyn(value1, tail_2)\n        mstore(add(headStart, 64), sub(tail_3, headStart))\n        tail := abi_encode_array_uint256_dyn(value2, tail_3)\n    }\n    function abi_decode_tuple_t_contract$_IInterpreterV1_$373t_contract$_IInterpreterStoreV1_$323t_address_fromMemory(headStart, dataEnd) -> value0, value1, value2\n    {\n        if slt(sub(dataEnd, headStart), 96) { revert(0, 0) }\n        let value := mload(headStart)\n        validator_revert_address(value)\n        value0 := value\n        let value_1 := mload(add(headStart, 32))\n        validator_revert_address(value_1)\n        value1 := value_1\n        let value_2 := mload(add(headStart, 64))\n        validator_revert_address(value_2)\n        value2 := value_2\n    }\n    function abi_encode_tuple_t_bytes_memory_ptr__to_t_bytes_memory_ptr__fromStack_reversed(headStart, value0) -> tail\n    {\n        mstore(headStart, 32)\n        tail := abi_encode_bytes(value0, add(headStart, 32))\n    }\n}","id":12,"language":"Yul","name":"#utility.yul"}],"linkReferences":{},"object":"60806040523480156200001157600080fd5b5060405162000c5e38038062000c5e8339810160408190526200003491620002fa565b7fae0fb5b68fe1791c72509bf46ea6abf6a982d21451265be0a017f7959712a67e60001b8162000074828260200151620000d860201b620001af1760201c565b60208101516040517fbea766d03fa1efd3f81cc8634d08320bc62bb0ed9234ac59bbaafa5893fb6b1391620000ad913391309162000408565b60405180910390a1620000cf81600001516200011f60201b6200020c1760201c565b5050506200057a565b805160208201208281146200010f5760405163074fe10f60e41b815260048101849052602481018290526044015b60405180910390fd5b6200011a82620001ea565b505050565b60408051600080825260208201909252819081906001600160a01b03851690635511cb67908362000161565b60608152602001906001900390816200014b5790505b5060408051600080825260208201908152818301928390526001600160e01b031960e086901b169092526200019b92916044820162000477565b6060604051808303816000875af1158015620001bb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001e191906200050a565b50505050505050565b620001f5816200021a565b620002175780604051630c89984b60e31b81526004016200010691906200055e565b50565b60006008825110156200022f57506000919050565b50600801516001600160401b031667ff0a89c674ee78741490565b634e487b7160e01b600052604160045260246000fd5b604080519081016001600160401b03811182821017156200028557620002856200024a565b60405290565b604051601f8201601f191681016001600160401b0381118282101715620002b657620002b66200024a565b604052919050565b6001600160a01b03811681146200021757600080fd5b60005b83811015620002f1578181015183820152602001620002d7565b50506000910152565b600060208083850312156200030e57600080fd5b82516001600160401b03808211156200032657600080fd5b90840190604082870312156200033b57600080fd5b6200034562000260565b82516200035281620002be565b815282840151828111156200036657600080fd5b80840193505086601f8401126200037c57600080fd5b8251828111156200039157620003916200024a565b620003a5601f8201601f191686016200028b565b92508083528785828601011115620003bc57600080fd5b620003cd81868501878701620002d4565b5092830152509392505050565b60008151808452620003f4816020860160208601620002d4565b601f01601f19169290920160200192915050565b60018060a01b0384168152826020820152606060408201526000620004316060830184620003da565b95945050505050565b600081518084526020808501945080840160005b838110156200046c578151875295820195908201906001016200044e565b509495945050505050565b6000606082016060835280865180835260808501915060808160051b8601019250602080890160005b83811015620004d257607f19888703018552620004bf868351620003da565b95509382019390820190600101620004a0565b505085840381870152505050620004ea81866200043a565b905082810360408401526200050081856200043a565b9695505050505050565b6000806000606084860312156200052057600080fd5b83516200052d81620002be565b60208501519093506200054081620002be565b60408501519092506200055381620002be565b809150509250925092565b602081526000620005736020830184620003da565b9392505050565b6106d4806200058a6000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80630fbe133c14610030575b600080fd5b61004361003e366004610453565b61006c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b600073ffffffffffffffffffffffffffffffffffffffff84166100bb576040517f4208d2eb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006100c6856102f5565b6040805133815273ffffffffffffffffffffffffffffffffffffffff888116602083015283168183015290519192507f274b5f356634f32a865af65bdc3d8205939d9413d75e1f367652e4f3b24d0c3a919081900360600190a16040517f439fab9100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82169063439fab919061017490879087906004016104d8565b600060405180830381600087803b15801561018e57600080fd5b505af11580156101a2573d6000803e3d6000fd5b5092979650505050505050565b805160208201208281146101fe576040517f74fe10f000000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044015b60405180910390fd5b610207826103bd565b505050565b604080516000808252602082019092528190819073ffffffffffffffffffffffffffffffffffffffff851690635511cb679083610259565b60608152602001906001900390816102445790505b5060408051600080825260208201908152818301928390527fffffffff0000000000000000000000000000000000000000000000000000000060e086901b169092526102a99291604482016105c4565b6060604051808303816000875af11580156102c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ec919061066d565b50505050505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f0905073ffffffffffffffffffffffffffffffffffffffff81166103b8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c65640000000000000000000060448201526064016101f5565b919050565b6103c681610401565b6103fe57806040517f644cc2580000000000000000000000000000000000000000000000000000000081526004016101f591906106ba565b50565b600060088251101561041557506000919050565b506008015167ffffffffffffffff1667ff0a89c674ee78741490565b73ffffffffffffffffffffffffffffffffffffffff811681146103fe57600080fd5b60008060006040848603121561046857600080fd5b833561047381610431565b9250602084013567ffffffffffffffff8082111561049057600080fd5b818601915086601f8301126104a457600080fd5b8135818111156104b357600080fd5b8760208285010111156104c557600080fd5b6020830194508093505050509250925092565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b6000815180845260005b8181101561054b5760208185018101518683018201520161052f565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600081518084526020808501945080840160005b838110156105b95781518752958201959082019060010161059d565b509495945050505050565b6000606082016060835280865180835260808501915060808160051b8601019250602080890160005b83811015610639577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80888703018552610627868351610525565b955093820193908201906001016105ed565b50508584038187015250505061064f8186610589565b905082810360408401526106638185610589565b9695505050505050565b60008060006060848603121561068257600080fd5b835161068d81610431565b602085015190935061069e81610431565b60408501519092506106af81610431565b809150509250925092565b6020815260006106cd6020830184610525565b939250505056","opcodes":"PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH3 0x11 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH3 0xC5E CODESIZE SUB DUP1 PUSH3 0xC5E DUP4 CODECOPY DUP2 ADD PUSH1 0x40 DUP2 SWAP1 MSTORE PUSH3 0x34 SWAP2 PUSH3 0x2FA JUMP JUMPDEST PUSH32 0xAE0FB5B68FE1791C72509BF46EA6ABF6A982D21451265BE0A017F7959712A67E PUSH1 0x0 SHL DUP2 PUSH3 0x74 DUP3 DUP3 PUSH1 0x20 ADD MLOAD PUSH3 0xD8 PUSH1 0x20 SHL PUSH3 0x1AF OR PUSH1 0x20 SHR JUMP JUMPDEST PUSH1 0x20 DUP2 ADD MLOAD PUSH1 0x40 MLOAD PUSH32 0xBEA766D03FA1EFD3F81CC8634D08320BC62BB0ED9234AC59BBAAFA5893FB6B13 SWAP2 PUSH3 0xAD SWAP2 CALLER SWAP2 ADDRESS SWAP2 PUSH3 0x408 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG1 PUSH3 0xCF DUP2 PUSH1 0x0 ADD MLOAD PUSH3 0x11F PUSH1 0x20 SHL PUSH3 0x20C OR PUSH1 0x20 SHR JUMP JUMPDEST POP POP POP PUSH3 0x57A JUMP JUMPDEST DUP1 MLOAD PUSH1 0x20 DUP3 ADD KECCAK256 DUP3 DUP2 EQ PUSH3 0x10F JUMPI PUSH1 0x40 MLOAD PUSH4 0x74FE10F PUSH1 0xE4 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD DUP5 SWAP1 MSTORE PUSH1 0x24 DUP2 ADD DUP3 SWAP1 MSTORE PUSH1 0x44 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH3 0x11A DUP3 PUSH3 0x1EA JUMP JUMPDEST POP POP POP JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD SWAP1 SWAP3 MSTORE DUP2 SWAP1 DUP2 SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP6 AND SWAP1 PUSH4 0x5511CB67 SWAP1 DUP4 PUSH3 0x161 JUMP JUMPDEST PUSH1 0x60 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 PUSH1 0x1 SWAP1 SUB SWAP1 DUP2 PUSH3 0x14B JUMPI SWAP1 POP JUMPDEST POP PUSH1 0x40 DUP1 MLOAD PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD SWAP1 DUP2 MSTORE DUP2 DUP4 ADD SWAP3 DUP4 SWAP1 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT PUSH1 0xE0 DUP7 SWAP1 SHL AND SWAP1 SWAP3 MSTORE PUSH3 0x19B SWAP3 SWAP2 PUSH1 0x44 DUP3 ADD PUSH3 0x477 JUMP JUMPDEST PUSH1 0x60 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 GAS CALL ISZERO DUP1 ISZERO PUSH3 0x1BB JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH3 0x1E1 SWAP2 SWAP1 PUSH3 0x50A JUMP JUMPDEST POP POP POP POP POP POP POP JUMP JUMPDEST PUSH3 0x1F5 DUP2 PUSH3 0x21A JUMP JUMPDEST PUSH3 0x217 JUMPI DUP1 PUSH1 0x40 MLOAD PUSH4 0xC89984B PUSH1 0xE3 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH3 0x106 SWAP2 SWAP1 PUSH3 0x55E JUMP JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x8 DUP3 MLOAD LT ISZERO PUSH3 0x22F JUMPI POP PUSH1 0x0 SWAP2 SWAP1 POP JUMP JUMPDEST POP PUSH1 0x8 ADD MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB AND PUSH8 0xFF0A89C674EE7874 EQ SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x40 DUP1 MLOAD SWAP1 DUP2 ADD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT DUP3 DUP3 LT OR ISZERO PUSH3 0x285 JUMPI PUSH3 0x285 PUSH3 0x24A JUMP JUMPDEST PUSH1 0x40 MSTORE SWAP1 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1F DUP3 ADD PUSH1 0x1F NOT AND DUP2 ADD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP2 GT DUP3 DUP3 LT OR ISZERO PUSH3 0x2B6 JUMPI PUSH3 0x2B6 PUSH3 0x24A JUMP JUMPDEST PUSH1 0x40 MSTORE SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH3 0x217 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH3 0x2F1 JUMPI DUP2 DUP2 ADD MLOAD DUP4 DUP3 ADD MSTORE PUSH1 0x20 ADD PUSH3 0x2D7 JUMP JUMPDEST POP POP PUSH1 0x0 SWAP2 ADD MSTORE JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP1 DUP4 DUP6 SUB SLT ISZERO PUSH3 0x30E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0x40 SHL SUB DUP1 DUP3 GT ISZERO PUSH3 0x326 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP1 DUP5 ADD SWAP1 PUSH1 0x40 DUP3 DUP8 SUB SLT ISZERO PUSH3 0x33B JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH3 0x345 PUSH3 0x260 JUMP JUMPDEST DUP3 MLOAD PUSH3 0x352 DUP2 PUSH3 0x2BE JUMP JUMPDEST DUP2 MSTORE DUP3 DUP5 ADD MLOAD DUP3 DUP2 GT ISZERO PUSH3 0x366 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 DUP5 ADD SWAP4 POP POP DUP7 PUSH1 0x1F DUP5 ADD SLT PUSH3 0x37C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 MLOAD DUP3 DUP2 GT ISZERO PUSH3 0x391 JUMPI PUSH3 0x391 PUSH3 0x24A JUMP JUMPDEST PUSH3 0x3A5 PUSH1 0x1F DUP3 ADD PUSH1 0x1F NOT AND DUP7 ADD PUSH3 0x28B JUMP JUMPDEST SWAP3 POP DUP1 DUP4 MSTORE DUP8 DUP6 DUP3 DUP7 ADD ADD GT ISZERO PUSH3 0x3BC JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH3 0x3CD DUP2 DUP7 DUP6 ADD DUP8 DUP8 ADD PUSH3 0x2D4 JUMP JUMPDEST POP SWAP3 DUP4 ADD MSTORE POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD DUP1 DUP5 MSTORE PUSH3 0x3F4 DUP2 PUSH1 0x20 DUP7 ADD PUSH1 0x20 DUP7 ADD PUSH3 0x2D4 JUMP JUMPDEST PUSH1 0x1F ADD PUSH1 0x1F NOT AND SWAP3 SWAP1 SWAP3 ADD PUSH1 0x20 ADD SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x1 DUP1 PUSH1 0xA0 SHL SUB DUP5 AND DUP2 MSTORE DUP3 PUSH1 0x20 DUP3 ADD MSTORE PUSH1 0x60 PUSH1 0x40 DUP3 ADD MSTORE PUSH1 0x0 PUSH3 0x431 PUSH1 0x60 DUP4 ADD DUP5 PUSH3 0x3DA JUMP JUMPDEST SWAP6 SWAP5 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD DUP1 DUP5 MSTORE PUSH1 0x20 DUP1 DUP6 ADD SWAP5 POP DUP1 DUP5 ADD PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH3 0x46C JUMPI DUP2 MLOAD DUP8 MSTORE SWAP6 DUP3 ADD SWAP6 SWAP1 DUP3 ADD SWAP1 PUSH1 0x1 ADD PUSH3 0x44E JUMP JUMPDEST POP SWAP5 SWAP6 SWAP5 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x60 DUP3 ADD PUSH1 0x60 DUP4 MSTORE DUP1 DUP7 MLOAD DUP1 DUP4 MSTORE PUSH1 0x80 DUP6 ADD SWAP2 POP PUSH1 0x80 DUP2 PUSH1 0x5 SHL DUP7 ADD ADD SWAP3 POP PUSH1 0x20 DUP1 DUP10 ADD PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH3 0x4D2 JUMPI PUSH1 0x7F NOT DUP9 DUP8 SUB ADD DUP6 MSTORE PUSH3 0x4BF DUP7 DUP4 MLOAD PUSH3 0x3DA JUMP JUMPDEST SWAP6 POP SWAP4 DUP3 ADD SWAP4 SWAP1 DUP3 ADD SWAP1 PUSH1 0x1 ADD PUSH3 0x4A0 JUMP JUMPDEST POP POP DUP6 DUP5 SUB DUP2 DUP8 ADD MSTORE POP POP POP PUSH3 0x4EA DUP2 DUP7 PUSH3 0x43A JUMP JUMPDEST SWAP1 POP DUP3 DUP2 SUB PUSH1 0x40 DUP5 ADD MSTORE PUSH3 0x500 DUP2 DUP6 PUSH3 0x43A JUMP JUMPDEST SWAP7 SWAP6 POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH3 0x520 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 MLOAD PUSH3 0x52D DUP2 PUSH3 0x2BE JUMP JUMPDEST PUSH1 0x20 DUP6 ADD MLOAD SWAP1 SWAP4 POP PUSH3 0x540 DUP2 PUSH3 0x2BE JUMP JUMPDEST PUSH1 0x40 DUP6 ADD MLOAD SWAP1 SWAP3 POP PUSH3 0x553 DUP2 PUSH3 0x2BE JUMP JUMPDEST DUP1 SWAP2 POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x20 DUP2 MSTORE PUSH1 0x0 PUSH3 0x573 PUSH1 0x20 DUP4 ADD DUP5 PUSH3 0x3DA JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH2 0x6D4 DUP1 PUSH3 0x58A PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x2B JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0xFBE133C EQ PUSH2 0x30 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x43 PUSH2 0x3E CALLDATASIZE PUSH1 0x4 PUSH2 0x453 JUMP JUMPDEST PUSH2 0x6C JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x0 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP5 AND PUSH2 0xBB JUMPI PUSH1 0x40 MLOAD PUSH32 0x4208D2EB00000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0xC6 DUP6 PUSH2 0x2F5 JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD CALLER DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP9 DUP2 AND PUSH1 0x20 DUP4 ADD MSTORE DUP4 AND DUP2 DUP4 ADD MSTORE SWAP1 MLOAD SWAP2 SWAP3 POP PUSH32 0x274B5F356634F32A865AF65BDC3D8205939D9413D75E1F367652E4F3B24D0C3A SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x60 ADD SWAP1 LOG1 PUSH1 0x40 MLOAD PUSH32 0x439FAB9100000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP3 AND SWAP1 PUSH4 0x439FAB91 SWAP1 PUSH2 0x174 SWAP1 DUP8 SWAP1 DUP8 SWAP1 PUSH1 0x4 ADD PUSH2 0x4D8 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x18E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x1A2 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP SWAP3 SWAP8 SWAP7 POP POP POP POP POP POP POP JUMP JUMPDEST DUP1 MLOAD PUSH1 0x20 DUP3 ADD KECCAK256 DUP3 DUP2 EQ PUSH2 0x1FE JUMPI PUSH1 0x40 MLOAD PUSH32 0x74FE10F000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 DUP2 ADD DUP5 SWAP1 MSTORE PUSH1 0x24 DUP2 ADD DUP3 SWAP1 MSTORE PUSH1 0x44 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x207 DUP3 PUSH2 0x3BD JUMP JUMPDEST POP POP POP JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD SWAP1 SWAP3 MSTORE DUP2 SWAP1 DUP2 SWAP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP6 AND SWAP1 PUSH4 0x5511CB67 SWAP1 DUP4 PUSH2 0x259 JUMP JUMPDEST PUSH1 0x60 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 PUSH1 0x1 SWAP1 SUB SWAP1 DUP2 PUSH2 0x244 JUMPI SWAP1 POP JUMPDEST POP PUSH1 0x40 DUP1 MLOAD PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD SWAP1 DUP2 MSTORE DUP2 DUP4 ADD SWAP3 DUP4 SWAP1 MSTORE PUSH32 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000 PUSH1 0xE0 DUP7 SWAP1 SHL AND SWAP1 SWAP3 MSTORE PUSH2 0x2A9 SWAP3 SWAP2 PUSH1 0x44 DUP3 ADD PUSH2 0x5C4 JUMP JUMPDEST PUSH1 0x60 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 GAS CALL ISZERO DUP1 ISZERO PUSH2 0x2C8 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x2EC SWAP2 SWAP1 PUSH2 0x66D JUMP JUMPDEST POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH23 0x3D602D80600A3D3981F3363D3D373D3D3D363D73000000 DUP3 PUSH1 0x60 SHL PUSH1 0xE8 SHR OR PUSH1 0x0 MSTORE PUSH15 0x5AF43D82803E903D91602B57FD5BF3 DUP3 PUSH1 0x78 SHL OR PUSH1 0x20 MSTORE PUSH1 0x37 PUSH1 0x9 PUSH1 0x0 CREATE SWAP1 POP PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 AND PUSH2 0x3B8 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x16 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x455243313136373A20637265617465206661696C656400000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x1F5 JUMP JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0x3C6 DUP2 PUSH2 0x401 JUMP JUMPDEST PUSH2 0x3FE JUMPI DUP1 PUSH1 0x40 MLOAD PUSH32 0x644CC25800000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x1F5 SWAP2 SWAP1 PUSH2 0x6BA JUMP JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x8 DUP3 MLOAD LT ISZERO PUSH2 0x415 JUMPI POP PUSH1 0x0 SWAP2 SWAP1 POP JUMP JUMPDEST POP PUSH1 0x8 ADD MLOAD PUSH8 0xFFFFFFFFFFFFFFFF AND PUSH8 0xFF0A89C674EE7874 EQ SWAP1 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 AND DUP2 EQ PUSH2 0x3FE JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x40 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x468 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 CALLDATALOAD PUSH2 0x473 DUP2 PUSH2 0x431 JUMP JUMPDEST SWAP3 POP PUSH1 0x20 DUP5 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0x490 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 DUP7 ADD SWAP2 POP DUP7 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x4A4 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD DUP2 DUP2 GT ISZERO PUSH2 0x4B3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP8 PUSH1 0x20 DUP3 DUP6 ADD ADD GT ISZERO PUSH2 0x4C5 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x20 DUP4 ADD SWAP5 POP DUP1 SWAP4 POP POP POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x20 DUP2 MSTORE DUP2 PUSH1 0x20 DUP3 ADD MSTORE DUP2 DUP4 PUSH1 0x40 DUP4 ADD CALLDATACOPY PUSH1 0x0 DUP2 DUP4 ADD PUSH1 0x40 SWAP1 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH1 0x1F SWAP1 SWAP3 ADD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 AND ADD ADD SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD DUP1 DUP5 MSTORE PUSH1 0x0 JUMPDEST DUP2 DUP2 LT ISZERO PUSH2 0x54B JUMPI PUSH1 0x20 DUP2 DUP6 ADD DUP2 ADD MLOAD DUP7 DUP4 ADD DUP3 ADD MSTORE ADD PUSH2 0x52F JUMP JUMPDEST POP PUSH1 0x0 PUSH1 0x20 DUP3 DUP7 ADD ADD MSTORE PUSH1 0x20 PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 PUSH1 0x1F DUP4 ADD AND DUP6 ADD ADD SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD DUP1 DUP5 MSTORE PUSH1 0x20 DUP1 DUP6 ADD SWAP5 POP DUP1 DUP5 ADD PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x5B9 JUMPI DUP2 MLOAD DUP8 MSTORE SWAP6 DUP3 ADD SWAP6 SWAP1 DUP3 ADD SWAP1 PUSH1 0x1 ADD PUSH2 0x59D JUMP JUMPDEST POP SWAP5 SWAP6 SWAP5 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x60 DUP3 ADD PUSH1 0x60 DUP4 MSTORE DUP1 DUP7 MLOAD DUP1 DUP4 MSTORE PUSH1 0x80 DUP6 ADD SWAP2 POP PUSH1 0x80 DUP2 PUSH1 0x5 SHL DUP7 ADD ADD SWAP3 POP PUSH1 0x20 DUP1 DUP10 ADD PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x639 JUMPI PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80 DUP9 DUP8 SUB ADD DUP6 MSTORE PUSH2 0x627 DUP7 DUP4 MLOAD PUSH2 0x525 JUMP JUMPDEST SWAP6 POP SWAP4 DUP3 ADD SWAP4 SWAP1 DUP3 ADD SWAP1 PUSH1 0x1 ADD PUSH2 0x5ED JUMP JUMPDEST POP POP DUP6 DUP5 SUB DUP2 DUP8 ADD MSTORE POP POP POP PUSH2 0x64F DUP2 DUP7 PUSH2 0x589 JUMP JUMPDEST SWAP1 POP DUP3 DUP2 SUB PUSH1 0x40 DUP5 ADD MSTORE PUSH2 0x663 DUP2 DUP6 PUSH2 0x589 JUMP JUMPDEST SWAP7 SWAP6 POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x682 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 MLOAD PUSH2 0x68D DUP2 PUSH2 0x431 JUMP JUMPDEST PUSH1 0x20 DUP6 ADD MLOAD SWAP1 SWAP4 POP PUSH2 0x69E DUP2 PUSH2 0x431 JUMP JUMPDEST PUSH1 0x40 DUP6 ADD MLOAD SWAP1 SWAP3 POP PUSH2 0x6AF DUP2 PUSH2 0x431 JUMP JUMPDEST DUP1 SWAP2 POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x20 DUP2 MSTORE PUSH1 0x0 PUSH2 0x6CD PUSH1 0x20 DUP4 ADD DUP5 PUSH2 0x525 JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP ","sourceMap":"518:654:2:-:0;;;597:148;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;448:66;440:75;;730:7;1068:46:5;1092:8;1102:6;:11;;;1068:23;;;;;:46;;:::i;:::-;1181:11;;;;1129:64;;;;;;1136:10;;1172:4;;1129:64;:::i;:::-;;;;;;;;1203:54;1241:6;:15;;;1203:37;;;;;:54;;:::i;:::-;968:296;;597:148:2;518:654;;1424:292:11;1538:16;;;;;;1568:28;;;1564:112;;1619:46;;-1:-1:-1;;;1619:46:11;;;;;3080:25:12;;;3121:18;;;3114:34;;;3053:18;;1619:46:11;;;;;;;;1564:112;1685:24;1703:5;1685:17;:24::i;:::-;1506:210;1424:292;;:::o;917:319:9:-;1116:14;;;978:26;1116:14;;;;;;;;;978:26;;;;-1:-1:-1;;;;;1067:48:9;;;;;978:26;1116:14;;;;;;;;;;;;;;;;;;;-1:-1:-1;1132:16:9;;;1146:1;1132:16;;;;;;1150;;;;;;;;;;-1:-1:-1;;;;;;1067:100:9;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;;;917:319:9:o;1075:155:11:-;1151:19;1164:5;1151:12;:19::i;:::-;1146:78;;1207:5;1193:20;;-1:-1:-1;;;1193:20:11;;;;;;;;:::i;1146:78::-;1075:155;:::o;550:376::-;615:4;650:1;635:5;:12;:16;631:34;;;-1:-1:-1;660:5:11;;550:376;-1:-1:-1;550:376:11:o;631:34::-;-1:-1:-1;846:1:11;835:13;829:20;-1:-1:-1;;;;;825:32:11;667:18:10;883:36:11;;550:376::o;14:127:12:-;75:10;70:3;66:20;63:1;56:31;106:4;103:1;96:15;130:4;127:1;120:15;146:256;217:4;211:11;;;249:17;;-1:-1:-1;;;;;281:34:12;;317:22;;;278:62;275:88;;;343:18;;:::i;:::-;379:4;372:24;146:256;:::o;407:275::-;478:2;472:9;543:2;524:13;;-1:-1:-1;;520:27:12;508:40;;-1:-1:-1;;;;;563:34:12;;599:22;;;560:62;557:88;;;625:18;;:::i;:::-;661:2;654:22;407:275;;-1:-1:-1;407:275:12:o;687:131::-;-1:-1:-1;;;;;762:31:12;;752:42;;742:70;;808:1;805;798:12;823:250;908:1;918:113;932:6;929:1;926:13;918:113;;;1008:11;;;1002:18;989:11;;;982:39;954:2;947:10;918:113;;;-1:-1:-1;;1065:1:12;1047:16;;1040:27;823:250::o;1078:1158::-;1209:6;1240:2;1283;1271:9;1262:7;1258:23;1254:32;1251:52;;;1299:1;1296;1289:12;1251:52;1326:16;;-1:-1:-1;;;;;1391:14:12;;;1388:34;;;1418:1;1415;1408:12;1388:34;1441:22;;;;1497:4;1479:16;;;1475:27;1472:47;;;1515:1;1512;1505:12;1472:47;1541:21;;:::i;:::-;1592:2;1586:9;1604:33;1629:7;1604:33;:::i;:::-;1646:22;;1699:11;;;1693:18;1723:16;;;1720:36;;;1752:1;1749;1742:12;1720:36;1783:8;1779:2;1775:17;1765:27;;;1830:7;1823:4;1819:2;1815:13;1811:27;1801:55;;1852:1;1849;1842:12;1801:55;1881:2;1875:9;1903:2;1899;1896:10;1893:36;;;1909:18;;:::i;:::-;1951:53;1994:2;1975:13;;-1:-1:-1;;1971:27:12;1967:36;;1951:53;:::i;:::-;1938:66;;2027:2;2020:5;2013:17;2067:7;2062:2;2057;2053;2049:11;2045:20;2042:33;2039:53;;;2088:1;2085;2078:12;2039:53;2101:67;2165:2;2160;2153:5;2149:14;2144:2;2140;2136:11;2101:67;:::i;:::-;-1:-1:-1;2184:14:12;;;2177:29;-1:-1:-1;2188:5:12;1078:1158;-1:-1:-1;;;1078:1158:12:o;2241:270::-;2282:3;2320:5;2314:12;2347:6;2342:3;2335:19;2363:76;2432:6;2425:4;2420:3;2416:14;2409:4;2402:5;2398:16;2363:76;:::i;:::-;2493:2;2472:15;-1:-1:-1;;2468:29:12;2459:39;;;;2500:4;2455:50;;2241:270;-1:-1:-1;;2241:270:12:o;2516:385::-;2748:1;2744;2739:3;2735:11;2731:19;2723:6;2719:32;2708:9;2701:51;2788:6;2783:2;2772:9;2768:18;2761:34;2831:2;2826;2815:9;2811:18;2804:30;2682:4;2851:44;2891:2;2880:9;2876:18;2868:6;2851:44;:::i;:::-;2843:52;2516:385;-1:-1:-1;;;;;2516:385:12:o;3159:435::-;3212:3;3250:5;3244:12;3277:6;3272:3;3265:19;3303:4;3332:2;3327:3;3323:12;3316:19;;3369:2;3362:5;3358:14;3390:1;3400:169;3414:6;3411:1;3408:13;3400:169;;;3475:13;;3463:26;;3509:12;;;;3544:15;;;;3436:1;3429:9;3400:169;;;-1:-1:-1;3585:3:12;;3159:435;-1:-1:-1;;;;;3159:435:12:o;3599:1184::-;3915:4;3963:2;3952:9;3948:18;3993:2;3982:9;3975:21;4016:6;4051;4045:13;4082:6;4074;4067:22;4120:3;4109:9;4105:19;4098:26;;4183:3;4173:6;4170:1;4166:14;4155:9;4151:30;4147:40;4133:54;;4206:4;4245:2;4237:6;4233:15;4266:1;4276:255;4290:6;4287:1;4284:13;4276:255;;;4383:3;4379:8;4367:9;4359:6;4355:22;4351:37;4346:3;4339:50;4412:39;4444:6;4435;4429:13;4412:39;:::i;:::-;4402:49;-1:-1:-1;4509:12:12;;;;4474:15;;;;4312:1;4305:9;4276:255;;;4280:3;;4579:9;4571:6;4567:22;4562:2;4551:9;4547:18;4540:50;;;;4613:44;4650:6;4642;4613:44;:::i;:::-;4599:58;;4705:9;4697:6;4693:22;4688:2;4677:9;4673:18;4666:50;4733:44;4770:6;4762;4733:44;:::i;:::-;4725:52;3599:1184;-1:-1:-1;;;;;;3599:1184:12:o;4788:568::-;4925:6;4933;4941;4994:2;4982:9;4973:7;4969:23;4965:32;4962:52;;;5010:1;5007;5000:12;4962:52;5042:9;5036:16;5061:31;5086:5;5061:31;:::i;:::-;5161:2;5146:18;;5140:25;5111:5;;-1:-1:-1;5174:33:12;5140:25;5174:33;:::i;:::-;5278:2;5263:18;;5257:25;5226:7;;-1:-1:-1;5291:33:12;5257:25;5291:33;:::i;:::-;5343:7;5333:17;;;4788:568;;;;;:::o;5361:217::-;5508:2;5497:9;5490:21;5471:4;5528:44;5568:2;5557:9;5553:18;5545:6;5528:44;:::i;:::-;5520:52;5361:217;-1:-1:-1;;;5361:217:12:o;:::-;518:654:2;;;;;;"},"deployedBytecode":{"functionDebugData":{"@checkMetaHashed_534":{"entryPoint":431,"id":534,"parameterSlots":2,"returnSlots":0},"@checkMetaUnhashed_505":{"entryPoint":957,"id":505,"parameterSlots":1,"returnSlots":0},"@clone_158":{"entryPoint":108,"id":158,"parameterSlots":3,"returnSlots":1},"@clone_25":{"entryPoint":757,"id":25,"parameterSlots":1,"returnSlots":1},"@isRainMetaV1_488":{"entryPoint":1025,"id":488,"parameterSlots":1,"returnSlots":1},"@touchDeployer_421":{"entryPoint":524,"id":421,"parameterSlots":1,"returnSlots":0},"abi_decode_tuple_t_addresst_bytes_calldata_ptr":{"entryPoint":1107,"id":null,"parameterSlots":2,"returnSlots":3},"abi_decode_tuple_t_contract$_IInterpreterV1_$373t_contract$_IInterpreterStoreV1_$323t_address_fromMemory":{"entryPoint":1645,"id":null,"parameterSlots":2,"returnSlots":3},"abi_encode_array_uint256_dyn":{"entryPoint":1417,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_bytes":{"entryPoint":1317,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_address__to_t_address__fromStack_reversed":{"entryPoint":null,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_address_t_address_t_address__to_t_address_t_address_t_address__fromStack_reversed":{"entryPoint":null,"id":null,"parameterSlots":4,"returnSlots":1},"abi_encode_tuple_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__fromStack_reversed":{"entryPoint":1476,"id":null,"parameterSlots":4,"returnSlots":1},"abi_encode_tuple_t_bytes32_t_bytes32__to_t_bytes32_t_bytes32__fromStack_reversed":{"entryPoint":null,"id":null,"parameterSlots":3,"returnSlots":1},"abi_encode_tuple_t_bytes_calldata_ptr__to_t_bytes_memory_ptr__fromStack_reversed":{"entryPoint":1240,"id":null,"parameterSlots":3,"returnSlots":1},"abi_encode_tuple_t_bytes_memory_ptr__to_t_bytes_memory_ptr__fromStack_reversed":{"entryPoint":1722,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_stringliteral_68ca40b61460257f14e69f48b1a4dbc812e9afc6932f127ef8084544457b3335__to_t_string_memory_ptr__fromStack_reversed":{"entryPoint":null,"id":null,"parameterSlots":1,"returnSlots":1},"panic_error_0x41":{"entryPoint":null,"id":null,"parameterSlots":0,"returnSlots":0},"validator_revert_address":{"entryPoint":1073,"id":null,"parameterSlots":1,"returnSlots":0}},"generatedSources":[{"ast":{"nodeType":"YulBlock","src":"0:5757:12","statements":[{"nodeType":"YulBlock","src":"6:3:12","statements":[]},{"body":{"nodeType":"YulBlock","src":"59:109:12","statements":[{"body":{"nodeType":"YulBlock","src":"146:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"155:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"158:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"148:6:12"},"nodeType":"YulFunctionCall","src":"148:12:12"},"nodeType":"YulExpressionStatement","src":"148:12:12"}]},"condition":{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"82:5:12"},{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"93:5:12"},{"kind":"number","nodeType":"YulLiteral","src":"100:42:12","type":"","value":"0xffffffffffffffffffffffffffffffffffffffff"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"89:3:12"},"nodeType":"YulFunctionCall","src":"89:54:12"}],"functionName":{"name":"eq","nodeType":"YulIdentifier","src":"79:2:12"},"nodeType":"YulFunctionCall","src":"79:65:12"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"72:6:12"},"nodeType":"YulFunctionCall","src":"72:73:12"},"nodeType":"YulIf","src":"69:93:12"}]},"name":"validator_revert_address","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nodeType":"YulTypedName","src":"48:5:12","type":""}],"src":"14:154:12"},{"body":{"nodeType":"YulBlock","src":"279:620:12","statements":[{"body":{"nodeType":"YulBlock","src":"325:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"334:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"337:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"327:6:12"},"nodeType":"YulFunctionCall","src":"327:12:12"},"nodeType":"YulExpressionStatement","src":"327:12:12"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nodeType":"YulIdentifier","src":"300:7:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"309:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"296:3:12"},"nodeType":"YulFunctionCall","src":"296:23:12"},{"kind":"number","nodeType":"YulLiteral","src":"321:2:12","type":"","value":"64"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"292:3:12"},"nodeType":"YulFunctionCall","src":"292:32:12"},"nodeType":"YulIf","src":"289:52:12"},{"nodeType":"YulVariableDeclaration","src":"350:36:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"376:9:12"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"363:12:12"},"nodeType":"YulFunctionCall","src":"363:23:12"},"variables":[{"name":"value","nodeType":"YulTypedName","src":"354:5:12","type":""}]},{"expression":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"420:5:12"}],"functionName":{"name":"validator_revert_address","nodeType":"YulIdentifier","src":"395:24:12"},"nodeType":"YulFunctionCall","src":"395:31:12"},"nodeType":"YulExpressionStatement","src":"395:31:12"},{"nodeType":"YulAssignment","src":"435:15:12","value":{"name":"value","nodeType":"YulIdentifier","src":"445:5:12"},"variableNames":[{"name":"value0","nodeType":"YulIdentifier","src":"435:6:12"}]},{"nodeType":"YulVariableDeclaration","src":"459:46:12","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"490:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"501:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"486:3:12"},"nodeType":"YulFunctionCall","src":"486:18:12"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"473:12:12"},"nodeType":"YulFunctionCall","src":"473:32:12"},"variables":[{"name":"offset","nodeType":"YulTypedName","src":"463:6:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"514:28:12","value":{"kind":"number","nodeType":"YulLiteral","src":"524:18:12","type":"","value":"0xffffffffffffffff"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"518:2:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"569:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"578:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"581:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"571:6:12"},"nodeType":"YulFunctionCall","src":"571:12:12"},"nodeType":"YulExpressionStatement","src":"571:12:12"}]},"condition":{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"557:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"565:2:12"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"554:2:12"},"nodeType":"YulFunctionCall","src":"554:14:12"},"nodeType":"YulIf","src":"551:34:12"},{"nodeType":"YulVariableDeclaration","src":"594:32:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"608:9:12"},{"name":"offset","nodeType":"YulIdentifier","src":"619:6:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"604:3:12"},"nodeType":"YulFunctionCall","src":"604:22:12"},"variables":[{"name":"_2","nodeType":"YulTypedName","src":"598:2:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"674:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"683:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"686:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"676:6:12"},"nodeType":"YulFunctionCall","src":"676:12:12"},"nodeType":"YulExpressionStatement","src":"676:12:12"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"_2","nodeType":"YulIdentifier","src":"653:2:12"},{"kind":"number","nodeType":"YulLiteral","src":"657:4:12","type":"","value":"0x1f"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"649:3:12"},"nodeType":"YulFunctionCall","src":"649:13:12"},{"name":"dataEnd","nodeType":"YulIdentifier","src":"664:7:12"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"645:3:12"},"nodeType":"YulFunctionCall","src":"645:27:12"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"638:6:12"},"nodeType":"YulFunctionCall","src":"638:35:12"},"nodeType":"YulIf","src":"635:55:12"},{"nodeType":"YulVariableDeclaration","src":"699:30:12","value":{"arguments":[{"name":"_2","nodeType":"YulIdentifier","src":"726:2:12"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"713:12:12"},"nodeType":"YulFunctionCall","src":"713:16:12"},"variables":[{"name":"length","nodeType":"YulTypedName","src":"703:6:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"756:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"765:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"768:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"758:6:12"},"nodeType":"YulFunctionCall","src":"758:12:12"},"nodeType":"YulExpressionStatement","src":"758:12:12"}]},"condition":{"arguments":[{"name":"length","nodeType":"YulIdentifier","src":"744:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"752:2:12"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"741:2:12"},"nodeType":"YulFunctionCall","src":"741:14:12"},"nodeType":"YulIf","src":"738:34:12"},{"body":{"nodeType":"YulBlock","src":"822:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"831:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"834:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"824:6:12"},"nodeType":"YulFunctionCall","src":"824:12:12"},"nodeType":"YulExpressionStatement","src":"824:12:12"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"_2","nodeType":"YulIdentifier","src":"795:2:12"},{"name":"length","nodeType":"YulIdentifier","src":"799:6:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"791:3:12"},"nodeType":"YulFunctionCall","src":"791:15:12"},{"kind":"number","nodeType":"YulLiteral","src":"808:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"787:3:12"},"nodeType":"YulFunctionCall","src":"787:24:12"},{"name":"dataEnd","nodeType":"YulIdentifier","src":"813:7:12"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"784:2:12"},"nodeType":"YulFunctionCall","src":"784:37:12"},"nodeType":"YulIf","src":"781:57:12"},{"nodeType":"YulAssignment","src":"847:21:12","value":{"arguments":[{"name":"_2","nodeType":"YulIdentifier","src":"861:2:12"},{"kind":"number","nodeType":"YulLiteral","src":"865:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"857:3:12"},"nodeType":"YulFunctionCall","src":"857:11:12"},"variableNames":[{"name":"value1","nodeType":"YulIdentifier","src":"847:6:12"}]},{"nodeType":"YulAssignment","src":"877:16:12","value":{"name":"length","nodeType":"YulIdentifier","src":"887:6:12"},"variableNames":[{"name":"value2","nodeType":"YulIdentifier","src":"877:6:12"}]}]},"name":"abi_decode_tuple_t_addresst_bytes_calldata_ptr","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"229:9:12","type":""},{"name":"dataEnd","nodeType":"YulTypedName","src":"240:7:12","type":""}],"returnVariables":[{"name":"value0","nodeType":"YulTypedName","src":"252:6:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"260:6:12","type":""},{"name":"value2","nodeType":"YulTypedName","src":"268:6:12","type":""}],"src":"173:726:12"},{"body":{"nodeType":"YulBlock","src":"1005:125:12","statements":[{"nodeType":"YulAssignment","src":"1015:26:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1027:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"1038:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1023:3:12"},"nodeType":"YulFunctionCall","src":"1023:18:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"1015:4:12"}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1057:9:12"},{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"1072:6:12"},{"kind":"number","nodeType":"YulLiteral","src":"1080:42:12","type":"","value":"0xffffffffffffffffffffffffffffffffffffffff"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"1068:3:12"},"nodeType":"YulFunctionCall","src":"1068:55:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1050:6:12"},"nodeType":"YulFunctionCall","src":"1050:74:12"},"nodeType":"YulExpressionStatement","src":"1050:74:12"}]},"name":"abi_encode_tuple_t_address__to_t_address__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"974:9:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"985:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"996:4:12","type":""}],"src":"904:226:12"},{"body":{"nodeType":"YulBlock","src":"1292:250:12","statements":[{"nodeType":"YulAssignment","src":"1302:26:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1314:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"1325:2:12","type":"","value":"96"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1310:3:12"},"nodeType":"YulFunctionCall","src":"1310:18:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"1302:4:12"}]},{"nodeType":"YulVariableDeclaration","src":"1337:52:12","value":{"kind":"number","nodeType":"YulLiteral","src":"1347:42:12","type":"","value":"0xffffffffffffffffffffffffffffffffffffffff"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"1341:2:12","type":""}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1405:9:12"},{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"1420:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"1428:2:12"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"1416:3:12"},"nodeType":"YulFunctionCall","src":"1416:15:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1398:6:12"},"nodeType":"YulFunctionCall","src":"1398:34:12"},"nodeType":"YulExpressionStatement","src":"1398:34:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1452:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"1463:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1448:3:12"},"nodeType":"YulFunctionCall","src":"1448:18:12"},{"arguments":[{"name":"value1","nodeType":"YulIdentifier","src":"1472:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"1480:2:12"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"1468:3:12"},"nodeType":"YulFunctionCall","src":"1468:15:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1441:6:12"},"nodeType":"YulFunctionCall","src":"1441:43:12"},"nodeType":"YulExpressionStatement","src":"1441:43:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1504:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"1515:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1500:3:12"},"nodeType":"YulFunctionCall","src":"1500:18:12"},{"arguments":[{"name":"value2","nodeType":"YulIdentifier","src":"1524:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"1532:2:12"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"1520:3:12"},"nodeType":"YulFunctionCall","src":"1520:15:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1493:6:12"},"nodeType":"YulFunctionCall","src":"1493:43:12"},"nodeType":"YulExpressionStatement","src":"1493:43:12"}]},"name":"abi_encode_tuple_t_address_t_address_t_address__to_t_address_t_address_t_address__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"1245:9:12","type":""},{"name":"value2","nodeType":"YulTypedName","src":"1256:6:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"1264:6:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"1272:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"1283:4:12","type":""}],"src":"1135:407:12"},{"body":{"nodeType":"YulBlock","src":"1676:318:12","statements":[{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1693:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"1704:2:12","type":"","value":"32"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1686:6:12"},"nodeType":"YulFunctionCall","src":"1686:21:12"},"nodeType":"YulExpressionStatement","src":"1686:21:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1727:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"1738:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1723:3:12"},"nodeType":"YulFunctionCall","src":"1723:18:12"},{"name":"value1","nodeType":"YulIdentifier","src":"1743:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1716:6:12"},"nodeType":"YulFunctionCall","src":"1716:34:12"},"nodeType":"YulExpressionStatement","src":"1716:34:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1776:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"1787:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1772:3:12"},"nodeType":"YulFunctionCall","src":"1772:18:12"},{"name":"value0","nodeType":"YulIdentifier","src":"1792:6:12"},{"name":"value1","nodeType":"YulIdentifier","src":"1800:6:12"}],"functionName":{"name":"calldatacopy","nodeType":"YulIdentifier","src":"1759:12:12"},"nodeType":"YulFunctionCall","src":"1759:48:12"},"nodeType":"YulExpressionStatement","src":"1759:48:12"},{"expression":{"arguments":[{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1831:9:12"},{"name":"value1","nodeType":"YulIdentifier","src":"1842:6:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1827:3:12"},"nodeType":"YulFunctionCall","src":"1827:22:12"},{"kind":"number","nodeType":"YulLiteral","src":"1851:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1823:3:12"},"nodeType":"YulFunctionCall","src":"1823:31:12"},{"kind":"number","nodeType":"YulLiteral","src":"1856:1:12","type":"","value":"0"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1816:6:12"},"nodeType":"YulFunctionCall","src":"1816:42:12"},"nodeType":"YulExpressionStatement","src":"1816:42:12"},{"nodeType":"YulAssignment","src":"1867:121:12","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1883:9:12"},{"arguments":[{"arguments":[{"name":"value1","nodeType":"YulIdentifier","src":"1902:6:12"},{"kind":"number","nodeType":"YulLiteral","src":"1910:2:12","type":"","value":"31"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1898:3:12"},"nodeType":"YulFunctionCall","src":"1898:15:12"},{"kind":"number","nodeType":"YulLiteral","src":"1915:66:12","type":"","value":"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"1894:3:12"},"nodeType":"YulFunctionCall","src":"1894:88:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1879:3:12"},"nodeType":"YulFunctionCall","src":"1879:104:12"},{"kind":"number","nodeType":"YulLiteral","src":"1985:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1875:3:12"},"nodeType":"YulFunctionCall","src":"1875:113:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"1867:4:12"}]}]},"name":"abi_encode_tuple_t_bytes_calldata_ptr__to_t_bytes_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"1637:9:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"1648:6:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"1656:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"1667:4:12","type":""}],"src":"1547:447:12"},{"body":{"nodeType":"YulBlock","src":"2128:119:12","statements":[{"nodeType":"YulAssignment","src":"2138:26:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2150:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"2161:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2146:3:12"},"nodeType":"YulFunctionCall","src":"2146:18:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"2138:4:12"}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2180:9:12"},{"name":"value0","nodeType":"YulIdentifier","src":"2191:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2173:6:12"},"nodeType":"YulFunctionCall","src":"2173:25:12"},"nodeType":"YulExpressionStatement","src":"2173:25:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2218:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"2229:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2214:3:12"},"nodeType":"YulFunctionCall","src":"2214:18:12"},{"name":"value1","nodeType":"YulIdentifier","src":"2234:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2207:6:12"},"nodeType":"YulFunctionCall","src":"2207:34:12"},"nodeType":"YulExpressionStatement","src":"2207:34:12"}]},"name":"abi_encode_tuple_t_bytes32_t_bytes32__to_t_bytes32_t_bytes32__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"2089:9:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"2100:6:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"2108:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"2119:4:12","type":""}],"src":"1999:248:12"},{"body":{"nodeType":"YulBlock","src":"2284:152:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2301:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"2304:77:12","type":"","value":"35408467139433450592217433187231851964531694900788300625387963629091585785856"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2294:6:12"},"nodeType":"YulFunctionCall","src":"2294:88:12"},"nodeType":"YulExpressionStatement","src":"2294:88:12"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2398:1:12","type":"","value":"4"},{"kind":"number","nodeType":"YulLiteral","src":"2401:4:12","type":"","value":"0x41"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2391:6:12"},"nodeType":"YulFunctionCall","src":"2391:15:12"},"nodeType":"YulExpressionStatement","src":"2391:15:12"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2422:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"2425:4:12","type":"","value":"0x24"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"2415:6:12"},"nodeType":"YulFunctionCall","src":"2415:15:12"},"nodeType":"YulExpressionStatement","src":"2415:15:12"}]},"name":"panic_error_0x41","nodeType":"YulFunctionDefinition","src":"2252:184:12"},{"body":{"nodeType":"YulBlock","src":"2490:432:12","statements":[{"nodeType":"YulVariableDeclaration","src":"2500:26:12","value":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"2520:5:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"2514:5:12"},"nodeType":"YulFunctionCall","src":"2514:12:12"},"variables":[{"name":"length","nodeType":"YulTypedName","src":"2504:6:12","type":""}]},{"expression":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"2542:3:12"},{"name":"length","nodeType":"YulIdentifier","src":"2547:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2535:6:12"},"nodeType":"YulFunctionCall","src":"2535:19:12"},"nodeType":"YulExpressionStatement","src":"2535:19:12"},{"nodeType":"YulVariableDeclaration","src":"2563:10:12","value":{"kind":"number","nodeType":"YulLiteral","src":"2572:1:12","type":"","value":"0"},"variables":[{"name":"i","nodeType":"YulTypedName","src":"2567:1:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"2634:110:12","statements":[{"nodeType":"YulVariableDeclaration","src":"2648:14:12","value":{"kind":"number","nodeType":"YulLiteral","src":"2658:4:12","type":"","value":"0x20"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"2652:2:12","type":""}]},{"expression":{"arguments":[{"arguments":[{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"2690:3:12"},{"name":"i","nodeType":"YulIdentifier","src":"2695:1:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2686:3:12"},"nodeType":"YulFunctionCall","src":"2686:11:12"},{"name":"_1","nodeType":"YulIdentifier","src":"2699:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2682:3:12"},"nodeType":"YulFunctionCall","src":"2682:20:12"},{"arguments":[{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"2718:5:12"},{"name":"i","nodeType":"YulIdentifier","src":"2725:1:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2714:3:12"},"nodeType":"YulFunctionCall","src":"2714:13:12"},{"name":"_1","nodeType":"YulIdentifier","src":"2729:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2710:3:12"},"nodeType":"YulFunctionCall","src":"2710:22:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"2704:5:12"},"nodeType":"YulFunctionCall","src":"2704:29:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2675:6:12"},"nodeType":"YulFunctionCall","src":"2675:59:12"},"nodeType":"YulExpressionStatement","src":"2675:59:12"}]},"condition":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"2593:1:12"},{"name":"length","nodeType":"YulIdentifier","src":"2596:6:12"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"2590:2:12"},"nodeType":"YulFunctionCall","src":"2590:13:12"},"nodeType":"YulForLoop","post":{"nodeType":"YulBlock","src":"2604:21:12","statements":[{"nodeType":"YulAssignment","src":"2606:17:12","value":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"2615:1:12"},{"kind":"number","nodeType":"YulLiteral","src":"2618:4:12","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2611:3:12"},"nodeType":"YulFunctionCall","src":"2611:12:12"},"variableNames":[{"name":"i","nodeType":"YulIdentifier","src":"2606:1:12"}]}]},"pre":{"nodeType":"YulBlock","src":"2586:3:12","statements":[]},"src":"2582:162:12"},{"expression":{"arguments":[{"arguments":[{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"2768:3:12"},{"name":"length","nodeType":"YulIdentifier","src":"2773:6:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2764:3:12"},"nodeType":"YulFunctionCall","src":"2764:16:12"},{"kind":"number","nodeType":"YulLiteral","src":"2782:4:12","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2760:3:12"},"nodeType":"YulFunctionCall","src":"2760:27:12"},{"kind":"number","nodeType":"YulLiteral","src":"2789:1:12","type":"","value":"0"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2753:6:12"},"nodeType":"YulFunctionCall","src":"2753:38:12"},"nodeType":"YulExpressionStatement","src":"2753:38:12"},{"nodeType":"YulAssignment","src":"2800:116:12","value":{"arguments":[{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"2815:3:12"},{"arguments":[{"arguments":[{"name":"length","nodeType":"YulIdentifier","src":"2828:6:12"},{"kind":"number","nodeType":"YulLiteral","src":"2836:2:12","type":"","value":"31"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2824:3:12"},"nodeType":"YulFunctionCall","src":"2824:15:12"},{"kind":"number","nodeType":"YulLiteral","src":"2841:66:12","type":"","value":"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"2820:3:12"},"nodeType":"YulFunctionCall","src":"2820:88:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2811:3:12"},"nodeType":"YulFunctionCall","src":"2811:98:12"},{"kind":"number","nodeType":"YulLiteral","src":"2911:4:12","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2807:3:12"},"nodeType":"YulFunctionCall","src":"2807:109:12"},"variableNames":[{"name":"end","nodeType":"YulIdentifier","src":"2800:3:12"}]}]},"name":"abi_encode_bytes","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nodeType":"YulTypedName","src":"2467:5:12","type":""},{"name":"pos","nodeType":"YulTypedName","src":"2474:3:12","type":""}],"returnVariables":[{"name":"end","nodeType":"YulTypedName","src":"2482:3:12","type":""}],"src":"2441:481:12"},{"body":{"nodeType":"YulBlock","src":"2988:374:12","statements":[{"nodeType":"YulVariableDeclaration","src":"2998:26:12","value":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"3018:5:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"3012:5:12"},"nodeType":"YulFunctionCall","src":"3012:12:12"},"variables":[{"name":"length","nodeType":"YulTypedName","src":"3002:6:12","type":""}]},{"expression":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3040:3:12"},{"name":"length","nodeType":"YulIdentifier","src":"3045:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3033:6:12"},"nodeType":"YulFunctionCall","src":"3033:19:12"},"nodeType":"YulExpressionStatement","src":"3033:19:12"},{"nodeType":"YulVariableDeclaration","src":"3061:14:12","value":{"kind":"number","nodeType":"YulLiteral","src":"3071:4:12","type":"","value":"0x20"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"3065:2:12","type":""}]},{"nodeType":"YulAssignment","src":"3084:19:12","value":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3095:3:12"},{"name":"_1","nodeType":"YulIdentifier","src":"3100:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3091:3:12"},"nodeType":"YulFunctionCall","src":"3091:12:12"},"variableNames":[{"name":"pos","nodeType":"YulIdentifier","src":"3084:3:12"}]},{"nodeType":"YulVariableDeclaration","src":"3112:28:12","value":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"3130:5:12"},{"name":"_1","nodeType":"YulIdentifier","src":"3137:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3126:3:12"},"nodeType":"YulFunctionCall","src":"3126:14:12"},"variables":[{"name":"srcPtr","nodeType":"YulTypedName","src":"3116:6:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"3149:10:12","value":{"kind":"number","nodeType":"YulLiteral","src":"3158:1:12","type":"","value":"0"},"variables":[{"name":"i","nodeType":"YulTypedName","src":"3153:1:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"3217:120:12","statements":[{"expression":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3238:3:12"},{"arguments":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"3249:6:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"3243:5:12"},"nodeType":"YulFunctionCall","src":"3243:13:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3231:6:12"},"nodeType":"YulFunctionCall","src":"3231:26:12"},"nodeType":"YulExpressionStatement","src":"3231:26:12"},{"nodeType":"YulAssignment","src":"3270:19:12","value":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3281:3:12"},{"name":"_1","nodeType":"YulIdentifier","src":"3286:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3277:3:12"},"nodeType":"YulFunctionCall","src":"3277:12:12"},"variableNames":[{"name":"pos","nodeType":"YulIdentifier","src":"3270:3:12"}]},{"nodeType":"YulAssignment","src":"3302:25:12","value":{"arguments":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"3316:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"3324:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3312:3:12"},"nodeType":"YulFunctionCall","src":"3312:15:12"},"variableNames":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"3302:6:12"}]}]},"condition":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"3179:1:12"},{"name":"length","nodeType":"YulIdentifier","src":"3182:6:12"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"3176:2:12"},"nodeType":"YulFunctionCall","src":"3176:13:12"},"nodeType":"YulForLoop","post":{"nodeType":"YulBlock","src":"3190:18:12","statements":[{"nodeType":"YulAssignment","src":"3192:14:12","value":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"3201:1:12"},{"kind":"number","nodeType":"YulLiteral","src":"3204:1:12","type":"","value":"1"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3197:3:12"},"nodeType":"YulFunctionCall","src":"3197:9:12"},"variableNames":[{"name":"i","nodeType":"YulIdentifier","src":"3192:1:12"}]}]},"pre":{"nodeType":"YulBlock","src":"3172:3:12","statements":[]},"src":"3168:169:12"},{"nodeType":"YulAssignment","src":"3346:10:12","value":{"name":"pos","nodeType":"YulIdentifier","src":"3353:3:12"},"variableNames":[{"name":"end","nodeType":"YulIdentifier","src":"3346:3:12"}]}]},"name":"abi_encode_array_uint256_dyn","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nodeType":"YulTypedName","src":"2965:5:12","type":""},{"name":"pos","nodeType":"YulTypedName","src":"2972:3:12","type":""}],"returnVariables":[{"name":"end","nodeType":"YulTypedName","src":"2980:3:12","type":""}],"src":"2927:435:12"},{"body":{"nodeType":"YulBlock","src":"3692:917:12","statements":[{"nodeType":"YulVariableDeclaration","src":"3702:32:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3720:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"3731:2:12","type":"","value":"96"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3716:3:12"},"nodeType":"YulFunctionCall","src":"3716:18:12"},"variables":[{"name":"tail_1","nodeType":"YulTypedName","src":"3706:6:12","type":""}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3750:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"3761:2:12","type":"","value":"96"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3743:6:12"},"nodeType":"YulFunctionCall","src":"3743:21:12"},"nodeType":"YulExpressionStatement","src":"3743:21:12"},{"nodeType":"YulVariableDeclaration","src":"3773:17:12","value":{"name":"tail_1","nodeType":"YulIdentifier","src":"3784:6:12"},"variables":[{"name":"pos","nodeType":"YulTypedName","src":"3777:3:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"3799:27:12","value":{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"3819:6:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"3813:5:12"},"nodeType":"YulFunctionCall","src":"3813:13:12"},"variables":[{"name":"length","nodeType":"YulTypedName","src":"3803:6:12","type":""}]},{"expression":{"arguments":[{"name":"tail_1","nodeType":"YulIdentifier","src":"3842:6:12"},{"name":"length","nodeType":"YulIdentifier","src":"3850:6:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3835:6:12"},"nodeType":"YulFunctionCall","src":"3835:22:12"},"nodeType":"YulExpressionStatement","src":"3835:22:12"},{"nodeType":"YulAssignment","src":"3866:26:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3877:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"3888:3:12","type":"","value":"128"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3873:3:12"},"nodeType":"YulFunctionCall","src":"3873:19:12"},"variableNames":[{"name":"pos","nodeType":"YulIdentifier","src":"3866:3:12"}]},{"nodeType":"YulVariableDeclaration","src":"3901:54:12","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3923:9:12"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"3938:1:12","type":"","value":"5"},{"name":"length","nodeType":"YulIdentifier","src":"3941:6:12"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"3934:3:12"},"nodeType":"YulFunctionCall","src":"3934:14:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3919:3:12"},"nodeType":"YulFunctionCall","src":"3919:30:12"},{"kind":"number","nodeType":"YulLiteral","src":"3951:3:12","type":"","value":"128"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3915:3:12"},"nodeType":"YulFunctionCall","src":"3915:40:12"},"variables":[{"name":"tail_2","nodeType":"YulTypedName","src":"3905:6:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"3964:14:12","value":{"kind":"number","nodeType":"YulLiteral","src":"3974:4:12","type":"","value":"0x20"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"3968:2:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"3987:29:12","value":{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"4005:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"4013:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4001:3:12"},"nodeType":"YulFunctionCall","src":"4001:15:12"},"variables":[{"name":"srcPtr","nodeType":"YulTypedName","src":"3991:6:12","type":""}]},{"nodeType":"YulVariableDeclaration","src":"4025:10:12","value":{"kind":"number","nodeType":"YulLiteral","src":"4034:1:12","type":"","value":"0"},"variables":[{"name":"i","nodeType":"YulTypedName","src":"4029:1:12","type":""}]},{"body":{"nodeType":"YulBlock","src":"4093:264:12","statements":[{"expression":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"4114:3:12"},{"arguments":[{"arguments":[{"name":"tail_2","nodeType":"YulIdentifier","src":"4127:6:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"4135:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"4123:3:12"},"nodeType":"YulFunctionCall","src":"4123:22:12"},{"kind":"number","nodeType":"YulLiteral","src":"4147:66:12","type":"","value":"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4119:3:12"},"nodeType":"YulFunctionCall","src":"4119:95:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4107:6:12"},"nodeType":"YulFunctionCall","src":"4107:108:12"},"nodeType":"YulExpressionStatement","src":"4107:108:12"},{"nodeType":"YulAssignment","src":"4228:49:12","value":{"arguments":[{"arguments":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"4261:6:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"4255:5:12"},"nodeType":"YulFunctionCall","src":"4255:13:12"},{"name":"tail_2","nodeType":"YulIdentifier","src":"4270:6:12"}],"functionName":{"name":"abi_encode_bytes","nodeType":"YulIdentifier","src":"4238:16:12"},"nodeType":"YulFunctionCall","src":"4238:39:12"},"variableNames":[{"name":"tail_2","nodeType":"YulIdentifier","src":"4228:6:12"}]},{"nodeType":"YulAssignment","src":"4290:25:12","value":{"arguments":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"4304:6:12"},{"name":"_1","nodeType":"YulIdentifier","src":"4312:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4300:3:12"},"nodeType":"YulFunctionCall","src":"4300:15:12"},"variableNames":[{"name":"srcPtr","nodeType":"YulIdentifier","src":"4290:6:12"}]},{"nodeType":"YulAssignment","src":"4328:19:12","value":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"4339:3:12"},{"name":"_1","nodeType":"YulIdentifier","src":"4344:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4335:3:12"},"nodeType":"YulFunctionCall","src":"4335:12:12"},"variableNames":[{"name":"pos","nodeType":"YulIdentifier","src":"4328:3:12"}]}]},"condition":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"4055:1:12"},{"name":"length","nodeType":"YulIdentifier","src":"4058:6:12"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"4052:2:12"},"nodeType":"YulFunctionCall","src":"4052:13:12"},"nodeType":"YulForLoop","post":{"nodeType":"YulBlock","src":"4066:18:12","statements":[{"nodeType":"YulAssignment","src":"4068:14:12","value":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"4077:1:12"},{"kind":"number","nodeType":"YulLiteral","src":"4080:1:12","type":"","value":"1"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4073:3:12"},"nodeType":"YulFunctionCall","src":"4073:9:12"},"variableNames":[{"name":"i","nodeType":"YulIdentifier","src":"4068:1:12"}]}]},"pre":{"nodeType":"YulBlock","src":"4048:3:12","statements":[]},"src":"4044:313:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4377:9:12"},{"name":"_1","nodeType":"YulIdentifier","src":"4388:2:12"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4373:3:12"},"nodeType":"YulFunctionCall","src":"4373:18:12"},{"arguments":[{"name":"tail_2","nodeType":"YulIdentifier","src":"4397:6:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"4405:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"4393:3:12"},"nodeType":"YulFunctionCall","src":"4393:22:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4366:6:12"},"nodeType":"YulFunctionCall","src":"4366:50:12"},"nodeType":"YulExpressionStatement","src":"4366:50:12"},{"nodeType":"YulVariableDeclaration","src":"4425:58:12","value":{"arguments":[{"name":"value1","nodeType":"YulIdentifier","src":"4468:6:12"},{"name":"tail_2","nodeType":"YulIdentifier","src":"4476:6:12"}],"functionName":{"name":"abi_encode_array_uint256_dyn","nodeType":"YulIdentifier","src":"4439:28:12"},"nodeType":"YulFunctionCall","src":"4439:44:12"},"variables":[{"name":"tail_3","nodeType":"YulTypedName","src":"4429:6:12","type":""}]},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4503:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"4514:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4499:3:12"},"nodeType":"YulFunctionCall","src":"4499:18:12"},{"arguments":[{"name":"tail_3","nodeType":"YulIdentifier","src":"4523:6:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"4531:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"4519:3:12"},"nodeType":"YulFunctionCall","src":"4519:22:12"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4492:6:12"},"nodeType":"YulFunctionCall","src":"4492:50:12"},"nodeType":"YulExpressionStatement","src":"4492:50:12"},{"nodeType":"YulAssignment","src":"4551:52:12","value":{"arguments":[{"name":"value2","nodeType":"YulIdentifier","src":"4588:6:12"},{"name":"tail_3","nodeType":"YulIdentifier","src":"4596:6:12"}],"functionName":{"name":"abi_encode_array_uint256_dyn","nodeType":"YulIdentifier","src":"4559:28:12"},"nodeType":"YulFunctionCall","src":"4559:44:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"4551:4:12"}]}]},"name":"abi_encode_tuple_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"3645:9:12","type":""},{"name":"value2","nodeType":"YulTypedName","src":"3656:6:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"3664:6:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"3672:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"3683:4:12","type":""}],"src":"3367:1242:12"},{"body":{"nodeType":"YulBlock","src":"4778:404:12","statements":[{"body":{"nodeType":"YulBlock","src":"4824:16:12","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"4833:1:12","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"4836:1:12","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"4826:6:12"},"nodeType":"YulFunctionCall","src":"4826:12:12"},"nodeType":"YulExpressionStatement","src":"4826:12:12"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nodeType":"YulIdentifier","src":"4799:7:12"},{"name":"headStart","nodeType":"YulIdentifier","src":"4808:9:12"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"4795:3:12"},"nodeType":"YulFunctionCall","src":"4795:23:12"},{"kind":"number","nodeType":"YulLiteral","src":"4820:2:12","type":"","value":"96"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"4791:3:12"},"nodeType":"YulFunctionCall","src":"4791:32:12"},"nodeType":"YulIf","src":"4788:52:12"},{"nodeType":"YulVariableDeclaration","src":"4849:29:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4868:9:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"4862:5:12"},"nodeType":"YulFunctionCall","src":"4862:16:12"},"variables":[{"name":"value","nodeType":"YulTypedName","src":"4853:5:12","type":""}]},{"expression":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"4912:5:12"}],"functionName":{"name":"validator_revert_address","nodeType":"YulIdentifier","src":"4887:24:12"},"nodeType":"YulFunctionCall","src":"4887:31:12"},"nodeType":"YulExpressionStatement","src":"4887:31:12"},{"nodeType":"YulAssignment","src":"4927:15:12","value":{"name":"value","nodeType":"YulIdentifier","src":"4937:5:12"},"variableNames":[{"name":"value0","nodeType":"YulIdentifier","src":"4927:6:12"}]},{"nodeType":"YulVariableDeclaration","src":"4951:40:12","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4976:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"4987:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4972:3:12"},"nodeType":"YulFunctionCall","src":"4972:18:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"4966:5:12"},"nodeType":"YulFunctionCall","src":"4966:25:12"},"variables":[{"name":"value_1","nodeType":"YulTypedName","src":"4955:7:12","type":""}]},{"expression":{"arguments":[{"name":"value_1","nodeType":"YulIdentifier","src":"5025:7:12"}],"functionName":{"name":"validator_revert_address","nodeType":"YulIdentifier","src":"5000:24:12"},"nodeType":"YulFunctionCall","src":"5000:33:12"},"nodeType":"YulExpressionStatement","src":"5000:33:12"},{"nodeType":"YulAssignment","src":"5042:17:12","value":{"name":"value_1","nodeType":"YulIdentifier","src":"5052:7:12"},"variableNames":[{"name":"value1","nodeType":"YulIdentifier","src":"5042:6:12"}]},{"nodeType":"YulVariableDeclaration","src":"5068:40:12","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5093:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5104:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5089:3:12"},"nodeType":"YulFunctionCall","src":"5089:18:12"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"5083:5:12"},"nodeType":"YulFunctionCall","src":"5083:25:12"},"variables":[{"name":"value_2","nodeType":"YulTypedName","src":"5072:7:12","type":""}]},{"expression":{"arguments":[{"name":"value_2","nodeType":"YulIdentifier","src":"5142:7:12"}],"functionName":{"name":"validator_revert_address","nodeType":"YulIdentifier","src":"5117:24:12"},"nodeType":"YulFunctionCall","src":"5117:33:12"},"nodeType":"YulExpressionStatement","src":"5117:33:12"},{"nodeType":"YulAssignment","src":"5159:17:12","value":{"name":"value_2","nodeType":"YulIdentifier","src":"5169:7:12"},"variableNames":[{"name":"value2","nodeType":"YulIdentifier","src":"5159:6:12"}]}]},"name":"abi_decode_tuple_t_contract$_IInterpreterV1_$373t_contract$_IInterpreterStoreV1_$323t_address_fromMemory","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"4728:9:12","type":""},{"name":"dataEnd","nodeType":"YulTypedName","src":"4739:7:12","type":""}],"returnVariables":[{"name":"value0","nodeType":"YulTypedName","src":"4751:6:12","type":""},{"name":"value1","nodeType":"YulTypedName","src":"4759:6:12","type":""},{"name":"value2","nodeType":"YulTypedName","src":"4767:6:12","type":""}],"src":"4614:568:12"},{"body":{"nodeType":"YulBlock","src":"5361:172:12","statements":[{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5378:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5389:2:12","type":"","value":"32"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5371:6:12"},"nodeType":"YulFunctionCall","src":"5371:21:12"},"nodeType":"YulExpressionStatement","src":"5371:21:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5412:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5423:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5408:3:12"},"nodeType":"YulFunctionCall","src":"5408:18:12"},{"kind":"number","nodeType":"YulLiteral","src":"5428:2:12","type":"","value":"22"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5401:6:12"},"nodeType":"YulFunctionCall","src":"5401:30:12"},"nodeType":"YulExpressionStatement","src":"5401:30:12"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5451:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5462:2:12","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5447:3:12"},"nodeType":"YulFunctionCall","src":"5447:18:12"},{"hexValue":"455243313136373a20637265617465206661696c6564","kind":"string","nodeType":"YulLiteral","src":"5467:24:12","type":"","value":"ERC1167: create failed"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5440:6:12"},"nodeType":"YulFunctionCall","src":"5440:52:12"},"nodeType":"YulExpressionStatement","src":"5440:52:12"},{"nodeType":"YulAssignment","src":"5501:26:12","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5513:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5524:2:12","type":"","value":"96"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5509:3:12"},"nodeType":"YulFunctionCall","src":"5509:18:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"5501:4:12"}]}]},"name":"abi_encode_tuple_t_stringliteral_68ca40b61460257f14e69f48b1a4dbc812e9afc6932f127ef8084544457b3335__to_t_string_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"5338:9:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"5352:4:12","type":""}],"src":"5187:346:12"},{"body":{"nodeType":"YulBlock","src":"5657:98:12","statements":[{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5674:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5685:2:12","type":"","value":"32"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5667:6:12"},"nodeType":"YulFunctionCall","src":"5667:21:12"},"nodeType":"YulExpressionStatement","src":"5667:21:12"},{"nodeType":"YulAssignment","src":"5697:52:12","value":{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"5722:6:12"},{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5734:9:12"},{"kind":"number","nodeType":"YulLiteral","src":"5745:2:12","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5730:3:12"},"nodeType":"YulFunctionCall","src":"5730:18:12"}],"functionName":{"name":"abi_encode_bytes","nodeType":"YulIdentifier","src":"5705:16:12"},"nodeType":"YulFunctionCall","src":"5705:44:12"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"5697:4:12"}]}]},"name":"abi_encode_tuple_t_bytes_memory_ptr__to_t_bytes_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"5626:9:12","type":""},{"name":"value0","nodeType":"YulTypedName","src":"5637:6:12","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"5648:4:12","type":""}],"src":"5538:217:12"}]},"contents":"{\n    { }\n    function validator_revert_address(value)\n    {\n        if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffff))) { revert(0, 0) }\n    }\n    function abi_decode_tuple_t_addresst_bytes_calldata_ptr(headStart, dataEnd) -> value0, value1, value2\n    {\n        if slt(sub(dataEnd, headStart), 64) { revert(0, 0) }\n        let value := calldataload(headStart)\n        validator_revert_address(value)\n        value0 := value\n        let offset := calldataload(add(headStart, 32))\n        let _1 := 0xffffffffffffffff\n        if gt(offset, _1) { revert(0, 0) }\n        let _2 := add(headStart, offset)\n        if iszero(slt(add(_2, 0x1f), dataEnd)) { revert(0, 0) }\n        let length := calldataload(_2)\n        if gt(length, _1) { revert(0, 0) }\n        if gt(add(add(_2, length), 32), dataEnd) { revert(0, 0) }\n        value1 := add(_2, 32)\n        value2 := length\n    }\n    function abi_encode_tuple_t_address__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, 0xffffffffffffffffffffffffffffffffffffffff))\n    }\n    function abi_encode_tuple_t_address_t_address_t_address__to_t_address_t_address_t_address__fromStack_reversed(headStart, value2, value1, value0) -> tail\n    {\n        tail := add(headStart, 96)\n        let _1 := 0xffffffffffffffffffffffffffffffffffffffff\n        mstore(headStart, and(value0, _1))\n        mstore(add(headStart, 32), and(value1, _1))\n        mstore(add(headStart, 64), and(value2, _1))\n    }\n    function abi_encode_tuple_t_bytes_calldata_ptr__to_t_bytes_memory_ptr__fromStack_reversed(headStart, value1, value0) -> tail\n    {\n        mstore(headStart, 32)\n        mstore(add(headStart, 32), value1)\n        calldatacopy(add(headStart, 64), value0, value1)\n        mstore(add(add(headStart, value1), 64), 0)\n        tail := add(add(headStart, and(add(value1, 31), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0)), 64)\n    }\n    function abi_encode_tuple_t_bytes32_t_bytes32__to_t_bytes32_t_bytes32__fromStack_reversed(headStart, value1, value0) -> tail\n    {\n        tail := add(headStart, 64)\n        mstore(headStart, value0)\n        mstore(add(headStart, 32), value1)\n    }\n    function panic_error_0x41()\n    {\n        mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n        mstore(4, 0x41)\n        revert(0, 0x24)\n    }\n    function abi_encode_bytes(value, pos) -> end\n    {\n        let length := mload(value)\n        mstore(pos, length)\n        let i := 0\n        for { } lt(i, length) { i := add(i, 0x20) }\n        {\n            let _1 := 0x20\n            mstore(add(add(pos, i), _1), mload(add(add(value, i), _1)))\n        }\n        mstore(add(add(pos, length), 0x20), 0)\n        end := add(add(pos, and(add(length, 31), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0)), 0x20)\n    }\n    function abi_encode_array_uint256_dyn(value, pos) -> end\n    {\n        let length := mload(value)\n        mstore(pos, length)\n        let _1 := 0x20\n        pos := add(pos, _1)\n        let srcPtr := add(value, _1)\n        let i := 0\n        for { } lt(i, length) { i := add(i, 1) }\n        {\n            mstore(pos, mload(srcPtr))\n            pos := add(pos, _1)\n            srcPtr := add(srcPtr, _1)\n        }\n        end := pos\n    }\n    function abi_encode_tuple_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_bytes_memory_ptr_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr_t_array$_t_uint256_$dyn_memory_ptr__fromStack_reversed(headStart, value2, value1, value0) -> tail\n    {\n        let tail_1 := add(headStart, 96)\n        mstore(headStart, 96)\n        let pos := tail_1\n        let length := mload(value0)\n        mstore(tail_1, length)\n        pos := add(headStart, 128)\n        let tail_2 := add(add(headStart, shl(5, length)), 128)\n        let _1 := 0x20\n        let srcPtr := add(value0, _1)\n        let i := 0\n        for { } lt(i, length) { i := add(i, 1) }\n        {\n            mstore(pos, add(sub(tail_2, headStart), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80))\n            tail_2 := abi_encode_bytes(mload(srcPtr), tail_2)\n            srcPtr := add(srcPtr, _1)\n            pos := add(pos, _1)\n        }\n        mstore(add(headStart, _1), sub(tail_2, headStart))\n        let tail_3 := abi_encode_array_uint256_dyn(value1, tail_2)\n        mstore(add(headStart, 64), sub(tail_3, headStart))\n        tail := abi_encode_array_uint256_dyn(value2, tail_3)\n    }\n    function abi_decode_tuple_t_contract$_IInterpreterV1_$373t_contract$_IInterpreterStoreV1_$323t_address_fromMemory(headStart, dataEnd) -> value0, value1, value2\n    {\n        if slt(sub(dataEnd, headStart), 96) { revert(0, 0) }\n        let value := mload(headStart)\n        validator_revert_address(value)\n        value0 := value\n        let value_1 := mload(add(headStart, 32))\n        validator_revert_address(value_1)\n        value1 := value_1\n        let value_2 := mload(add(headStart, 64))\n        validator_revert_address(value_2)\n        value2 := value_2\n    }\n    function abi_encode_tuple_t_stringliteral_68ca40b61460257f14e69f48b1a4dbc812e9afc6932f127ef8084544457b3335__to_t_string_memory_ptr__fromStack_reversed(headStart) -> tail\n    {\n        mstore(headStart, 32)\n        mstore(add(headStart, 32), 22)\n        mstore(add(headStart, 64), \"ERC1167: create failed\")\n        tail := add(headStart, 96)\n    }\n    function abi_encode_tuple_t_bytes_memory_ptr__to_t_bytes_memory_ptr__fromStack_reversed(headStart, value0) -> tail\n    {\n        mstore(headStart, 32)\n        tail := abi_encode_bytes(value0, add(headStart, 32))\n    }\n}","id":12,"language":"Yul","name":"#utility.yul"}],"immutableReferences":{},"linkReferences":{},"object":"608060405234801561001057600080fd5b506004361061002b5760003560e01c80630fbe133c14610030575b600080fd5b61004361003e366004610453565b61006c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b600073ffffffffffffffffffffffffffffffffffffffff84166100bb576040517f4208d2eb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006100c6856102f5565b6040805133815273ffffffffffffffffffffffffffffffffffffffff888116602083015283168183015290519192507f274b5f356634f32a865af65bdc3d8205939d9413d75e1f367652e4f3b24d0c3a919081900360600190a16040517f439fab9100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82169063439fab919061017490879087906004016104d8565b600060405180830381600087803b15801561018e57600080fd5b505af11580156101a2573d6000803e3d6000fd5b5092979650505050505050565b805160208201208281146101fe576040517f74fe10f000000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044015b60405180910390fd5b610207826103bd565b505050565b604080516000808252602082019092528190819073ffffffffffffffffffffffffffffffffffffffff851690635511cb679083610259565b60608152602001906001900390816102445790505b5060408051600080825260208201908152818301928390527fffffffff0000000000000000000000000000000000000000000000000000000060e086901b169092526102a99291604482016105c4565b6060604051808303816000875af11580156102c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ec919061066d565b50505050505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f0905073ffffffffffffffffffffffffffffffffffffffff81166103b8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c65640000000000000000000060448201526064016101f5565b919050565b6103c681610401565b6103fe57806040517f644cc2580000000000000000000000000000000000000000000000000000000081526004016101f591906106ba565b50565b600060088251101561041557506000919050565b506008015167ffffffffffffffff1667ff0a89c674ee78741490565b73ffffffffffffffffffffffffffffffffffffffff811681146103fe57600080fd5b60008060006040848603121561046857600080fd5b833561047381610431565b9250602084013567ffffffffffffffff8082111561049057600080fd5b818601915086601f8301126104a457600080fd5b8135818111156104b357600080fd5b8760208285010111156104c557600080fd5b6020830194508093505050509250925092565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b6000815180845260005b8181101561054b5760208185018101518683018201520161052f565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b600081518084526020808501945080840160005b838110156105b95781518752958201959082019060010161059d565b509495945050505050565b6000606082016060835280865180835260808501915060808160051b8601019250602080890160005b83811015610639577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80888703018552610627868351610525565b955093820193908201906001016105ed565b50508584038187015250505061064f8186610589565b905082810360408401526106638185610589565b9695505050505050565b60008060006060848603121561068257600080fd5b835161068d81610431565b602085015190935061069e81610431565b60408501519092506106af81610431565b809150509250925092565b6020815260006106cd6020830184610525565b939250505056","opcodes":"PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x2B JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0xFBE133C EQ PUSH2 0x30 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x43 PUSH2 0x3E CALLDATASIZE PUSH1 0x4 PUSH2 0x453 JUMP JUMPDEST PUSH2 0x6C JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x0 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP5 AND PUSH2 0xBB JUMPI PUSH1 0x40 MLOAD PUSH32 0x4208D2EB00000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0xC6 DUP6 PUSH2 0x2F5 JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD CALLER DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP9 DUP2 AND PUSH1 0x20 DUP4 ADD MSTORE DUP4 AND DUP2 DUP4 ADD MSTORE SWAP1 MLOAD SWAP2 SWAP3 POP PUSH32 0x274B5F356634F32A865AF65BDC3D8205939D9413D75E1F367652E4F3B24D0C3A SWAP2 SWAP1 DUP2 SWAP1 SUB PUSH1 0x60 ADD SWAP1 LOG1 PUSH1 0x40 MLOAD PUSH32 0x439FAB9100000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP3 AND SWAP1 PUSH4 0x439FAB91 SWAP1 PUSH2 0x174 SWAP1 DUP8 SWAP1 DUP8 SWAP1 PUSH1 0x4 ADD PUSH2 0x4D8 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x18E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x1A2 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP SWAP3 SWAP8 SWAP7 POP POP POP POP POP POP POP JUMP JUMPDEST DUP1 MLOAD PUSH1 0x20 DUP3 ADD KECCAK256 DUP3 DUP2 EQ PUSH2 0x1FE JUMPI PUSH1 0x40 MLOAD PUSH32 0x74FE10F000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 DUP2 ADD DUP5 SWAP1 MSTORE PUSH1 0x24 DUP2 ADD DUP3 SWAP1 MSTORE PUSH1 0x44 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x207 DUP3 PUSH2 0x3BD JUMP JUMPDEST POP POP POP JUMP JUMPDEST PUSH1 0x40 DUP1 MLOAD PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD SWAP1 SWAP3 MSTORE DUP2 SWAP1 DUP2 SWAP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP6 AND SWAP1 PUSH4 0x5511CB67 SWAP1 DUP4 PUSH2 0x259 JUMP JUMPDEST PUSH1 0x60 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 PUSH1 0x1 SWAP1 SUB SWAP1 DUP2 PUSH2 0x244 JUMPI SWAP1 POP JUMPDEST POP PUSH1 0x40 DUP1 MLOAD PUSH1 0x0 DUP1 DUP3 MSTORE PUSH1 0x20 DUP3 ADD SWAP1 DUP2 MSTORE DUP2 DUP4 ADD SWAP3 DUP4 SWAP1 MSTORE PUSH32 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000 PUSH1 0xE0 DUP7 SWAP1 SHL AND SWAP1 SWAP3 MSTORE PUSH2 0x2A9 SWAP3 SWAP2 PUSH1 0x44 DUP3 ADD PUSH2 0x5C4 JUMP JUMPDEST PUSH1 0x60 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 GAS CALL ISZERO DUP1 ISZERO PUSH2 0x2C8 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x1F NOT PUSH1 0x1F DUP3 ADD AND DUP3 ADD DUP1 PUSH1 0x40 MSTORE POP DUP2 ADD SWAP1 PUSH2 0x2EC SWAP2 SWAP1 PUSH2 0x66D JUMP JUMPDEST POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH23 0x3D602D80600A3D3981F3363D3D373D3D3D363D73000000 DUP3 PUSH1 0x60 SHL PUSH1 0xE8 SHR OR PUSH1 0x0 MSTORE PUSH15 0x5AF43D82803E903D91602B57FD5BF3 DUP3 PUSH1 0x78 SHL OR PUSH1 0x20 MSTORE PUSH1 0x37 PUSH1 0x9 PUSH1 0x0 CREATE SWAP1 POP PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 AND PUSH2 0x3B8 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x20 PUSH1 0x4 DUP3 ADD MSTORE PUSH1 0x16 PUSH1 0x24 DUP3 ADD MSTORE PUSH32 0x455243313136373A20637265617465206661696C656400000000000000000000 PUSH1 0x44 DUP3 ADD MSTORE PUSH1 0x64 ADD PUSH2 0x1F5 JUMP JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH2 0x3C6 DUP2 PUSH2 0x401 JUMP JUMPDEST PUSH2 0x3FE JUMPI DUP1 PUSH1 0x40 MLOAD PUSH32 0x644CC25800000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x1F5 SWAP2 SWAP1 PUSH2 0x6BA JUMP JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x8 DUP3 MLOAD LT ISZERO PUSH2 0x415 JUMPI POP PUSH1 0x0 SWAP2 SWAP1 POP JUMP JUMPDEST POP PUSH1 0x8 ADD MLOAD PUSH8 0xFFFFFFFFFFFFFFFF AND PUSH8 0xFF0A89C674EE7874 EQ SWAP1 JUMP JUMPDEST PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF DUP2 AND DUP2 EQ PUSH2 0x3FE JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x40 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x468 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 CALLDATALOAD PUSH2 0x473 DUP2 PUSH2 0x431 JUMP JUMPDEST SWAP3 POP PUSH1 0x20 DUP5 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0x490 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 DUP7 ADD SWAP2 POP DUP7 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x4A4 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD DUP2 DUP2 GT ISZERO PUSH2 0x4B3 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP8 PUSH1 0x20 DUP3 DUP6 ADD ADD GT ISZERO PUSH2 0x4C5 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x20 DUP4 ADD SWAP5 POP DUP1 SWAP4 POP POP POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x20 DUP2 MSTORE DUP2 PUSH1 0x20 DUP3 ADD MSTORE DUP2 DUP4 PUSH1 0x40 DUP4 ADD CALLDATACOPY PUSH1 0x0 DUP2 DUP4 ADD PUSH1 0x40 SWAP1 DUP2 ADD SWAP2 SWAP1 SWAP2 MSTORE PUSH1 0x1F SWAP1 SWAP3 ADD PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 AND ADD ADD SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD DUP1 DUP5 MSTORE PUSH1 0x0 JUMPDEST DUP2 DUP2 LT ISZERO PUSH2 0x54B JUMPI PUSH1 0x20 DUP2 DUP6 ADD DUP2 ADD MLOAD DUP7 DUP4 ADD DUP3 ADD MSTORE ADD PUSH2 0x52F JUMP JUMPDEST POP PUSH1 0x0 PUSH1 0x20 DUP3 DUP7 ADD ADD MSTORE PUSH1 0x20 PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 PUSH1 0x1F DUP4 ADD AND DUP6 ADD ADD SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD DUP1 DUP5 MSTORE PUSH1 0x20 DUP1 DUP6 ADD SWAP5 POP DUP1 DUP5 ADD PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x5B9 JUMPI DUP2 MLOAD DUP8 MSTORE SWAP6 DUP3 ADD SWAP6 SWAP1 DUP3 ADD SWAP1 PUSH1 0x1 ADD PUSH2 0x59D JUMP JUMPDEST POP SWAP5 SWAP6 SWAP5 POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x60 DUP3 ADD PUSH1 0x60 DUP4 MSTORE DUP1 DUP7 MLOAD DUP1 DUP4 MSTORE PUSH1 0x80 DUP6 ADD SWAP2 POP PUSH1 0x80 DUP2 PUSH1 0x5 SHL DUP7 ADD ADD SWAP3 POP PUSH1 0x20 DUP1 DUP10 ADD PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x639 JUMPI PUSH32 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF80 DUP9 DUP8 SUB ADD DUP6 MSTORE PUSH2 0x627 DUP7 DUP4 MLOAD PUSH2 0x525 JUMP JUMPDEST SWAP6 POP SWAP4 DUP3 ADD SWAP4 SWAP1 DUP3 ADD SWAP1 PUSH1 0x1 ADD PUSH2 0x5ED JUMP JUMPDEST POP POP DUP6 DUP5 SUB DUP2 DUP8 ADD MSTORE POP POP POP PUSH2 0x64F DUP2 DUP7 PUSH2 0x589 JUMP JUMPDEST SWAP1 POP DUP3 DUP2 SUB PUSH1 0x40 DUP5 ADD MSTORE PUSH2 0x663 DUP2 DUP6 PUSH2 0x589 JUMP JUMPDEST SWAP7 SWAP6 POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x682 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 MLOAD PUSH2 0x68D DUP2 PUSH2 0x431 JUMP JUMPDEST PUSH1 0x20 DUP6 ADD MLOAD SWAP1 SWAP4 POP PUSH2 0x69E DUP2 PUSH2 0x431 JUMP JUMPDEST PUSH1 0x40 DUP6 ADD MLOAD SWAP1 SWAP3 POP PUSH2 0x6AF DUP2 PUSH2 0x431 JUMP JUMPDEST DUP1 SWAP2 POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x20 DUP2 MSTORE PUSH1 0x0 PUSH2 0x6CD PUSH1 0x20 DUP4 ADD DUP5 PUSH2 0x525 JUMP JUMPDEST SWAP4 SWAP3 POP POP POP JUMP ","sourceMap":"518:654:2:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;791:379;;;;;;:::i;:::-;;:::i;:::-;;;1080:42:12;1068:55;;;1050:74;;1038:2;1023:18;791:379:2;;;;;;;;871:7;894:29;;;890:87;;946:20;;;;;;;;;;;;;;890:87;986:14;1003:29;1016:15;1003:12;:29::i;:::-;1047:45;;;1056:10;1398:34:12;;1347:42;1468:15;;;1463:2;1448:18;;1441:43;1520:15;;1500:18;;;1493:43;1047:45:2;;1520:15:12;;-1:-1:-1;1047:45:2;;;;;;1325:2:12;1047:45:2;;;1102:38;;;;;:31;;;;;;:38;;1134:5;;;;1102:38;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;1157:6:2;;791:379;-1:-1:-1;;;;;;;791:379:2:o;1424:292:11:-;1538:16;;;;;;1568:28;;;1564:112;;1619:46;;;;;;;;2173:25:12;;;2214:18;;;2207:34;;;2146:18;;1619:46:11;;;;;;;;1564:112;1685:24;1703:5;1685:17;:24::i;:::-;1506:210;1424:292;;:::o;917:319:9:-;1116:14;;;978:26;1116:14;;;;;;;;;978:26;;;;1067:48;;;;;;978:26;1116:14;;;;;;;;;;;;;;;;;;;-1:-1:-1;1132:16:9;;;1146:1;1132:16;;;;;;1150;;;;;;;;;;1067:100;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;;;917:319:9:o;973:759:1:-;1030:16;1362:48;1344:14;1338:4;1334:25;1328:4;1324:36;1321:90;1315:4;1308:104;1569:32;1552:14;1546:4;1542:25;1539:63;1533:4;1526:77;1644:4;1638;1635:1;1628:21;1616:33;-1:-1:-1;1676:22:1;;;1668:57;;;;;;;5389:2:12;1668:57:1;;;5371:21:12;5428:2;5408:18;;;5401:30;5467:24;5447:18;;;5440:52;5509:18;;1668:57:1;5187:346:12;1668:57:1;973:759;;;:::o;1075:155:11:-;1151:19;1164:5;1151:12;:19::i;:::-;1146:78;;1207:5;1193:20;;;;;;;;;;;:::i;1146:78::-;1075:155;:::o;550:376::-;615:4;650:1;635:5;:12;:16;631:34;;;-1:-1:-1;660:5:11;;550:376;-1:-1:-1;550:376:11:o;631:34::-;-1:-1:-1;846:1:11;835:13;829:20;691:16;825:32;667:18:10;883:36:11;;550:376::o;14:154:12:-;100:42;93:5;89:54;82:5;79:65;69:93;;158:1;155;148:12;173:726;252:6;260;268;321:2;309:9;300:7;296:23;292:32;289:52;;;337:1;334;327:12;289:52;376:9;363:23;395:31;420:5;395:31;:::i;:::-;445:5;-1:-1:-1;501:2:12;486:18;;473:32;524:18;554:14;;;551:34;;;581:1;578;571:12;551:34;619:6;608:9;604:22;594:32;;664:7;657:4;653:2;649:13;645:27;635:55;;686:1;683;676:12;635:55;726:2;713:16;752:2;744:6;741:14;738:34;;;768:1;765;758:12;738:34;813:7;808:2;799:6;795:2;791:15;787:24;784:37;781:57;;;834:1;831;824:12;781:57;865:2;861;857:11;847:21;;887:6;877:16;;;;;173:726;;;;;:::o;1547:447::-;1704:2;1693:9;1686:21;1743:6;1738:2;1727:9;1723:18;1716:34;1800:6;1792;1787:2;1776:9;1772:18;1759:48;1856:1;1827:22;;;1851:2;1823:31;;;1816:42;;;;1910:2;1898:15;;;1915:66;1894:88;1879:104;1875:113;;1547:447;-1:-1:-1;1547:447:12:o;2441:481::-;2482:3;2520:5;2514:12;2547:6;2542:3;2535:19;2572:1;2582:162;2596:6;2593:1;2590:13;2582:162;;;2658:4;2714:13;;;2710:22;;2704:29;2686:11;;;2682:20;;2675:59;2611:12;2582:162;;;2586:3;2789:1;2782:4;2773:6;2768:3;2764:16;2760:27;2753:38;2911:4;2841:66;2836:2;2828:6;2824:15;2820:88;2815:3;2811:98;2807:109;2800:116;;;2441:481;;;;:::o;2927:435::-;2980:3;3018:5;3012:12;3045:6;3040:3;3033:19;3071:4;3100:2;3095:3;3091:12;3084:19;;3137:2;3130:5;3126:14;3158:1;3168:169;3182:6;3179:1;3176:13;3168:169;;;3243:13;;3231:26;;3277:12;;;;3312:15;;;;3204:1;3197:9;3168:169;;;-1:-1:-1;3353:3:12;;2927:435;-1:-1:-1;;;;;2927:435:12:o;3367:1242::-;3683:4;3731:2;3720:9;3716:18;3761:2;3750:9;3743:21;3784:6;3819;3813:13;3850:6;3842;3835:22;3888:3;3877:9;3873:19;3866:26;;3951:3;3941:6;3938:1;3934:14;3923:9;3919:30;3915:40;3901:54;;3974:4;4013:2;4005:6;4001:15;4034:1;4044:313;4058:6;4055:1;4052:13;4044:313;;;4147:66;4135:9;4127:6;4123:22;4119:95;4114:3;4107:108;4238:39;4270:6;4261;4255:13;4238:39;:::i;:::-;4228:49;-1:-1:-1;4335:12:12;;;;4300:15;;;;4080:1;4073:9;4044:313;;;4048:3;;4405:9;4397:6;4393:22;4388:2;4377:9;4373:18;4366:50;;;;4439:44;4476:6;4468;4439:44;:::i;:::-;4425:58;;4531:9;4523:6;4519:22;4514:2;4503:9;4499:18;4492:50;4559:44;4596:6;4588;4559:44;:::i;:::-;4551:52;3367:1242;-1:-1:-1;;;;;;3367:1242:12:o;4614:568::-;4751:6;4759;4767;4820:2;4808:9;4799:7;4795:23;4791:32;4788:52;;;4836:1;4833;4826:12;4788:52;4868:9;4862:16;4887:31;4912:5;4887:31;:::i;:::-;4987:2;4972:18;;4966:25;4937:5;;-1:-1:-1;5000:33:12;4966:25;5000:33;:::i;:::-;5104:2;5089:18;;5083:25;5052:7;;-1:-1:-1;5117:33:12;5083:25;5117:33;:::i;:::-;5169:7;5159:17;;;4614:568;;;;;:::o;5538:217::-;5685:2;5674:9;5667:21;5648:4;5705:44;5745:2;5734:9;5730:18;5722:6;5705:44;:::i;:::-;5697:52;5538:217;-1:-1:-1;;;5538:217:12:o"},"methodIdentifiers":{"clone(address,bytes)":"0fbe133c"}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"internalType\":\"struct DeployerDiscoverableMetaV1ConstructionConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"unmeta\",\"type\":\"bytes\"}],\"name\":\"NotRainMetaV1\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expectedHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actualHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedMetaHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroImplementation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"name\":\"MetaV1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"NewClone\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"NotRainMetaV1(bytes)\":[{\"params\":{\"unmeta\":\"the bytes that are not meta.\"}}],\"UnexpectedMetaHash(bytes32,bytes32)\":[{\"params\":{\"actualHash\":\"The hash of the metadata seen by the `IMetaV1` contract.\",\"expectedHash\":\"The hash expected by the `IMetaV1` contract.\"}}]},\"events\":{\"MetaV1(address,uint256,bytes)\":{\"params\":{\"meta\":\"Rain metadata V1 compliant metadata bytes. https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\",\"sender\":\"The msg.sender.\",\"subject\":\"The entity that the metadata is about. MAY be the address of the emitting contract (as `uint256`) OR anything else. The interpretation of the subject is context specific, so will often be a hash of some data/thing that this metadata is about.\"}},\"NewClone(address,address,address)\":{\"params\":{\"clone\":\"The address of the new proxy contract.\",\"implementation\":\"The reference bytecode to clone as a proxy.\",\"sender\":\"The `msg.sender` that called `clone`.\"}}},\"kind\":\"dev\",\"methods\":{\"clone(address,bytes)\":{\"params\":{\"data\":\"As per `ICloneableV1`.\",\"implementation\":\"The contract to clone.\"},\"returns\":{\"_0\":\"New child contract address.\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"NotRainMetaV1(bytes)\":[{\"notice\":\"Thrown when some bytes are expected to be rain meta and are not.\"}],\"UnexpectedMetaHash(bytes32,bytes32)\":[{\"notice\":\"Thrown when hashed metadata does NOT match the expected hash.\"}],\"ZeroImplementation()\":[{\"notice\":\"Thrown when an implementation is the zero address which is always a mistake.\"}]},\"events\":{\"MetaV1(address,uint256,bytes)\":{\"notice\":\"An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender to the metadata so that tooling can easily drop/ignore data from unknown sources. As metadata is about something, the subject MUST be provided.\"},\"NewClone(address,address,address)\":{\"notice\":\"Emitted upon each `clone`.\"}},\"kind\":\"user\",\"methods\":{\"clone(address,bytes)\":{\"notice\":\"Clones an implementation using a proxy. EIP1167 proxy as used by Open Zeppelin is recommended but the exact cloning procedure is not specified by this interface. The factory MUST call `ICloneableV1.initialize` atomically with the cloning process and MUST NOT call any other functions on the cloned proxy before initialize completes successfully. If the initialize reverts then the `clone` MUST revert. MUST emit `NewClone` with the implementation and clone address.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.factory/src/concrete/CloneFactory.sol\":\"CloneFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x888d64d221d52c31d015b76e50ca1af5ef8ff076550810b49cea6b01d8267a10\",\"license\":\"MIT\"},\"lib/rain.factory/src/concrete/CloneFactory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.18;\\n\\nimport \\\"../interface/ICloneableV1.sol\\\";\\nimport \\\"../interface/ICloneableFactoryV1.sol\\\";\\nimport \\\"rain.interpreter/abstract/DeployerDiscoverableMetaV1.sol\\\";\\nimport {Clones} from \\\"openzeppelin-contracts/contracts/proxy/Clones.sol\\\";\\n\\n/// Thrown when an implementation is the zero address which is always a mistake.\\nerror ZeroImplementation();\\n\\nbytes32 constant CLONE_FACTORY_META_HASH = bytes32(0xae0fb5b68fe1791c72509bf46ea6abf6a982d21451265be0a017f7959712a67e);\\n\\ncontract CloneFactory is ICloneableFactoryV1, DeployerDiscoverableMetaV1 {\\n    constructor(DeployerDiscoverableMetaV1ConstructionConfig memory config_)\\n        DeployerDiscoverableMetaV1(CLONE_FACTORY_META_HASH, config_)\\n    {}\\n\\n    /// @inheritdoc ICloneableFactoryV1\\n    function clone(address implementation_, bytes calldata data_) external returns (address) {\\n        if (implementation_ == address(0)) {\\n            revert ZeroImplementation();\\n        }\\n        address clone_ = Clones.clone(implementation_);\\n        emit NewClone(msg.sender, implementation_, clone_);\\n        ICloneableV1(clone_).initialize(data_);\\n        return clone_;\\n    }\\n}\\n\",\"keccak256\":\"0x9525dfdf6f811c7fd65ad2951a7c901f3a069513895537f373021ca60094d08c\",\"license\":\"CAL\"},\"lib/rain.factory/src/interface/ICloneableFactoryV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @title ICloneableFactoryV1\\n/// @notice A minimal interface to create proxy clones of a reference bytecode\\n/// and emit events so that indexers can discover it. `ICloneableFactoryV1` knows\\n/// nothing about the contracts that it clones, instead relying only on the\\n/// minimal `ICloneableV1` interface being implemented on the reference bytecode.\\ninterface ICloneableFactoryV1 {\\n    /// Emitted upon each `clone`.\\n    /// @param sender The `msg.sender` that called `clone`.\\n    /// @param implementation The reference bytecode to clone as a proxy.\\n    /// @param clone The address of the new proxy contract.\\n    event NewClone(address sender, address implementation, address clone);\\n\\n    /// Clones an implementation using a proxy. EIP1167 proxy as used by Open\\n    /// Zeppelin is recommended but the exact cloning procedure is not specified\\n    /// by this interface. The factory MUST call `ICloneableV1.initialize`\\n    /// atomically with the cloning process and MUST NOT call any other functions\\n    /// on the cloned proxy before initialize completes successfully. If the\\n    /// initialize reverts then the `clone` MUST revert.\\n    /// MUST emit `NewClone` with the implementation and clone address.\\n    /// @param implementation The contract to clone.\\n    /// @param data As per `ICloneableV1`.\\n    /// @return New child contract address.\\n    function clone(address implementation, bytes calldata data) external returns (address);\\n}\\n\",\"keccak256\":\"0x7a54823dba2b60e9af5079f29860bf8baab341549b02aecec8511ee8d9bc2851\",\"license\":\"CAL\"},\"lib/rain.factory/src/interface/ICloneableV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @title ICloneableV1\\n/// @notice Minimal interface following the Open Zeppelin conventions for\\n/// initializing a cloned proxy.\\ninterface ICloneableV1 {\\n    /// Initialize is intended to work like constructors but for cloneable\\n    /// proxies. The `ICloneableV1` contract MUST ensure that initialize cannot\\n    /// be called more than once. The `ICloneableV1` contract is designed to be\\n    /// deployed by an `ICloneFactoryV1` but MUST NOT assume that it will be. It\\n    /// is possible for someone to directly deploy an `ICloneableV1` and fail to\\n    /// call initialize before other functions are called, and end users MAY NOT\\n    /// realise or know how to confirm a safe deployment state. The\\n    /// `ICloneableV1` MUST take appropriate measures to ensure that functions\\n    /// called before initialize are safe to do so, or revert.\\n    ///\\n    /// To be fully generic `initilize` accepts `bytes` and so MUST ABI decode\\n    /// within the initialize function. This allows the factory to service\\n    /// arbitrary cloneable proxies but also erases the type of the\\n    /// initialization config from the ABI. One workaround is to emit an event\\n    /// containing the initialization config type, so that the type appears\\n    /// within the event and therefore the ABI.\\n    /// @param data The initialization data.\\n    function initialize(bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0xe0db9f90f202186f80942f2b19d487658afa777076ccf325b6f853cb6295aaac\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"rain.metadata/IMetaV1.sol\\\";\\nimport \\\"rain.metadata/LibMeta.sol\\\";\\nimport \\\"../lib/LibDeployerDiscoverable.sol\\\";\\n\\n/// Construction config for `DeployerDiscoverableMetaV1`.\\n/// @param deployer Deployer the calling contract will be discoverable under.\\n/// @param meta MetaV1 data to emit before touching the deployer.\\nstruct DeployerDiscoverableMetaV1ConstructionConfig {\\n    address deployer;\\n    bytes meta;\\n}\\n\\n/// @title DeployerDiscoverableMetaV1\\n/// @notice Upon construction, checks metadata against a known hash, emits it\\n/// then touches the deployer (deploy an empty expression). This allows indexers\\n/// to discover the metadata of the `DeployerDiscoverableMetaV1` contract by\\n/// indexing the deployer. In this way the deployer acts as a pseudo-registry by\\n/// virtue of it being a natural hub for interactions with calling contracts.\\nabstract contract DeployerDiscoverableMetaV1 is IMetaV1 {\\n    constructor(bytes32 metaHash, DeployerDiscoverableMetaV1ConstructionConfig memory config) {\\n        LibMeta.checkMetaHashed(metaHash, config.meta);\\n        emit MetaV1(msg.sender, uint256(uint160(address(this))), config.meta);\\n        LibDeployerDiscoverable.touchDeployer(config.deployer);\\n    }\\n}\\n\",\"keccak256\":\"0xa77654c83162f29850efc8e40e108fd800b800348c4007bd078a6ec1c9df626a\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param sources Sources verbatim. These sources MUST be provided in their\\n    /// sequential/index opcode form as the deployment process will need to index\\n    /// into BOTH the integrity check and the final runtime function pointers.\\n    /// This will be emitted in an event for offchain processing to use the\\n    /// indexed opcode sources. The first N sources are considered entrypoints\\n    /// and will be integrity checked by the expression deployer against a\\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\\n    /// internal use such as the `call` opcode but will NOT be integrity checked\\n    /// UNLESS entered by an opcode in an entrypoint.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\",\"keccak256\":\"0xe93e1663f30d95cef4df5e19a371282cef6739b1cda72868439a2c39403732dc\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\",\"keccak256\":\"0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/lib/LibDeployerDiscoverable.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../interface/IExpressionDeployerV1.sol\\\";\\n\\nlibrary LibDeployerDiscoverable {\\n    /// Hack so that some deployer will emit an event with the sender as the\\n    /// caller of `touchDeployer`. This MAY be needed by indexers such as\\n    /// subgraph that can only index events from the first moment they are aware\\n    /// of some contract. The deployer MUST be registered in ERC1820 registry\\n    /// before it is touched, THEN the caller meta MUST be emitted after the\\n    /// deployer is touched. This allows indexers such as subgraph to index the\\n    /// deployer, then see the caller, then see the caller's meta emitted in the\\n    /// same transaction.\\n    /// This is NOT required if ANY other expression is deployed in the same\\n    /// transaction as the caller meta, there only needs to be one expression on\\n    /// ANY deployer known to ERC1820.\\n    function touchDeployer(address deployer) internal {\\n        (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression) =\\n            IExpressionDeployerV1(deployer).deployExpression(new bytes[](0), new uint256[](0), new uint256[](0));\\n        (interpreter);\\n        (store);\\n        (expression);\\n    }\\n}\\n\",\"keccak256\":\"0xa4585885c30fd796b5ae877469f0b2db8e72f08b33f9c534e1a6b0fe7e12d80c\",\"license\":\"CAL\"},\"lib/rain.metadata/src/IMetaV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Thrown when hashed metadata does NOT match the expected hash.\\n/// @param expectedHash The hash expected by the `IMetaV1` contract.\\n/// @param actualHash The hash of the metadata seen by the `IMetaV1` contract.\\nerror UnexpectedMetaHash(bytes32 expectedHash, bytes32 actualHash);\\n\\n/// Thrown when some bytes are expected to be rain meta and are not.\\n/// @param unmeta the bytes that are not meta.\\nerror NotRainMetaV1(bytes unmeta);\\n\\n/// @dev Randomly generated magic number with first bytes oned out.\\n/// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\nuint64 constant META_MAGIC_NUMBER_V1 = 0xff0a89c674ee7874;\\n\\n/// @title IMetaV1\\ninterface IMetaV1 {\\n    /// An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\\n    /// to the metadata so that tooling can easily drop/ignore data from unknown\\n    /// sources. As metadata is about something, the subject MUST be provided.\\n    /// @param sender The msg.sender.\\n    /// @param subject The entity that the metadata is about. MAY be the address\\n    /// of the emitting contract (as `uint256`) OR anything else. The\\n    /// interpretation of the subject is context specific, so will often be a\\n    /// hash of some data/thing that this metadata is about.\\n    /// @param meta Rain metadata V1 compliant metadata bytes.\\n    /// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\n    event MetaV1(address sender, uint256 subject, bytes meta);\\n}\\n\",\"keccak256\":\"0xd1959040fcc89be7a4dc8c9c193e4e5a78b84b05848b86c54d39c3d717ad1843\",\"license\":\"CAL\"},\"lib/rain.metadata/src/LibMeta.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IMetaV1.sol\\\";\\n\\n/// @title LibMeta\\n/// @notice Need a place to put data that can be handled offchain like ABIs that\\n/// IS NOT etherscan.\\nlibrary LibMeta {\\n    /// Returns true if the metadata bytes are prefixed by the Rain meta magic\\n    /// number. DOES NOT attempt to validate the body of the metadata as offchain\\n    /// tooling will be required for this.\\n    /// @param meta_ The data that may be rain metadata.\\n    /// @return True if `meta_` is metadata, false otherwise.\\n    function isRainMetaV1(bytes memory meta_) internal pure returns (bool) {\\n        if (meta_.length < 8) return false;\\n        uint256 mask_ = type(uint64).max;\\n        uint256 magicNumber_ = META_MAGIC_NUMBER_V1;\\n        assembly (\\\"memory-safe\\\") {\\n            magicNumber_ := and(mload(add(meta_, 8)), mask_)\\n        }\\n        return magicNumber_ == META_MAGIC_NUMBER_V1;\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1`.\\n    /// @param meta_ The metadata bytes to check.\\n    function checkMetaUnhashed(bytes memory meta_) internal pure {\\n        if (!isRainMetaV1(meta_)) {\\n            revert NotRainMetaV1(meta_);\\n        }\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1` OR it does not match the expected hash of its data.\\n    /// @param meta_ The metadata to check.\\n    function checkMetaHashed(bytes32 expectedHash_, bytes memory meta_) internal pure {\\n        bytes32 actualHash_ = keccak256(meta_);\\n        if (expectedHash_ != actualHash_) {\\n            revert UnexpectedMetaHash(expectedHash_, actualHash_);\\n        }\\n        checkMetaUnhashed(meta_);\\n    }\\n}\\n\",\"keccak256\":\"0x04665ba6364cc67050b2a245daa780c39039dd51653f7b2029910f242f5dd285\",\"license\":\"CAL\"}},\"version\":1}"}},"lib/rain.factory/src/interface/ICloneableFactoryV1.sol":{"ICloneableFactoryV1":{"abi":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"address","name":"implementation","type":"address"},{"indexed":false,"internalType":"address","name":"clone","type":"address"}],"name":"NewClone","type":"event"},{"inputs":[{"internalType":"address","name":"implementation","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"clone","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"}],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"methodIdentifiers":{"clone(address,bytes)":"0fbe133c"}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"NewClone\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"NewClone(address,address,address)\":{\"params\":{\"clone\":\"The address of the new proxy contract.\",\"implementation\":\"The reference bytecode to clone as a proxy.\",\"sender\":\"The `msg.sender` that called `clone`.\"}}},\"kind\":\"dev\",\"methods\":{\"clone(address,bytes)\":{\"params\":{\"data\":\"As per `ICloneableV1`.\",\"implementation\":\"The contract to clone.\"},\"returns\":{\"_0\":\"New child contract address.\"}}},\"title\":\"ICloneableFactoryV1\",\"version\":1},\"userdoc\":{\"events\":{\"NewClone(address,address,address)\":{\"notice\":\"Emitted upon each `clone`.\"}},\"kind\":\"user\",\"methods\":{\"clone(address,bytes)\":{\"notice\":\"Clones an implementation using a proxy. EIP1167 proxy as used by Open Zeppelin is recommended but the exact cloning procedure is not specified by this interface. The factory MUST call `ICloneableV1.initialize` atomically with the cloning process and MUST NOT call any other functions on the cloned proxy before initialize completes successfully. If the initialize reverts then the `clone` MUST revert. MUST emit `NewClone` with the implementation and clone address.\"}},\"notice\":\"A minimal interface to create proxy clones of a reference bytecode and emit events so that indexers can discover it. `ICloneableFactoryV1` knows nothing about the contracts that it clones, instead relying only on the minimal `ICloneableV1` interface being implemented on the reference bytecode.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.factory/src/interface/ICloneableFactoryV1.sol\":\"ICloneableFactoryV1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/rain.factory/src/interface/ICloneableFactoryV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @title ICloneableFactoryV1\\n/// @notice A minimal interface to create proxy clones of a reference bytecode\\n/// and emit events so that indexers can discover it. `ICloneableFactoryV1` knows\\n/// nothing about the contracts that it clones, instead relying only on the\\n/// minimal `ICloneableV1` interface being implemented on the reference bytecode.\\ninterface ICloneableFactoryV1 {\\n    /// Emitted upon each `clone`.\\n    /// @param sender The `msg.sender` that called `clone`.\\n    /// @param implementation The reference bytecode to clone as a proxy.\\n    /// @param clone The address of the new proxy contract.\\n    event NewClone(address sender, address implementation, address clone);\\n\\n    /// Clones an implementation using a proxy. EIP1167 proxy as used by Open\\n    /// Zeppelin is recommended but the exact cloning procedure is not specified\\n    /// by this interface. The factory MUST call `ICloneableV1.initialize`\\n    /// atomically with the cloning process and MUST NOT call any other functions\\n    /// on the cloned proxy before initialize completes successfully. If the\\n    /// initialize reverts then the `clone` MUST revert.\\n    /// MUST emit `NewClone` with the implementation and clone address.\\n    /// @param implementation The contract to clone.\\n    /// @param data As per `ICloneableV1`.\\n    /// @return New child contract address.\\n    function clone(address implementation, bytes calldata data) external returns (address);\\n}\\n\",\"keccak256\":\"0x7a54823dba2b60e9af5079f29860bf8baab341549b02aecec8511ee8d9bc2851\",\"license\":\"CAL\"}},\"version\":1}"}},"lib/rain.factory/src/interface/ICloneableV1.sol":{"ICloneableV1":{"abi":[{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"}],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"methodIdentifiers":{"initialize(bytes)":"439fab91"}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"initialize(bytes)\":{\"params\":{\"data\":\"The initialization data.\"}}},\"title\":\"ICloneableV1\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"initialize(bytes)\":{\"notice\":\"Initialize is intended to work like constructors but for cloneable proxies. The `ICloneableV1` contract MUST ensure that initialize cannot be called more than once. The `ICloneableV1` contract is designed to be deployed by an `ICloneFactoryV1` but MUST NOT assume that it will be. It is possible for someone to directly deploy an `ICloneableV1` and fail to call initialize before other functions are called, and end users MAY NOT realise or know how to confirm a safe deployment state. The `ICloneableV1` MUST take appropriate measures to ensure that functions called before initialize are safe to do so, or revert. To be fully generic `initilize` accepts `bytes` and so MUST ABI decode within the initialize function. This allows the factory to service arbitrary cloneable proxies but also erases the type of the initialization config from the ABI. One workaround is to emit an event containing the initialization config type, so that the type appears within the event and therefore the ABI.\"}},\"notice\":\"Minimal interface following the Open Zeppelin conventions for initializing a cloned proxy.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.factory/src/interface/ICloneableV1.sol\":\"ICloneableV1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/rain.factory/src/interface/ICloneableV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @title ICloneableV1\\n/// @notice Minimal interface following the Open Zeppelin conventions for\\n/// initializing a cloned proxy.\\ninterface ICloneableV1 {\\n    /// Initialize is intended to work like constructors but for cloneable\\n    /// proxies. The `ICloneableV1` contract MUST ensure that initialize cannot\\n    /// be called more than once. The `ICloneableV1` contract is designed to be\\n    /// deployed by an `ICloneFactoryV1` but MUST NOT assume that it will be. It\\n    /// is possible for someone to directly deploy an `ICloneableV1` and fail to\\n    /// call initialize before other functions are called, and end users MAY NOT\\n    /// realise or know how to confirm a safe deployment state. The\\n    /// `ICloneableV1` MUST take appropriate measures to ensure that functions\\n    /// called before initialize are safe to do so, or revert.\\n    ///\\n    /// To be fully generic `initilize` accepts `bytes` and so MUST ABI decode\\n    /// within the initialize function. This allows the factory to service\\n    /// arbitrary cloneable proxies but also erases the type of the\\n    /// initialization config from the ABI. One workaround is to emit an event\\n    /// containing the initialization config type, so that the type appears\\n    /// within the event and therefore the ABI.\\n    /// @param data The initialization data.\\n    function initialize(bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0xe0db9f90f202186f80942f2b19d487658afa777076ccf325b6f853cb6295aaac\",\"license\":\"CAL\"}},\"version\":1}"}},"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol":{"DeployerDiscoverableMetaV1":{"abi":[{"inputs":[{"internalType":"bytes","name":"unmeta","type":"bytes"}],"name":"NotRainMetaV1","type":"error"},{"inputs":[{"internalType":"bytes32","name":"expectedHash","type":"bytes32"},{"internalType":"bytes32","name":"actualHash","type":"bytes32"}],"name":"UnexpectedMetaHash","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"subject","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"meta","type":"bytes"}],"name":"MetaV1","type":"event"}],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"methodIdentifiers":{}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"unmeta\",\"type\":\"bytes\"}],\"name\":\"NotRainMetaV1\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expectedHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actualHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedMetaHash\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"name\":\"MetaV1\",\"type\":\"event\"}],\"devdoc\":{\"errors\":{\"NotRainMetaV1(bytes)\":[{\"params\":{\"unmeta\":\"the bytes that are not meta.\"}}],\"UnexpectedMetaHash(bytes32,bytes32)\":[{\"params\":{\"actualHash\":\"The hash of the metadata seen by the `IMetaV1` contract.\",\"expectedHash\":\"The hash expected by the `IMetaV1` contract.\"}}]},\"events\":{\"MetaV1(address,uint256,bytes)\":{\"params\":{\"meta\":\"Rain metadata V1 compliant metadata bytes. https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\",\"sender\":\"The msg.sender.\",\"subject\":\"The entity that the metadata is about. MAY be the address of the emitting contract (as `uint256`) OR anything else. The interpretation of the subject is context specific, so will often be a hash of some data/thing that this metadata is about.\"}}},\"kind\":\"dev\",\"methods\":{},\"title\":\"DeployerDiscoverableMetaV1\",\"version\":1},\"userdoc\":{\"errors\":{\"NotRainMetaV1(bytes)\":[{\"notice\":\"Thrown when some bytes are expected to be rain meta and are not.\"}],\"UnexpectedMetaHash(bytes32,bytes32)\":[{\"notice\":\"Thrown when hashed metadata does NOT match the expected hash.\"}]},\"events\":{\"MetaV1(address,uint256,bytes)\":{\"notice\":\"An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender to the metadata so that tooling can easily drop/ignore data from unknown sources. As metadata is about something, the subject MUST be provided.\"}},\"kind\":\"user\",\"methods\":{},\"notice\":\"Upon construction, checks metadata against a known hash, emits it then touches the deployer (deploy an empty expression). This allows indexers to discover the metadata of the `DeployerDiscoverableMetaV1` contract by indexing the deployer. In this way the deployer acts as a pseudo-registry by virtue of it being a natural hub for interactions with calling contracts.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol\":\"DeployerDiscoverableMetaV1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"rain.metadata/IMetaV1.sol\\\";\\nimport \\\"rain.metadata/LibMeta.sol\\\";\\nimport \\\"../lib/LibDeployerDiscoverable.sol\\\";\\n\\n/// Construction config for `DeployerDiscoverableMetaV1`.\\n/// @param deployer Deployer the calling contract will be discoverable under.\\n/// @param meta MetaV1 data to emit before touching the deployer.\\nstruct DeployerDiscoverableMetaV1ConstructionConfig {\\n    address deployer;\\n    bytes meta;\\n}\\n\\n/// @title DeployerDiscoverableMetaV1\\n/// @notice Upon construction, checks metadata against a known hash, emits it\\n/// then touches the deployer (deploy an empty expression). This allows indexers\\n/// to discover the metadata of the `DeployerDiscoverableMetaV1` contract by\\n/// indexing the deployer. In this way the deployer acts as a pseudo-registry by\\n/// virtue of it being a natural hub for interactions with calling contracts.\\nabstract contract DeployerDiscoverableMetaV1 is IMetaV1 {\\n    constructor(bytes32 metaHash, DeployerDiscoverableMetaV1ConstructionConfig memory config) {\\n        LibMeta.checkMetaHashed(metaHash, config.meta);\\n        emit MetaV1(msg.sender, uint256(uint160(address(this))), config.meta);\\n        LibDeployerDiscoverable.touchDeployer(config.deployer);\\n    }\\n}\\n\",\"keccak256\":\"0xa77654c83162f29850efc8e40e108fd800b800348c4007bd078a6ec1c9df626a\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param sources Sources verbatim. These sources MUST be provided in their\\n    /// sequential/index opcode form as the deployment process will need to index\\n    /// into BOTH the integrity check and the final runtime function pointers.\\n    /// This will be emitted in an event for offchain processing to use the\\n    /// indexed opcode sources. The first N sources are considered entrypoints\\n    /// and will be integrity checked by the expression deployer against a\\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\\n    /// internal use such as the `call` opcode but will NOT be integrity checked\\n    /// UNLESS entered by an opcode in an entrypoint.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\",\"keccak256\":\"0xe93e1663f30d95cef4df5e19a371282cef6739b1cda72868439a2c39403732dc\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\",\"keccak256\":\"0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/lib/LibDeployerDiscoverable.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../interface/IExpressionDeployerV1.sol\\\";\\n\\nlibrary LibDeployerDiscoverable {\\n    /// Hack so that some deployer will emit an event with the sender as the\\n    /// caller of `touchDeployer`. This MAY be needed by indexers such as\\n    /// subgraph that can only index events from the first moment they are aware\\n    /// of some contract. The deployer MUST be registered in ERC1820 registry\\n    /// before it is touched, THEN the caller meta MUST be emitted after the\\n    /// deployer is touched. This allows indexers such as subgraph to index the\\n    /// deployer, then see the caller, then see the caller's meta emitted in the\\n    /// same transaction.\\n    /// This is NOT required if ANY other expression is deployed in the same\\n    /// transaction as the caller meta, there only needs to be one expression on\\n    /// ANY deployer known to ERC1820.\\n    function touchDeployer(address deployer) internal {\\n        (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression) =\\n            IExpressionDeployerV1(deployer).deployExpression(new bytes[](0), new uint256[](0), new uint256[](0));\\n        (interpreter);\\n        (store);\\n        (expression);\\n    }\\n}\\n\",\"keccak256\":\"0xa4585885c30fd796b5ae877469f0b2db8e72f08b33f9c534e1a6b0fe7e12d80c\",\"license\":\"CAL\"},\"lib/rain.metadata/src/IMetaV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Thrown when hashed metadata does NOT match the expected hash.\\n/// @param expectedHash The hash expected by the `IMetaV1` contract.\\n/// @param actualHash The hash of the metadata seen by the `IMetaV1` contract.\\nerror UnexpectedMetaHash(bytes32 expectedHash, bytes32 actualHash);\\n\\n/// Thrown when some bytes are expected to be rain meta and are not.\\n/// @param unmeta the bytes that are not meta.\\nerror NotRainMetaV1(bytes unmeta);\\n\\n/// @dev Randomly generated magic number with first bytes oned out.\\n/// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\nuint64 constant META_MAGIC_NUMBER_V1 = 0xff0a89c674ee7874;\\n\\n/// @title IMetaV1\\ninterface IMetaV1 {\\n    /// An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\\n    /// to the metadata so that tooling can easily drop/ignore data from unknown\\n    /// sources. As metadata is about something, the subject MUST be provided.\\n    /// @param sender The msg.sender.\\n    /// @param subject The entity that the metadata is about. MAY be the address\\n    /// of the emitting contract (as `uint256`) OR anything else. The\\n    /// interpretation of the subject is context specific, so will often be a\\n    /// hash of some data/thing that this metadata is about.\\n    /// @param meta Rain metadata V1 compliant metadata bytes.\\n    /// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\n    event MetaV1(address sender, uint256 subject, bytes meta);\\n}\\n\",\"keccak256\":\"0xd1959040fcc89be7a4dc8c9c193e4e5a78b84b05848b86c54d39c3d717ad1843\",\"license\":\"CAL\"},\"lib/rain.metadata/src/LibMeta.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IMetaV1.sol\\\";\\n\\n/// @title LibMeta\\n/// @notice Need a place to put data that can be handled offchain like ABIs that\\n/// IS NOT etherscan.\\nlibrary LibMeta {\\n    /// Returns true if the metadata bytes are prefixed by the Rain meta magic\\n    /// number. DOES NOT attempt to validate the body of the metadata as offchain\\n    /// tooling will be required for this.\\n    /// @param meta_ The data that may be rain metadata.\\n    /// @return True if `meta_` is metadata, false otherwise.\\n    function isRainMetaV1(bytes memory meta_) internal pure returns (bool) {\\n        if (meta_.length < 8) return false;\\n        uint256 mask_ = type(uint64).max;\\n        uint256 magicNumber_ = META_MAGIC_NUMBER_V1;\\n        assembly (\\\"memory-safe\\\") {\\n            magicNumber_ := and(mload(add(meta_, 8)), mask_)\\n        }\\n        return magicNumber_ == META_MAGIC_NUMBER_V1;\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1`.\\n    /// @param meta_ The metadata bytes to check.\\n    function checkMetaUnhashed(bytes memory meta_) internal pure {\\n        if (!isRainMetaV1(meta_)) {\\n            revert NotRainMetaV1(meta_);\\n        }\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1` OR it does not match the expected hash of its data.\\n    /// @param meta_ The metadata to check.\\n    function checkMetaHashed(bytes32 expectedHash_, bytes memory meta_) internal pure {\\n        bytes32 actualHash_ = keccak256(meta_);\\n        if (expectedHash_ != actualHash_) {\\n            revert UnexpectedMetaHash(expectedHash_, actualHash_);\\n        }\\n        checkMetaUnhashed(meta_);\\n    }\\n}\\n\",\"keccak256\":\"0x04665ba6364cc67050b2a245daa780c39039dd51653f7b2029910f242f5dd285\",\"license\":\"CAL\"}},\"version\":1}"}},"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol":{"IExpressionDeployerV1":{"abi":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"address","name":"deployer","type":"address"},{"indexed":false,"internalType":"address","name":"interpreter","type":"address"},{"indexed":false,"internalType":"address","name":"store","type":"address"},{"indexed":false,"internalType":"bytes","name":"opMeta","type":"bytes"}],"name":"DISpair","type":"event"},{"inputs":[{"internalType":"bytes[]","name":"sources","type":"bytes[]"},{"internalType":"uint256[]","name":"constants","type":"uint256[]"},{"internalType":"uint256[]","name":"minOutputs","type":"uint256[]"}],"name":"deployExpression","outputs":[{"internalType":"contract IInterpreterV1","name":"interpreter","type":"address"},{"internalType":"contract IInterpreterStoreV1","name":"store","type":"address"},{"internalType":"address","name":"expression","type":"address"}],"stateMutability":"nonpayable","type":"function"}],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"methodIdentifiers":{"deployExpression(bytes[],uint256[],uint256[])":"5511cb67"}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"store\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"opMeta\",\"type\":\"bytes\"}],\"name\":\"DISpair\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minOutputs\",\"type\":\"uint256[]\"}],\"name\":\"deployExpression\",\"outputs\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"DISpair(address,address,address,address,bytes)\":{\"params\":{\"opMeta\":\"The raw binary data of the op meta. Maybe compressed data etc. and is intended for offchain consumption.\",\"sender\":\"The `msg.sender` providing the op meta.\"}}},\"kind\":\"dev\",\"methods\":{\"deployExpression(bytes[],uint256[],uint256[])\":{\"params\":{\"constants\":\"Constants verbatim. Constants are provided alongside sources rather than inline as it allows us to avoid variable length opcodes and can be more memory efficient if the same constant is referenced several times from the sources.\",\"minOutputs\":\"The first N sources on the state config are entrypoints to the expression where N is the length of the `minOutputs` array. Each item in the `minOutputs` array specifies the number of outputs that MUST be present on the final stack for an evaluation of each entrypoint. The minimum output for some entrypoint MAY be zero if the expectation is that the expression only applies checks and error logic. Non-entrypoint sources MUST NOT have a minimum outputs length specified.\",\"sources\":\"Sources verbatim. These sources MUST be provided in their sequential/index opcode form as the deployment process will need to index into BOTH the integrity check and the final runtime function pointers. This will be emitted in an event for offchain processing to use the indexed opcode sources. The first N sources are considered entrypoints and will be integrity checked by the expression deployer against a starting stack height of 0. Non-entrypoint sources MAY be provided for internal use such as the `call` opcode but will NOT be integrity checked UNLESS entered by an opcode in an entrypoint.\"},\"returns\":{\"expression\":\"The address of the deployed onchain expression. MUST be valid according to all integrity checks the deployer is aware of.\",\"interpreter\":\"The interpreter the deployer believes it is qualified to perform integrity checks on behalf of.\",\"store\":\"The interpreter store the deployer believes is compatible with the interpreter.\"}}},\"title\":\"IExpressionDeployerV1\",\"version\":1},\"userdoc\":{\"events\":{\"DISpair(address,address,address,address,bytes)\":{\"notice\":\"This is the literal InterpreterOpMeta bytes to be used offchain to make sense of the opcodes in this interpreter deployment, as a human. For formats like json that make heavy use of boilerplate, repetition and whitespace, some kind of compression is recommended.\"}},\"kind\":\"user\",\"methods\":{\"deployExpression(bytes[],uint256[],uint256[])\":{\"notice\":\"Expressions are expected to be deployed onchain as immutable contract code with a first class address like any other contract or account. Technically this is optional in the sense that all the tools required to eval some expression and define all its opcodes are available as libraries. In practise there are enough advantages to deploying the sources directly onchain as contract data and loading them from the interpreter at eval: - Loading and storing binary data is gas efficient as immutable contract   data - Expressions need to be immutable between their deploy time integrity   check and runtime evaluation - Passing the address of an expression through calldata to an interpreter   is cheaper than passing an entire expression through calldata - Conceptually a very simple approach, even if implementations like   SSTORE2 are subtle under the hood The expression deployer MUST perform an integrity check of the source code before it puts the expression onchain at a known address. The integrity check MUST at a minimum (it is free to do additional static analysis) calculate the memory required to be allocated for the stack in total, and that no out of bounds memory reads/writes occur within this stack. A simple example of an invalid source would be one that pushes one value to the stack then attempts to pops two values, clearly we cannot remove more values than we added. The `IExpressionDeployerV1` MUST revert in the case of any integrity failure, all integrity checks MUST pass in order for the deployment to complete. Once the integrity check is complete the `IExpressionDeployerV1` MUST do any additional processing required by its paired interpreter. For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed opcodes in the `ExpressionConfig` sources with real function pointers from the corresponding interpreter.\"}},\"notice\":\"Companion to `IInterpreterV1` responsible for onchain static code analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly coupled at the bytecode level to some interpreter that it knows how to analyse and deploy expressions for. The expression deployer can perform an integrity check \\\"dry run\\\" of candidate source code for the intepreter. The critical analysis/transformation includes: - Enforcement of no out of bounds memory reads/writes - Calculation of memory required to eval the stack with a single allocation - Replacing index based opcodes with absolute interpreter function pointers - Enforcement that all opcodes and operands used exist and are valid This analysis is highly sensitive to the specific implementation and position of all opcodes and function pointers as compiled into the interpreter. This is what makes the coupling between an interpreter and expression deployer so tight. Ideally all responsibilities would be handled by a single contract but this introduces code size issues quickly by roughly doubling the compiled logic of each opcode (half for the integrity check and half for evaluation). Interpreters MUST assume that expression deployers are malicious and fail gracefully if the integrity check is corrupt/bypassed and/or function pointers are incorrect, etc. i.e. the interpreter MUST always return a stack from `eval` in a read only way or error. I.e. it is the expression deployer's responsibility to do everything it can to prevent undefined behaviour in the interpreter, and the interpreter's responsibility to handle the expression deployer completely failing to do so.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol\":\"IExpressionDeployerV1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param sources Sources verbatim. These sources MUST be provided in their\\n    /// sequential/index opcode form as the deployment process will need to index\\n    /// into BOTH the integrity check and the final runtime function pointers.\\n    /// This will be emitted in an event for offchain processing to use the\\n    /// indexed opcode sources. The first N sources are considered entrypoints\\n    /// and will be integrity checked by the expression deployer against a\\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\\n    /// internal use such as the `call` opcode but will NOT be integrity checked\\n    /// UNLESS entered by an opcode in an entrypoint.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\",\"keccak256\":\"0xe93e1663f30d95cef4df5e19a371282cef6739b1cda72868439a2c39403732dc\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\",\"keccak256\":\"0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293\",\"license\":\"CAL\"}},\"version\":1}"}},"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol":{"IInterpreterStoreV1":{"abi":[{"inputs":[{"internalType":"FullyQualifiedNamespace","name":"namespace","type":"uint256"},{"internalType":"uint256","name":"key","type":"uint256"}],"name":"get","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"StateNamespace","name":"namespace","type":"uint256"},{"internalType":"uint256[]","name":"kvs","type":"uint256[]"}],"name":"set","outputs":[],"stateMutability":"nonpayable","type":"function"}],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"methodIdentifiers":{"get(uint256,uint256)":"669e48aa","set(uint256,uint256[])":"946aadc6"}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"FullyQualifiedNamespace\",\"name\":\"namespace\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"StateNamespace\",\"name\":\"namespace\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"kvs\",\"type\":\"uint256[]\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"get(uint256,uint256)\":{\"params\":{\"key\":\"The key to get the value for within the namespace.\",\"namespace\":\"The fully qualified namespace to get a single value for.\"},\"returns\":{\"_0\":\"The value OR ZERO IF NOT SET.\"}},\"set(uint256,uint256[])\":{\"params\":{\"kvs\":\"The list of changes to apply to the store's internal state.\",\"namespace\":\"The unqualified namespace for the set that MUST be fully qualified by the `IInterpreterStoreV1` to prevent key collisions between callers. The fully qualified namespace forms a compound key with the keys for each value to set.\"}}},\"title\":\"IInterpreterStoreV1\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"get(uint256,uint256)\":{\"notice\":\"Given a fully qualified namespace and key, return the associated value. Ostensibly the interpreter can use this to implement opcodes that read previously set values. The interpreter MUST apply the same qualification logic as the store that it uses to guarantee consistent round tripping of data and prevent malicious behaviours. Technically also allows onchain reads of any set value from any contract, not just interpreters, but in this case readers MUST be aware and handle inconsistencies between get and set while the state changes are still in memory in the calling context and haven't yet been persisted to the store. `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\"},\"set(uint256,uint256[])\":{\"notice\":\"Mutates the interpreter store in bulk. The bulk values are provided in the form of a `uint256[]` which can be treated e.g. as pairwise keys and values to be stored in a Solidity mapping. The `IInterpreterStoreV1` defines the meaning of the `uint256[]` for its own storage logic.\"}},\"notice\":\"Tracks state changes on behalf of an interpreter. A single store can handle state changes for many calling contracts, many interpreters and many expressions. The store is responsible for ensuring that applying these state changes is safe from key collisions with calls to `set` from different `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the state changes associated with some other caller. The store defines the shape of its own state changes, which is opaque to the calling contract. For example, some store may treat the list of state changes as a pairwise key/value set, and some other store may treat it as a literal list to be stored as-is. Each interpreter decides for itself which store to use based on the compatibility of its own opcodes. The store MUST assume the state changes have been corrupted by the calling contract due to bugs or malicious intent, and enforce state isolation between callers despite arbitrarily invalid state changes. The store MUST revert if it can detect invalid state changes, such as a key/value list having an odd number of items, but this MAY NOT be possible if the corruption is undetectable.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\":\"IInterpreterStoreV1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\",\"keccak256\":\"0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293\",\"license\":\"CAL\"}},\"version\":1}"}},"lib/rain.interpreter/src/interface/IInterpreterV1.sol":{"IInterpreterV1":{"abi":[{"inputs":[{"internalType":"contract IInterpreterStoreV1","name":"store","type":"address"},{"internalType":"StateNamespace","name":"namespace","type":"uint256"},{"internalType":"EncodedDispatch","name":"dispatch","type":"uint256"},{"internalType":"uint256[][]","name":"context","type":"uint256[][]"}],"name":"eval","outputs":[{"internalType":"uint256[]","name":"stack","type":"uint256[]"},{"internalType":"uint256[]","name":"kvs","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"functionPointers","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"}],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"methodIdentifiers":{"eval(address,uint256,uint256,uint256[][])":"6715f825","functionPointers()":"f933c72f"}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"StateNamespace\",\"name\":\"namespace\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"context\",\"type\":\"uint256[][]\"}],\"name\":\"eval\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"stack\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"kvs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"functionPointers\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"eval(address,uint256,uint256,uint256[][])\":{\"params\":{\"context\":\"A 2-dimensional array of data that can be indexed into at runtime by the interpreter. The calling contract is responsible for ensuring the authenticity and completeness of context data. The interpreter MUST revert at runtime if an expression attempts to index into some context value that is not provided by the caller. This implies that context reads cannot be checked for out of bounds reads at deploy time, as the runtime context MAY be provided in a different shape to what the expression is expecting. Same as `eval` but allowing the caller to specify a namespace under which the state changes will be applied. The interpeter MUST ensure that keys will never collide across namespaces, even if, for example: - The calling contract is malicious and attempts to craft a collision   with state changes from another contract - The expression is malicious and attempts to craft a collision with   other expressions evaluated by the same calling contract A malicious entity MAY have access to significant offchain resources to attempt to precompute key collisions through brute force. The collision resistance of namespaces should be comparable or equivalent to the collision resistance of the hashing algorithms employed by the blockchain itself, such as the design of `mapping` in Solidity that hashes each nested key to produce a collision resistant compound key.\",\"dispatch\":\"All the information required for the interpreter to load an expression, select an entrypoint and return the values expected by the caller. The interpreter MAY encode dispatches differently to `LibEncodedDispatch` but this WILL negatively impact compatibility for calling contracts that hardcode the encoding logic.\",\"namespace\":\"The state namespace that will be fully qualified by the interpreter at runtime in order to perform gets on the underlying store. MUST be the same namespace passed to the store by the calling contract when sending the resulting key/value items to storage.\",\"store\":\"The storage contract that the returned key/value pairs MUST be passed to IF the calling contract is in a non-static calling context. Static calling contexts MUST pass `address(0)`.\"},\"returns\":{\"kvs\":\"A list of pairwise key/value items to be saved in the store.\",\"stack\":\"The list of values produced by evaluating the expression. MUST NOT be longer than the maximum length specified by `dispatch`, if applicable.\"}}},\"title\":\"IInterpreterV1 Interface into a standard interpreter that supports: - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1` - receiving arbitrary `uint256[][]` supporting context to be made available   to the evaluated logic - handling subsequent state changes in bulk in response to evaluated logic - namespacing state changes according to the caller's preferences to avoid   unwanted key collisions - exposing its internal function pointers to support external precompilation   of logic for more gas efficient runtime evaluation by the interpreter The interface is designed to be stable across many versions and implementations of an interpreter, balancing minimalism with features required for a general purpose onchain interpreted compute environment. The security model of an interpreter is that it MUST be resilient to malicious expressions even if they dispatch arbitrary internal function pointers during an eval. The interpreter MAY return garbage or exhibit undefined behaviour or error during an eval, _provided that no state changes are persisted_ e.g. in storage, such that only the caller that specifies the malicious expression can be negatively impacted by the result. In turn, the caller must guard itself against arbitrarily corrupt/malicious reverts and return values from any interpreter that it requests an expression from. And so on and so forth up to the externally owned account (EOA) who signs the transaction and agrees to a specific combination of contracts, expressions and interpreters, who can presumably make an informed decision about which ones to trust to get the job done. The state changes for an interpreter are expected to be produces by an `eval` and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the caller, after the caller has had an opportunity to apply their own intermediate logic such as reentrancy defenses against malicious interpreters. The interpreter is free to structure the state changes however it wants but MUST guard against the calling contract corrupting the changes between `eval` and `set`. For example a store could sandbox storage writes per-caller so that a malicious caller can only damage their own state changes, while honest callers respect, benefit from and are protected by the interpreter store's state change handling. The two step eval-state model allows eval to be read-only which provides security guarantees for the caller such as no stateful reentrancy, either from the interpreter or some contract interface used by some word, while still allowing for storage writes. As the storage writes happen on the interpreter rather than the caller (c.f. delegate call) the caller DOES NOT need to trust the interpreter, which allows for permissionless selection of interpreters by end users. Delegate call always implies an admin key on the caller because the delegatee contract can write arbitrarily to the state of the delegator, which severely limits the generality of contract composition.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"eval(address,uint256,uint256,uint256[][])\":{\"notice\":\"The raison d'etre for an interpreter. Given some expression and per-call additional contextual data, produce a stack of results and a set of state changes that the caller MAY OPTIONALLY pass back to be persisted by a call to `IInterpreterStoreV1.set`.\"},\"functionPointers()\":{\"notice\":\"Exposes the function pointers as `uint16` values packed into a single `bytes` in the same order as they would be indexed into by opcodes. For example, if opcode `2` should dispatch function at position `0x1234` then the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is a placeholder for the function pointers of opcodes `0` and `1`. `IExpressionDeployerV1` contracts use these function pointers to \\\"compile\\\" the expression into something that an interpreter can dispatch directly without paying gas to lookup the same at runtime. As the validity of any integrity check and subsequent dispatch is highly sensitive to both the function pointers and overall bytecode of the interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards against accidentally being deployed onchain paired against an unknown interpreter. It is very easy for an apparent compatible pairing to be subtly and critically incompatible due to addition/removal/reordering of opcodes and compiler optimisations on the interpreter bytecode. This MAY return different values during construction vs. all other times after the interpreter has been successfully deployed onchain. DO NOT rely on function pointers reported during contract construction.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interpreter/src/interface/IInterpreterV1.sol\":\"IInterpreterV1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\",\"keccak256\":\"0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293\",\"license\":\"CAL\"}},\"version\":1}"}},"lib/rain.interpreter/src/lib/LibDeployerDiscoverable.sol":{"LibDeployerDiscoverable":{"abi":[],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"60206037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fd","opcodes":"PUSH1 0x20 PUSH1 0x37 PUSH1 0xB DUP3 DUP3 DUP3 CODECOPY DUP1 MLOAD PUSH1 0x0 BYTE PUSH1 0x73 EQ PUSH1 0x2A JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x0 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST ADDRESS PUSH1 0x0 MSTORE PUSH1 0x73 DUP2 MSTORE8 DUP3 DUP2 RETURN INVALID PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT ","sourceMap":"108:1130:9:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;108:1130:9;;;;;;;;;;;;;;;;;"},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"73000000000000000000000000000000000000000030146080604052600080fd","opcodes":"PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT ","sourceMap":"108:1130:9:-:0;;;;;;;;"},"methodIdentifiers":{}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interpreter/src/lib/LibDeployerDiscoverable.sol\":\"LibDeployerDiscoverable\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param sources Sources verbatim. These sources MUST be provided in their\\n    /// sequential/index opcode form as the deployment process will need to index\\n    /// into BOTH the integrity check and the final runtime function pointers.\\n    /// This will be emitted in an event for offchain processing to use the\\n    /// indexed opcode sources. The first N sources are considered entrypoints\\n    /// and will be integrity checked by the expression deployer against a\\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\\n    /// internal use such as the `call` opcode but will NOT be integrity checked\\n    /// UNLESS entered by an opcode in an entrypoint.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\",\"keccak256\":\"0xe93e1663f30d95cef4df5e19a371282cef6739b1cda72868439a2c39403732dc\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xbd9baa8cd30406576f876a76f1c08396561ba93131741af338f63e2414e20619\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/interface/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\",\"keccak256\":\"0xebde08ca2e1c25fc733e0bb8867598715f8ba79772f86db1c8960ad7d68a5293\",\"license\":\"CAL\"},\"lib/rain.interpreter/src/lib/LibDeployerDiscoverable.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../interface/IExpressionDeployerV1.sol\\\";\\n\\nlibrary LibDeployerDiscoverable {\\n    /// Hack so that some deployer will emit an event with the sender as the\\n    /// caller of `touchDeployer`. This MAY be needed by indexers such as\\n    /// subgraph that can only index events from the first moment they are aware\\n    /// of some contract. The deployer MUST be registered in ERC1820 registry\\n    /// before it is touched, THEN the caller meta MUST be emitted after the\\n    /// deployer is touched. This allows indexers such as subgraph to index the\\n    /// deployer, then see the caller, then see the caller's meta emitted in the\\n    /// same transaction.\\n    /// This is NOT required if ANY other expression is deployed in the same\\n    /// transaction as the caller meta, there only needs to be one expression on\\n    /// ANY deployer known to ERC1820.\\n    function touchDeployer(address deployer) internal {\\n        (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression) =\\n            IExpressionDeployerV1(deployer).deployExpression(new bytes[](0), new uint256[](0), new uint256[](0));\\n        (interpreter);\\n        (store);\\n        (expression);\\n    }\\n}\\n\",\"keccak256\":\"0xa4585885c30fd796b5ae877469f0b2db8e72f08b33f9c534e1a6b0fe7e12d80c\",\"license\":\"CAL\"}},\"version\":1}"}},"lib/rain.metadata/src/IMetaV1.sol":{"IMetaV1":{"abi":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"subject","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"meta","type":"bytes"}],"name":"MetaV1","type":"event"}],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"methodIdentifiers":{}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"name\":\"MetaV1\",\"type\":\"event\"}],\"devdoc\":{\"events\":{\"MetaV1(address,uint256,bytes)\":{\"params\":{\"meta\":\"Rain metadata V1 compliant metadata bytes. https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\",\"sender\":\"The msg.sender.\",\"subject\":\"The entity that the metadata is about. MAY be the address of the emitting contract (as `uint256`) OR anything else. The interpretation of the subject is context specific, so will often be a hash of some data/thing that this metadata is about.\"}}},\"kind\":\"dev\",\"methods\":{},\"title\":\"IMetaV1\",\"version\":1},\"userdoc\":{\"events\":{\"MetaV1(address,uint256,bytes)\":{\"notice\":\"An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender to the metadata so that tooling can easily drop/ignore data from unknown sources. As metadata is about something, the subject MUST be provided.\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.metadata/src/IMetaV1.sol\":\"IMetaV1\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/rain.metadata/src/IMetaV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Thrown when hashed metadata does NOT match the expected hash.\\n/// @param expectedHash The hash expected by the `IMetaV1` contract.\\n/// @param actualHash The hash of the metadata seen by the `IMetaV1` contract.\\nerror UnexpectedMetaHash(bytes32 expectedHash, bytes32 actualHash);\\n\\n/// Thrown when some bytes are expected to be rain meta and are not.\\n/// @param unmeta the bytes that are not meta.\\nerror NotRainMetaV1(bytes unmeta);\\n\\n/// @dev Randomly generated magic number with first bytes oned out.\\n/// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\nuint64 constant META_MAGIC_NUMBER_V1 = 0xff0a89c674ee7874;\\n\\n/// @title IMetaV1\\ninterface IMetaV1 {\\n    /// An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\\n    /// to the metadata so that tooling can easily drop/ignore data from unknown\\n    /// sources. As metadata is about something, the subject MUST be provided.\\n    /// @param sender The msg.sender.\\n    /// @param subject The entity that the metadata is about. MAY be the address\\n    /// of the emitting contract (as `uint256`) OR anything else. The\\n    /// interpretation of the subject is context specific, so will often be a\\n    /// hash of some data/thing that this metadata is about.\\n    /// @param meta Rain metadata V1 compliant metadata bytes.\\n    /// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\n    event MetaV1(address sender, uint256 subject, bytes meta);\\n}\\n\",\"keccak256\":\"0xd1959040fcc89be7a4dc8c9c193e4e5a78b84b05848b86c54d39c3d717ad1843\",\"license\":\"CAL\"}},\"version\":1}"}},"lib/rain.metadata/src/LibMeta.sol":{"LibMeta":{"abi":[],"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"60206037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fd","opcodes":"PUSH1 0x20 PUSH1 0x37 PUSH1 0xB DUP3 DUP3 DUP3 CODECOPY DUP1 MLOAD PUSH1 0x0 BYTE PUSH1 0x73 EQ PUSH1 0x2A JUMPI PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x0 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST ADDRESS PUSH1 0x0 MSTORE PUSH1 0x73 DUP2 MSTORE8 DUP3 DUP2 RETURN INVALID PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT ","sourceMap":"205:1513:11:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;205:1513:11;;;;;;;;;;;;;;;;;"},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"73000000000000000000000000000000000000000030146080604052600080fd","opcodes":"PUSH20 0x0 ADDRESS EQ PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT ","sourceMap":"205:1513:11:-:0;;;;;;;;"},"methodIdentifiers":{}},"metadata":"{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"LibMeta\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Need a place to put data that can be handled offchain like ABIs that IS NOT etherscan.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.metadata/src/LibMeta.sol\":\"LibMeta\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/rain.interpreter/lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/rain.interpreter/lib/openzeppelin-contracts/contracts/\",\":rain.cooldown/=lib/rain.cooldown/src/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.flow/=lib/rain.flow/src/\",\":rain.interface.sale/=lib/rain.interface.sale/src/\",\":rain.interpreter/=lib/rain.interpreter/src/\",\":rain.lib.hash/=lib/rain.interpreter/lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\":rain.lib.memkv/=lib/rain.interpreter/lib/rain.lib.memkv/src/\",\":rain.lib.typecast/=lib/rain.lib.typecast/src/\",\":rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\":rain.math.saturating/=lib/rain.math.saturating/src/\",\":rain.metadata/=lib/rain.metadata/src/\",\":rain.orderbook/=lib/rain.orderbook/\",\":sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\":sol.lib.datacontract/=lib/sol.lib.datacontract/src/\",\":sol.lib.memory/=lib/sol.lib.memory/src/\"]},\"sources\":{\"lib/rain.metadata/src/IMetaV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Thrown when hashed metadata does NOT match the expected hash.\\n/// @param expectedHash The hash expected by the `IMetaV1` contract.\\n/// @param actualHash The hash of the metadata seen by the `IMetaV1` contract.\\nerror UnexpectedMetaHash(bytes32 expectedHash, bytes32 actualHash);\\n\\n/// Thrown when some bytes are expected to be rain meta and are not.\\n/// @param unmeta the bytes that are not meta.\\nerror NotRainMetaV1(bytes unmeta);\\n\\n/// @dev Randomly generated magic number with first bytes oned out.\\n/// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\nuint64 constant META_MAGIC_NUMBER_V1 = 0xff0a89c674ee7874;\\n\\n/// @title IMetaV1\\ninterface IMetaV1 {\\n    /// An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\\n    /// to the metadata so that tooling can easily drop/ignore data from unknown\\n    /// sources. As metadata is about something, the subject MUST be provided.\\n    /// @param sender The msg.sender.\\n    /// @param subject The entity that the metadata is about. MAY be the address\\n    /// of the emitting contract (as `uint256`) OR anything else. The\\n    /// interpretation of the subject is context specific, so will often be a\\n    /// hash of some data/thing that this metadata is about.\\n    /// @param meta Rain metadata V1 compliant metadata bytes.\\n    /// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\n    event MetaV1(address sender, uint256 subject, bytes meta);\\n}\\n\",\"keccak256\":\"0xd1959040fcc89be7a4dc8c9c193e4e5a78b84b05848b86c54d39c3d717ad1843\",\"license\":\"CAL\"},\"lib/rain.metadata/src/LibMeta.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IMetaV1.sol\\\";\\n\\n/// @title LibMeta\\n/// @notice Need a place to put data that can be handled offchain like ABIs that\\n/// IS NOT etherscan.\\nlibrary LibMeta {\\n    /// Returns true if the metadata bytes are prefixed by the Rain meta magic\\n    /// number. DOES NOT attempt to validate the body of the metadata as offchain\\n    /// tooling will be required for this.\\n    /// @param meta_ The data that may be rain metadata.\\n    /// @return True if `meta_` is metadata, false otherwise.\\n    function isRainMetaV1(bytes memory meta_) internal pure returns (bool) {\\n        if (meta_.length < 8) return false;\\n        uint256 mask_ = type(uint64).max;\\n        uint256 magicNumber_ = META_MAGIC_NUMBER_V1;\\n        assembly (\\\"memory-safe\\\") {\\n            magicNumber_ := and(mload(add(meta_, 8)), mask_)\\n        }\\n        return magicNumber_ == META_MAGIC_NUMBER_V1;\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1`.\\n    /// @param meta_ The metadata bytes to check.\\n    function checkMetaUnhashed(bytes memory meta_) internal pure {\\n        if (!isRainMetaV1(meta_)) {\\n            revert NotRainMetaV1(meta_);\\n        }\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1` OR it does not match the expected hash of its data.\\n    /// @param meta_ The metadata to check.\\n    function checkMetaHashed(bytes32 expectedHash_, bytes memory meta_) internal pure {\\n        bytes32 actualHash_ = keccak256(meta_);\\n        if (expectedHash_ != actualHash_) {\\n            revert UnexpectedMetaHash(expectedHash_, actualHash_);\\n        }\\n        checkMetaUnhashed(meta_);\\n    }\\n}\\n\",\"keccak256\":\"0x04665ba6364cc67050b2a245daa780c39039dd51653f7b2029910f242f5dd285\",\"license\":\"CAL\"}},\"version\":1}"}}}}}